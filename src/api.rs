// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]
#![allow(clippy::cast_possible_truncation)]

//! Generated file from `api.proto`

use ::std::{vec::Vec, default::Default, fmt::{Display, Formatter}, string::String};

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

///  Message sent at the beginning of each connection
///  Can only be sent by the client and only at the beginning of the connection
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HelloRequest)
pub struct HelloRequest {
    // message fields
    ///  Description of client (like User Agent)
    ///  For example "Home Assistant"
    ///  Not strictly necessary to send but nice for debugging
    ///  purposes.
    // @@protoc_insertion_point(field:HelloRequest.client_info)
    pub client_info: String,
    // @@protoc_insertion_point(field:HelloRequest.api_version_major)
    pub api_version_major: u32,
    // @@protoc_insertion_point(field:HelloRequest.api_version_minor)
    pub api_version_minor: u32,
    // special fields
    // @@protoc_insertion_point(special_field:HelloRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a HelloRequest {
    fn default() -> &'a HelloRequest {
        <HelloRequest as ::protobuf::Message>::default_instance()
    }
}

impl HelloRequest {
    pub fn new() -> HelloRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(3);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_info",
            |m: &HelloRequest| { &m.client_info },
            |m: &mut HelloRequest| { &mut m.client_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "api_version_major",
            |m: &HelloRequest| { &m.api_version_major },
            |m: &mut HelloRequest| { &mut m.api_version_major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "api_version_minor",
            |m: &HelloRequest| { &m.api_version_minor },
            |m: &mut HelloRequest| { &mut m.api_version_minor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HelloRequest>(
            "HelloRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HelloRequest {
    const NAME: &'static str = "HelloRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.client_info = is.read_string()?;
                },
                16 => {
                    self.api_version_major = is.read_uint32()?;
                },
                24 => {
                    self.api_version_minor = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.client_info.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.client_info);
        }
        if self.api_version_major != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.api_version_major);
        }
        if self.api_version_minor != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.api_version_minor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.client_info.is_empty() {
            os.write_string(1, &self.client_info)?;
        }
        if self.api_version_major != 0 {
            os.write_uint32(2, self.api_version_major)?;
        }
        if self.api_version_minor != 0 {
            os.write_uint32(3, self.api_version_minor)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HelloRequest {
        HelloRequest::new()
    }

    fn clear(&mut self) {
        self.client_info.clear();
        self.api_version_major = 0;
        self.api_version_minor = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HelloRequest {
        static instance: HelloRequest = HelloRequest {
            client_info: String::new(),
            api_version_major: 0,
            api_version_minor: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HelloRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HelloRequest").unwrap()).clone()
    }
}

impl Display for HelloRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelloRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Confirmation of successful connection request.
///  Can only be sent by the server and only at the beginning of the connection
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HelloResponse)
pub struct HelloResponse {
    // message fields
    ///  The version of the API to use. The _client_ (for example Home Assistant) needs to check
    ///  for compatibility and if necessary adopt to an older API.
    ///  Major is for breaking changes in the base protocol - a mismatch will lead to immediate disconnect_client_
    ///  Minor is for breaking changes in individual messages - a mismatch will lead to a warning message
    // @@protoc_insertion_point(field:HelloResponse.api_version_major)
    pub api_version_major: u32,
    // @@protoc_insertion_point(field:HelloResponse.api_version_minor)
    pub api_version_minor: u32,
    ///  A string identifying the server (ESP); like client info this may be empty
    ///  and only exists for debugging/logging purposes.
    ///  For example "ESPHome v1.10.0 on ESP8266"
    // @@protoc_insertion_point(field:HelloResponse.server_info)
    pub server_info: String,
    ///  The name of the server (App.get_name())
    // @@protoc_insertion_point(field:HelloResponse.name)
    pub name: String,
    // special fields
    // @@protoc_insertion_point(special_field:HelloResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a HelloResponse {
    fn default() -> &'a HelloResponse {
        <HelloResponse as ::protobuf::Message>::default_instance()
    }
}

impl HelloResponse {
    pub fn new() -> HelloResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(4);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "api_version_major",
            |m: &HelloResponse| { &m.api_version_major },
            |m: &mut HelloResponse| { &mut m.api_version_major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "api_version_minor",
            |m: &HelloResponse| { &m.api_version_minor },
            |m: &mut HelloResponse| { &mut m.api_version_minor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "server_info",
            |m: &HelloResponse| { &m.server_info },
            |m: &mut HelloResponse| { &mut m.server_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &HelloResponse| { &m.name },
            |m: &mut HelloResponse| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HelloResponse>(
            "HelloResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HelloResponse {
    const NAME: &'static str = "HelloResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.api_version_major = is.read_uint32()?;
                },
                16 => {
                    self.api_version_minor = is.read_uint32()?;
                },
                26 => {
                    self.server_info = is.read_string()?;
                },
                34 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.api_version_major != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.api_version_major);
        }
        if self.api_version_minor != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.api_version_minor);
        }
        if !self.server_info.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.server_info);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.api_version_major != 0 {
            os.write_uint32(1, self.api_version_major)?;
        }
        if self.api_version_minor != 0 {
            os.write_uint32(2, self.api_version_minor)?;
        }
        if !self.server_info.is_empty() {
            os.write_string(3, &self.server_info)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HelloResponse {
        HelloResponse::new()
    }

    fn clear(&mut self) {
        self.api_version_major = 0;
        self.api_version_minor = 0;
        self.server_info.clear();
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HelloResponse {
        static instance: HelloResponse = HelloResponse {
            api_version_major: 0,
            api_version_minor: 0,
            server_info: String::new(),
            name: String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HelloResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HelloResponse").unwrap()).clone()
    }
}

impl Display for HelloResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelloResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Message sent at the beginning of each connection to authenticate the client
///  Can only be sent by the client and only at the beginning of the connection
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ConnectRequest)
pub struct ConnectRequest {
    // message fields
    ///  The password to log in with
    // @@protoc_insertion_point(field:ConnectRequest.password)
    pub password: String,
    // special fields
    // @@protoc_insertion_point(special_field:ConnectRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ConnectRequest {
    fn default() -> &'a ConnectRequest {
        <ConnectRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConnectRequest {
    pub fn new() -> ConnectRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(1);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "password",
            |m: &ConnectRequest| { &m.password },
            |m: &mut ConnectRequest| { &mut m.password },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectRequest>(
            "ConnectRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConnectRequest {
    const NAME: &'static str = "ConnectRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.password = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.password.is_empty() {
            os.write_string(1, &self.password)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConnectRequest {
        ConnectRequest::new()
    }

    fn clear(&mut self) {
        self.password.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConnectRequest {
        static instance: ConnectRequest = ConnectRequest {
            password: String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConnectRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConnectRequest").unwrap()).clone()
    }
}

impl Display for ConnectRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Confirmation of successful connection. After this the connection is available for all traffic.
///  Can only be sent by the server and only at the beginning of the connection
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ConnectResponse)
pub struct ConnectResponse {
    // message fields
    // @@protoc_insertion_point(field:ConnectResponse.invalid_password)
    pub invalid_password: bool,
    // special fields
    // @@protoc_insertion_point(special_field:ConnectResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ConnectResponse {
    fn default() -> &'a ConnectResponse {
        <ConnectResponse as ::protobuf::Message>::default_instance()
    }
}

impl ConnectResponse {
    pub fn new() -> ConnectResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(1);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "invalid_password",
            |m: &ConnectResponse| { &m.invalid_password },
            |m: &mut ConnectResponse| { &mut m.invalid_password },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectResponse>(
            "ConnectResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConnectResponse {
    const NAME: &'static str = "ConnectResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.invalid_password = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.invalid_password != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.invalid_password != false {
            os.write_bool(1, self.invalid_password)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConnectResponse {
        ConnectResponse::new()
    }

    fn clear(&mut self) {
        self.invalid_password = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConnectResponse {
        static instance: ConnectResponse = ConnectResponse {
            invalid_password: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConnectResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConnectResponse").unwrap()).clone()
    }
}

impl Display for ConnectResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Request to close the connection.
///  Can be sent by both the client and server
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DisconnectRequest)
pub struct DisconnectRequest {
    // special fields
    // @@protoc_insertion_point(special_field:DisconnectRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a DisconnectRequest {
    fn default() -> &'a DisconnectRequest {
        <DisconnectRequest as ::protobuf::Message>::default_instance()
    }
}

impl DisconnectRequest {
    pub fn new() -> DisconnectRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::new();
        let mut oneofs = Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DisconnectRequest>(
            "DisconnectRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DisconnectRequest {
    const NAME: &'static str = "DisconnectRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DisconnectRequest {
        DisconnectRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DisconnectRequest {
        static instance: DisconnectRequest = DisconnectRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DisconnectRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DisconnectRequest").unwrap()).clone()
    }
}

impl Display for DisconnectRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisconnectRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DisconnectResponse)
pub struct DisconnectResponse {
    // special fields
    // @@protoc_insertion_point(special_field:DisconnectResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a DisconnectResponse {
    fn default() -> &'a DisconnectResponse {
        <DisconnectResponse as ::protobuf::Message>::default_instance()
    }
}

impl DisconnectResponse {
    pub fn new() -> DisconnectResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::new();
        let mut oneofs = Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DisconnectResponse>(
            "DisconnectResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DisconnectResponse {
    const NAME: &'static str = "DisconnectResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DisconnectResponse {
        DisconnectResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DisconnectResponse {
        static instance: DisconnectResponse = DisconnectResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DisconnectResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DisconnectResponse").unwrap()).clone()
    }
}

impl Display for DisconnectResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisconnectResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:PingRequest)
pub struct PingRequest {
    // special fields
    // @@protoc_insertion_point(special_field:PingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a PingRequest {
    fn default() -> &'a PingRequest {
        <PingRequest as ::protobuf::Message>::default_instance()
    }
}

impl PingRequest {
    pub fn new() -> PingRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::new();
        let mut oneofs = Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingRequest>(
            "PingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PingRequest {
    const NAME: &'static str = "PingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PingRequest {
        PingRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PingRequest {
        static instance: PingRequest = PingRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PingRequest").unwrap()).clone()
    }
}

impl Display for PingRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:PingResponse)
pub struct PingResponse {
    // special fields
    // @@protoc_insertion_point(special_field:PingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a PingResponse {
    fn default() -> &'a PingResponse {
        <PingResponse as ::protobuf::Message>::default_instance()
    }
}

impl PingResponse {
    pub fn new() -> PingResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::new();
        let mut oneofs = Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingResponse>(
            "PingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PingResponse {
    const NAME: &'static str = "PingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PingResponse {
        PingResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PingResponse {
        static instance: PingResponse = PingResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PingResponse").unwrap()).clone()
    }
}

impl Display for PingResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DeviceInfoRequest)
pub struct DeviceInfoRequest {
    // special fields
    // @@protoc_insertion_point(special_field:DeviceInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a DeviceInfoRequest {
    fn default() -> &'a DeviceInfoRequest {
        <DeviceInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeviceInfoRequest {
    pub fn new() -> DeviceInfoRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::new();
        let mut oneofs = Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceInfoRequest>(
            "DeviceInfoRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceInfoRequest {
    const NAME: &'static str = "DeviceInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceInfoRequest {
        DeviceInfoRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceInfoRequest {
        static instance: DeviceInfoRequest = DeviceInfoRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceInfoRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceInfoRequest").unwrap()).clone()
    }
}

impl Display for DeviceInfoRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceInfoRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DeviceInfoResponse)
pub struct DeviceInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:DeviceInfoResponse.uses_password)
    pub uses_password: bool,
    ///  The name of the node, given by "App.set_name()"
    // @@protoc_insertion_point(field:DeviceInfoResponse.name)
    pub name: String,
    ///  The mac address of the device. For example "AC:BC:32:89:0E:A9"
    // @@protoc_insertion_point(field:DeviceInfoResponse.mac_address)
    pub mac_address: String,
    ///  A string describing the ESPHome version. For example "1.10.0"
    // @@protoc_insertion_point(field:DeviceInfoResponse.esphome_version)
    pub esphome_version: String,
    ///  A string describing the date of compilation, this is generated by the compiler
    ///  and therefore may not be in the same format all the time.
    ///  If the user isn't using ESPHome, this will also not be set.
    // @@protoc_insertion_point(field:DeviceInfoResponse.compilation_time)
    pub compilation_time: String,
    ///  The model of the board. For example NodeMCU
    // @@protoc_insertion_point(field:DeviceInfoResponse.model)
    pub model: String,
    // @@protoc_insertion_point(field:DeviceInfoResponse.has_deep_sleep)
    pub has_deep_sleep: bool,
    ///  The esphome project details if set
    // @@protoc_insertion_point(field:DeviceInfoResponse.project_name)
    pub project_name: String,
    // @@protoc_insertion_point(field:DeviceInfoResponse.project_version)
    pub project_version: String,
    // @@protoc_insertion_point(field:DeviceInfoResponse.webserver_port)
    pub webserver_port: u32,
    // @@protoc_insertion_point(field:DeviceInfoResponse.bluetooth_proxy_version)
    pub bluetooth_proxy_version: u32,
    // special fields
    // @@protoc_insertion_point(special_field:DeviceInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a DeviceInfoResponse {
    fn default() -> &'a DeviceInfoResponse {
        <DeviceInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeviceInfoResponse {
    pub fn new() -> DeviceInfoResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(11);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uses_password",
            |m: &DeviceInfoResponse| { &m.uses_password },
            |m: &mut DeviceInfoResponse| { &mut m.uses_password },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &DeviceInfoResponse| { &m.name },
            |m: &mut DeviceInfoResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mac_address",
            |m: &DeviceInfoResponse| { &m.mac_address },
            |m: &mut DeviceInfoResponse| { &mut m.mac_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "esphome_version",
            |m: &DeviceInfoResponse| { &m.esphome_version },
            |m: &mut DeviceInfoResponse| { &mut m.esphome_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "compilation_time",
            |m: &DeviceInfoResponse| { &m.compilation_time },
            |m: &mut DeviceInfoResponse| { &mut m.compilation_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model",
            |m: &DeviceInfoResponse| { &m.model },
            |m: &mut DeviceInfoResponse| { &mut m.model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_deep_sleep",
            |m: &DeviceInfoResponse| { &m.has_deep_sleep },
            |m: &mut DeviceInfoResponse| { &mut m.has_deep_sleep },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "project_name",
            |m: &DeviceInfoResponse| { &m.project_name },
            |m: &mut DeviceInfoResponse| { &mut m.project_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "project_version",
            |m: &DeviceInfoResponse| { &m.project_version },
            |m: &mut DeviceInfoResponse| { &mut m.project_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "webserver_port",
            |m: &DeviceInfoResponse| { &m.webserver_port },
            |m: &mut DeviceInfoResponse| { &mut m.webserver_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bluetooth_proxy_version",
            |m: &DeviceInfoResponse| { &m.bluetooth_proxy_version },
            |m: &mut DeviceInfoResponse| { &mut m.bluetooth_proxy_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceInfoResponse>(
            "DeviceInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceInfoResponse {
    const NAME: &'static str = "DeviceInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.uses_password = is.read_bool()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.mac_address = is.read_string()?;
                },
                34 => {
                    self.esphome_version = is.read_string()?;
                },
                42 => {
                    self.compilation_time = is.read_string()?;
                },
                50 => {
                    self.model = is.read_string()?;
                },
                56 => {
                    self.has_deep_sleep = is.read_bool()?;
                },
                66 => {
                    self.project_name = is.read_string()?;
                },
                74 => {
                    self.project_version = is.read_string()?;
                },
                80 => {
                    self.webserver_port = is.read_uint32()?;
                },
                88 => {
                    self.bluetooth_proxy_version = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.uses_password != false {
            my_size += 1 + 1;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.mac_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.mac_address);
        }
        if !self.esphome_version.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.esphome_version);
        }
        if !self.compilation_time.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.compilation_time);
        }
        if !self.model.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.model);
        }
        if self.has_deep_sleep != false {
            my_size += 1 + 1;
        }
        if !self.project_name.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.project_name);
        }
        if !self.project_version.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.project_version);
        }
        if self.webserver_port != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.webserver_port);
        }
        if self.bluetooth_proxy_version != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.bluetooth_proxy_version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.uses_password != false {
            os.write_bool(1, self.uses_password)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.mac_address.is_empty() {
            os.write_string(3, &self.mac_address)?;
        }
        if !self.esphome_version.is_empty() {
            os.write_string(4, &self.esphome_version)?;
        }
        if !self.compilation_time.is_empty() {
            os.write_string(5, &self.compilation_time)?;
        }
        if !self.model.is_empty() {
            os.write_string(6, &self.model)?;
        }
        if self.has_deep_sleep != false {
            os.write_bool(7, self.has_deep_sleep)?;
        }
        if !self.project_name.is_empty() {
            os.write_string(8, &self.project_name)?;
        }
        if !self.project_version.is_empty() {
            os.write_string(9, &self.project_version)?;
        }
        if self.webserver_port != 0 {
            os.write_uint32(10, self.webserver_port)?;
        }
        if self.bluetooth_proxy_version != 0 {
            os.write_uint32(11, self.bluetooth_proxy_version)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceInfoResponse {
        DeviceInfoResponse::new()
    }

    fn clear(&mut self) {
        self.uses_password = false;
        self.name.clear();
        self.mac_address.clear();
        self.esphome_version.clear();
        self.compilation_time.clear();
        self.model.clear();
        self.has_deep_sleep = false;
        self.project_name.clear();
        self.project_version.clear();
        self.webserver_port = 0;
        self.bluetooth_proxy_version = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceInfoResponse {
        static instance: DeviceInfoResponse = DeviceInfoResponse {
            uses_password: false,
            name: String::new(),
            mac_address: String::new(),
            esphome_version: String::new(),
            compilation_time: String::new(),
            model: String::new(),
            has_deep_sleep: false,
            project_name: String::new(),
            project_version: String::new(),
            webserver_port: 0,
            bluetooth_proxy_version: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceInfoResponse").unwrap()).clone()
    }
}

impl Display for DeviceInfoResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListEntitiesRequest)
pub struct ListEntitiesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ListEntitiesRequest {
    fn default() -> &'a ListEntitiesRequest {
        <ListEntitiesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesRequest {
    pub fn new() -> ListEntitiesRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::new();
        let mut oneofs = Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesRequest>(
            "ListEntitiesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesRequest {
    const NAME: &'static str = "ListEntitiesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesRequest {
        ListEntitiesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesRequest {
        static instance: ListEntitiesRequest = ListEntitiesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesRequest").unwrap()).clone()
    }
}

impl Display for ListEntitiesRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListEntitiesDoneResponse)
pub struct ListEntitiesDoneResponse {
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesDoneResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ListEntitiesDoneResponse {
    fn default() -> &'a ListEntitiesDoneResponse {
        <ListEntitiesDoneResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesDoneResponse {
    pub fn new() -> ListEntitiesDoneResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::new();
        let mut oneofs = Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesDoneResponse>(
            "ListEntitiesDoneResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesDoneResponse {
    const NAME: &'static str = "ListEntitiesDoneResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesDoneResponse {
        ListEntitiesDoneResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesDoneResponse {
        static instance: ListEntitiesDoneResponse = ListEntitiesDoneResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesDoneResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesDoneResponse").unwrap()).clone()
    }
}

impl Display for ListEntitiesDoneResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesDoneResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SubscribeStatesRequest)
pub struct SubscribeStatesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeStatesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a SubscribeStatesRequest {
    fn default() -> &'a SubscribeStatesRequest {
        <SubscribeStatesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeStatesRequest {
    pub fn new() -> SubscribeStatesRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::new();
        let mut oneofs = Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeStatesRequest>(
            "SubscribeStatesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeStatesRequest {
    const NAME: &'static str = "SubscribeStatesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeStatesRequest {
        SubscribeStatesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeStatesRequest {
        static instance: SubscribeStatesRequest = SubscribeStatesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeStatesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeStatesRequest").unwrap()).clone()
    }
}

impl Display for SubscribeStatesRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeStatesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ==================== BINARY SENSOR ====================
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListEntitiesBinarySensorResponse)
pub struct ListEntitiesBinarySensorResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesBinarySensorResponse.object_id)
    pub object_id: String,
    // @@protoc_insertion_point(field:ListEntitiesBinarySensorResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesBinarySensorResponse.name)
    pub name: String,
    // @@protoc_insertion_point(field:ListEntitiesBinarySensorResponse.unique_id)
    pub unique_id: String,
    // @@protoc_insertion_point(field:ListEntitiesBinarySensorResponse.device_class)
    pub device_class: String,
    // @@protoc_insertion_point(field:ListEntitiesBinarySensorResponse.is_status_binary_sensor)
    pub is_status_binary_sensor: bool,
    // @@protoc_insertion_point(field:ListEntitiesBinarySensorResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesBinarySensorResponse.icon)
    pub icon: String,
    // @@protoc_insertion_point(field:ListEntitiesBinarySensorResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesBinarySensorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ListEntitiesBinarySensorResponse {
    fn default() -> &'a ListEntitiesBinarySensorResponse {
        <ListEntitiesBinarySensorResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesBinarySensorResponse {
    pub fn new() -> ListEntitiesBinarySensorResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(9);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesBinarySensorResponse| { &m.object_id },
            |m: &mut ListEntitiesBinarySensorResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesBinarySensorResponse| { &m.key },
            |m: &mut ListEntitiesBinarySensorResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesBinarySensorResponse| { &m.name },
            |m: &mut ListEntitiesBinarySensorResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesBinarySensorResponse| { &m.unique_id },
            |m: &mut ListEntitiesBinarySensorResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_class",
            |m: &ListEntitiesBinarySensorResponse| { &m.device_class },
            |m: &mut ListEntitiesBinarySensorResponse| { &mut m.device_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_status_binary_sensor",
            |m: &ListEntitiesBinarySensorResponse| { &m.is_status_binary_sensor },
            |m: &mut ListEntitiesBinarySensorResponse| { &mut m.is_status_binary_sensor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesBinarySensorResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesBinarySensorResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesBinarySensorResponse| { &m.icon },
            |m: &mut ListEntitiesBinarySensorResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesBinarySensorResponse| { &m.entity_category },
            |m: &mut ListEntitiesBinarySensorResponse| { &mut m.entity_category },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesBinarySensorResponse>(
            "ListEntitiesBinarySensorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesBinarySensorResponse {
    const NAME: &'static str = "ListEntitiesBinarySensorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.device_class = is.read_string()?;
                },
                48 => {
                    self.is_status_binary_sensor = is.read_bool()?;
                },
                56 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                66 => {
                    self.icon = is.read_string()?;
                },
                72 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.device_class);
        }
        if self.is_status_binary_sensor != false {
            my_size += 1 + 1;
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.icon);
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(9, self.entity_category.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.device_class.is_empty() {
            os.write_string(5, &self.device_class)?;
        }
        if self.is_status_binary_sensor != false {
            os.write_bool(6, self.is_status_binary_sensor)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(7, self.disabled_by_default)?;
        }
        if !self.icon.is_empty() {
            os.write_string(8, &self.icon)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesBinarySensorResponse {
        ListEntitiesBinarySensorResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.device_class.clear();
        self.is_status_binary_sensor = false;
        self.disabled_by_default = false;
        self.icon.clear();
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesBinarySensorResponse {
        static instance: ListEntitiesBinarySensorResponse = ListEntitiesBinarySensorResponse {
            object_id: String::new(),
            key: 0,
            name: String::new(),
            unique_id: String::new(),
            device_class: String::new(),
            is_status_binary_sensor: false,
            disabled_by_default: false,
            icon: String::new(),
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesBinarySensorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesBinarySensorResponse").unwrap()).clone()
    }
}

impl Display for ListEntitiesBinarySensorResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesBinarySensorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BinarySensorStateResponse)
pub struct BinarySensorStateResponse {
    // message fields
    // @@protoc_insertion_point(field:BinarySensorStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:BinarySensorStateResponse.state)
    pub state: bool,
    ///  If the binary sensor does not have a valid state yet.
    ///  Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
    // @@protoc_insertion_point(field:BinarySensorStateResponse.missing_state)
    pub missing_state: bool,
    // special fields
    // @@protoc_insertion_point(special_field:BinarySensorStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a BinarySensorStateResponse {
    fn default() -> &'a BinarySensorStateResponse {
        <BinarySensorStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl BinarySensorStateResponse {
    pub fn new() -> BinarySensorStateResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(3);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &BinarySensorStateResponse| { &m.key },
            |m: &mut BinarySensorStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &BinarySensorStateResponse| { &m.state },
            |m: &mut BinarySensorStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "missing_state",
            |m: &BinarySensorStateResponse| { &m.missing_state },
            |m: &mut BinarySensorStateResponse| { &mut m.missing_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BinarySensorStateResponse>(
            "BinarySensorStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BinarySensorStateResponse {
    const NAME: &'static str = "BinarySensorStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.state = is.read_bool()?;
                },
                24 => {
                    self.missing_state = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != false {
            my_size += 1 + 1;
        }
        if self.missing_state != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BinarySensorStateResponse {
        BinarySensorStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.missing_state = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BinarySensorStateResponse {
        static instance: BinarySensorStateResponse = BinarySensorStateResponse {
            key: 0,
            state: false,
            missing_state: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BinarySensorStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BinarySensorStateResponse").unwrap()).clone()
    }
}

impl Display for BinarySensorStateResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BinarySensorStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ==================== COVER ====================
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListEntitiesCoverResponse)
pub struct ListEntitiesCoverResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.object_id)
    pub object_id: String,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.name)
    pub name: String,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.unique_id)
    pub unique_id: String,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.assumed_state)
    pub assumed_state: bool,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.supports_position)
    pub supports_position: bool,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.supports_tilt)
    pub supports_tilt: bool,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.device_class)
    pub device_class: String,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.icon)
    pub icon: String,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesCoverResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ListEntitiesCoverResponse {
    fn default() -> &'a ListEntitiesCoverResponse {
        <ListEntitiesCoverResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesCoverResponse {
    pub fn new() -> ListEntitiesCoverResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(11);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesCoverResponse| { &m.object_id },
            |m: &mut ListEntitiesCoverResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesCoverResponse| { &m.key },
            |m: &mut ListEntitiesCoverResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesCoverResponse| { &m.name },
            |m: &mut ListEntitiesCoverResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesCoverResponse| { &m.unique_id },
            |m: &mut ListEntitiesCoverResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "assumed_state",
            |m: &ListEntitiesCoverResponse| { &m.assumed_state },
            |m: &mut ListEntitiesCoverResponse| { &mut m.assumed_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_position",
            |m: &ListEntitiesCoverResponse| { &m.supports_position },
            |m: &mut ListEntitiesCoverResponse| { &mut m.supports_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_tilt",
            |m: &ListEntitiesCoverResponse| { &m.supports_tilt },
            |m: &mut ListEntitiesCoverResponse| { &mut m.supports_tilt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_class",
            |m: &ListEntitiesCoverResponse| { &m.device_class },
            |m: &mut ListEntitiesCoverResponse| { &mut m.device_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesCoverResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesCoverResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesCoverResponse| { &m.icon },
            |m: &mut ListEntitiesCoverResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesCoverResponse| { &m.entity_category },
            |m: &mut ListEntitiesCoverResponse| { &mut m.entity_category },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesCoverResponse>(
            "ListEntitiesCoverResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesCoverResponse {
    const NAME: &'static str = "ListEntitiesCoverResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                40 => {
                    self.assumed_state = is.read_bool()?;
                },
                48 => {
                    self.supports_position = is.read_bool()?;
                },
                56 => {
                    self.supports_tilt = is.read_bool()?;
                },
                66 => {
                    self.device_class = is.read_string()?;
                },
                72 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                82 => {
                    self.icon = is.read_string()?;
                },
                88 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if self.assumed_state != false {
            my_size += 1 + 1;
        }
        if self.supports_position != false {
            my_size += 1 + 1;
        }
        if self.supports_tilt != false {
            my_size += 1 + 1;
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.device_class);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.icon);
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(11, self.entity_category.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if self.assumed_state != false {
            os.write_bool(5, self.assumed_state)?;
        }
        if self.supports_position != false {
            os.write_bool(6, self.supports_position)?;
        }
        if self.supports_tilt != false {
            os.write_bool(7, self.supports_tilt)?;
        }
        if !self.device_class.is_empty() {
            os.write_string(8, &self.device_class)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(9, self.disabled_by_default)?;
        }
        if !self.icon.is_empty() {
            os.write_string(10, &self.icon)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesCoverResponse {
        ListEntitiesCoverResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.assumed_state = false;
        self.supports_position = false;
        self.supports_tilt = false;
        self.device_class.clear();
        self.disabled_by_default = false;
        self.icon.clear();
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesCoverResponse {
        static instance: ListEntitiesCoverResponse = ListEntitiesCoverResponse {
            object_id: String::new(),
            key: 0,
            name: String::new(),
            unique_id: String::new(),
            assumed_state: false,
            supports_position: false,
            supports_tilt: false,
            device_class: String::new(),
            disabled_by_default: false,
            icon: String::new(),
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesCoverResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesCoverResponse").unwrap()).clone()
    }
}

impl Display for ListEntitiesCoverResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesCoverResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CoverStateResponse)
pub struct CoverStateResponse {
    // message fields
    // @@protoc_insertion_point(field:CoverStateResponse.key)
    pub key: u32,
    ///  legacy: state has been removed in 1.13
    ///  clients/servers must still send/accept it until the next protocol change
    // @@protoc_insertion_point(field:CoverStateResponse.legacy_state)
    pub legacy_state: ::protobuf::EnumOrUnknown<LegacyCoverState>,
    // @@protoc_insertion_point(field:CoverStateResponse.position)
    pub position: f32,
    // @@protoc_insertion_point(field:CoverStateResponse.tilt)
    pub tilt: f32,
    // @@protoc_insertion_point(field:CoverStateResponse.current_operation)
    pub current_operation: ::protobuf::EnumOrUnknown<CoverOperation>,
    // special fields
    // @@protoc_insertion_point(special_field:CoverStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a CoverStateResponse {
    fn default() -> &'a CoverStateResponse {
        <CoverStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl CoverStateResponse {
    pub fn new() -> CoverStateResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(5);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &CoverStateResponse| { &m.key },
            |m: &mut CoverStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_state",
            |m: &CoverStateResponse| { &m.legacy_state },
            |m: &mut CoverStateResponse| { &mut m.legacy_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "position",
            |m: &CoverStateResponse| { &m.position },
            |m: &mut CoverStateResponse| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tilt",
            |m: &CoverStateResponse| { &m.tilt },
            |m: &mut CoverStateResponse| { &mut m.tilt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "current_operation",
            |m: &CoverStateResponse| { &m.current_operation },
            |m: &mut CoverStateResponse| { &mut m.current_operation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CoverStateResponse>(
            "CoverStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CoverStateResponse {
    const NAME: &'static str = "CoverStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.legacy_state = is.read_enum_or_unknown()?;
                },
                29 => {
                    self.position = is.read_float()?;
                },
                37 => {
                    self.tilt = is.read_float()?;
                },
                40 => {
                    self.current_operation = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.legacy_state != ::protobuf::EnumOrUnknown::new(LegacyCoverState::LEGACY_COVER_STATE_OPEN) {
            my_size += ::protobuf::rt::int32_size(2, self.legacy_state.value());
        }
        if self.position != 0. {
            my_size += 1 + 4;
        }
        if self.tilt != 0. {
            my_size += 1 + 4;
        }
        if self.current_operation != ::protobuf::EnumOrUnknown::new(CoverOperation::COVER_OPERATION_IDLE) {
            my_size += ::protobuf::rt::int32_size(5, self.current_operation.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.legacy_state != ::protobuf::EnumOrUnknown::new(LegacyCoverState::LEGACY_COVER_STATE_OPEN) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.legacy_state))?;
        }
        if self.position != 0. {
            os.write_float(3, self.position)?;
        }
        if self.tilt != 0. {
            os.write_float(4, self.tilt)?;
        }
        if self.current_operation != ::protobuf::EnumOrUnknown::new(CoverOperation::COVER_OPERATION_IDLE) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.current_operation))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CoverStateResponse {
        CoverStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.legacy_state = ::protobuf::EnumOrUnknown::new(LegacyCoverState::LEGACY_COVER_STATE_OPEN);
        self.position = 0.;
        self.tilt = 0.;
        self.current_operation = ::protobuf::EnumOrUnknown::new(CoverOperation::COVER_OPERATION_IDLE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CoverStateResponse {
        static instance: CoverStateResponse = CoverStateResponse {
            key: 0,
            legacy_state: ::protobuf::EnumOrUnknown::from_i32(0),
            position: 0.,
            tilt: 0.,
            current_operation: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CoverStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CoverStateResponse").unwrap()).clone()
    }
}

impl Display for CoverStateResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoverStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CoverCommandRequest)
pub struct CoverCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:CoverCommandRequest.key)
    pub key: u32,
    ///  legacy: command has been removed in 1.13
    ///  clients/servers must still send/accept it until the next protocol change
    // @@protoc_insertion_point(field:CoverCommandRequest.has_legacy_command)
    pub has_legacy_command: bool,
    // @@protoc_insertion_point(field:CoverCommandRequest.legacy_command)
    pub legacy_command: ::protobuf::EnumOrUnknown<LegacyCoverCommand>,
    // @@protoc_insertion_point(field:CoverCommandRequest.has_position)
    pub has_position: bool,
    // @@protoc_insertion_point(field:CoverCommandRequest.position)
    pub position: f32,
    // @@protoc_insertion_point(field:CoverCommandRequest.has_tilt)
    pub has_tilt: bool,
    // @@protoc_insertion_point(field:CoverCommandRequest.tilt)
    pub tilt: f32,
    // @@protoc_insertion_point(field:CoverCommandRequest.stop)
    pub stop: bool,
    // special fields
    // @@protoc_insertion_point(special_field:CoverCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a CoverCommandRequest {
    fn default() -> &'a CoverCommandRequest {
        <CoverCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl CoverCommandRequest {
    pub fn new() -> CoverCommandRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(8);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &CoverCommandRequest| { &m.key },
            |m: &mut CoverCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_legacy_command",
            |m: &CoverCommandRequest| { &m.has_legacy_command },
            |m: &mut CoverCommandRequest| { &mut m.has_legacy_command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_command",
            |m: &CoverCommandRequest| { &m.legacy_command },
            |m: &mut CoverCommandRequest| { &mut m.legacy_command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_position",
            |m: &CoverCommandRequest| { &m.has_position },
            |m: &mut CoverCommandRequest| { &mut m.has_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "position",
            |m: &CoverCommandRequest| { &m.position },
            |m: &mut CoverCommandRequest| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_tilt",
            |m: &CoverCommandRequest| { &m.has_tilt },
            |m: &mut CoverCommandRequest| { &mut m.has_tilt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tilt",
            |m: &CoverCommandRequest| { &m.tilt },
            |m: &mut CoverCommandRequest| { &mut m.tilt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stop",
            |m: &CoverCommandRequest| { &m.stop },
            |m: &mut CoverCommandRequest| { &mut m.stop },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CoverCommandRequest>(
            "CoverCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CoverCommandRequest {
    const NAME: &'static str = "CoverCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.has_legacy_command = is.read_bool()?;
                },
                24 => {
                    self.legacy_command = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.has_position = is.read_bool()?;
                },
                45 => {
                    self.position = is.read_float()?;
                },
                48 => {
                    self.has_tilt = is.read_bool()?;
                },
                61 => {
                    self.tilt = is.read_float()?;
                },
                64 => {
                    self.stop = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.has_legacy_command != false {
            my_size += 1 + 1;
        }
        if self.legacy_command != ::protobuf::EnumOrUnknown::new(LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN) {
            my_size += ::protobuf::rt::int32_size(3, self.legacy_command.value());
        }
        if self.has_position != false {
            my_size += 1 + 1;
        }
        if self.position != 0. {
            my_size += 1 + 4;
        }
        if self.has_tilt != false {
            my_size += 1 + 1;
        }
        if self.tilt != 0. {
            my_size += 1 + 4;
        }
        if self.stop != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_legacy_command != false {
            os.write_bool(2, self.has_legacy_command)?;
        }
        if self.legacy_command != ::protobuf::EnumOrUnknown::new(LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.legacy_command))?;
        }
        if self.has_position != false {
            os.write_bool(4, self.has_position)?;
        }
        if self.position != 0. {
            os.write_float(5, self.position)?;
        }
        if self.has_tilt != false {
            os.write_bool(6, self.has_tilt)?;
        }
        if self.tilt != 0. {
            os.write_float(7, self.tilt)?;
        }
        if self.stop != false {
            os.write_bool(8, self.stop)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CoverCommandRequest {
        CoverCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.has_legacy_command = false;
        self.legacy_command = ::protobuf::EnumOrUnknown::new(LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN);
        self.has_position = false;
        self.position = 0.;
        self.has_tilt = false;
        self.tilt = 0.;
        self.stop = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CoverCommandRequest {
        static instance: CoverCommandRequest = CoverCommandRequest {
            key: 0,
            has_legacy_command: false,
            legacy_command: ::protobuf::EnumOrUnknown::from_i32(0),
            has_position: false,
            position: 0.,
            has_tilt: false,
            tilt: 0.,
            stop: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CoverCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CoverCommandRequest").unwrap()).clone()
    }
}

impl Display for CoverCommandRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoverCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ==================== FAN ====================
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListEntitiesFanResponse)
pub struct ListEntitiesFanResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.object_id)
    pub object_id: String,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.name)
    pub name: String,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.unique_id)
    pub unique_id: String,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.supports_oscillation)
    pub supports_oscillation: bool,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.supports_speed)
    pub supports_speed: bool,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.supports_direction)
    pub supports_direction: bool,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.supported_speed_count)
    pub supported_speed_count: i32,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.icon)
    pub icon: String,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesFanResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ListEntitiesFanResponse {
    fn default() -> &'a ListEntitiesFanResponse {
        <ListEntitiesFanResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesFanResponse {
    pub fn new() -> ListEntitiesFanResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(11);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesFanResponse| { &m.object_id },
            |m: &mut ListEntitiesFanResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesFanResponse| { &m.key },
            |m: &mut ListEntitiesFanResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesFanResponse| { &m.name },
            |m: &mut ListEntitiesFanResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesFanResponse| { &m.unique_id },
            |m: &mut ListEntitiesFanResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_oscillation",
            |m: &ListEntitiesFanResponse| { &m.supports_oscillation },
            |m: &mut ListEntitiesFanResponse| { &mut m.supports_oscillation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_speed",
            |m: &ListEntitiesFanResponse| { &m.supports_speed },
            |m: &mut ListEntitiesFanResponse| { &mut m.supports_speed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_direction",
            |m: &ListEntitiesFanResponse| { &m.supports_direction },
            |m: &mut ListEntitiesFanResponse| { &mut m.supports_direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supported_speed_count",
            |m: &ListEntitiesFanResponse| { &m.supported_speed_count },
            |m: &mut ListEntitiesFanResponse| { &mut m.supported_speed_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesFanResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesFanResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesFanResponse| { &m.icon },
            |m: &mut ListEntitiesFanResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesFanResponse| { &m.entity_category },
            |m: &mut ListEntitiesFanResponse| { &mut m.entity_category },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesFanResponse>(
            "ListEntitiesFanResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesFanResponse {
    const NAME: &'static str = "ListEntitiesFanResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                40 => {
                    self.supports_oscillation = is.read_bool()?;
                },
                48 => {
                    self.supports_speed = is.read_bool()?;
                },
                56 => {
                    self.supports_direction = is.read_bool()?;
                },
                64 => {
                    self.supported_speed_count = is.read_int32()?;
                },
                72 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                82 => {
                    self.icon = is.read_string()?;
                },
                88 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if self.supports_oscillation != false {
            my_size += 1 + 1;
        }
        if self.supports_speed != false {
            my_size += 1 + 1;
        }
        if self.supports_direction != false {
            my_size += 1 + 1;
        }
        if self.supported_speed_count != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.supported_speed_count);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.icon);
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(11, self.entity_category.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if self.supports_oscillation != false {
            os.write_bool(5, self.supports_oscillation)?;
        }
        if self.supports_speed != false {
            os.write_bool(6, self.supports_speed)?;
        }
        if self.supports_direction != false {
            os.write_bool(7, self.supports_direction)?;
        }
        if self.supported_speed_count != 0 {
            os.write_int32(8, self.supported_speed_count)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(9, self.disabled_by_default)?;
        }
        if !self.icon.is_empty() {
            os.write_string(10, &self.icon)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesFanResponse {
        ListEntitiesFanResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.supports_oscillation = false;
        self.supports_speed = false;
        self.supports_direction = false;
        self.supported_speed_count = 0;
        self.disabled_by_default = false;
        self.icon.clear();
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesFanResponse {
        static instance: ListEntitiesFanResponse = ListEntitiesFanResponse {
            object_id: String::new(),
            key: 0,
            name: String::new(),
            unique_id: String::new(),
            supports_oscillation: false,
            supports_speed: false,
            supports_direction: false,
            supported_speed_count: 0,
            disabled_by_default: false,
            icon: String::new(),
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesFanResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesFanResponse").unwrap()).clone()
    }
}

impl Display for ListEntitiesFanResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesFanResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:FanStateResponse)
pub struct FanStateResponse {
    // message fields
    // @@protoc_insertion_point(field:FanStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:FanStateResponse.state)
    pub state: bool,
    // @@protoc_insertion_point(field:FanStateResponse.oscillating)
    pub oscillating: bool,
    // @@protoc_insertion_point(field:FanStateResponse.speed)
    pub speed: ::protobuf::EnumOrUnknown<FanSpeed>,
    // @@protoc_insertion_point(field:FanStateResponse.direction)
    pub direction: ::protobuf::EnumOrUnknown<FanDirection>,
    // @@protoc_insertion_point(field:FanStateResponse.speed_level)
    pub speed_level: i32,
    // special fields
    // @@protoc_insertion_point(special_field:FanStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a FanStateResponse {
    fn default() -> &'a FanStateResponse {
        <FanStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl FanStateResponse {
    pub fn new() -> FanStateResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(6);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &FanStateResponse| { &m.key },
            |m: &mut FanStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &FanStateResponse| { &m.state },
            |m: &mut FanStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "oscillating",
            |m: &FanStateResponse| { &m.oscillating },
            |m: &mut FanStateResponse| { &mut m.oscillating },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "speed",
            |m: &FanStateResponse| { &m.speed },
            |m: &mut FanStateResponse| { &mut m.speed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "direction",
            |m: &FanStateResponse| { &m.direction },
            |m: &mut FanStateResponse| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "speed_level",
            |m: &FanStateResponse| { &m.speed_level },
            |m: &mut FanStateResponse| { &mut m.speed_level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FanStateResponse>(
            "FanStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FanStateResponse {
    const NAME: &'static str = "FanStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.state = is.read_bool()?;
                },
                24 => {
                    self.oscillating = is.read_bool()?;
                },
                32 => {
                    self.speed = is.read_enum_or_unknown()?;
                },
                40 => {
                    self.direction = is.read_enum_or_unknown()?;
                },
                48 => {
                    self.speed_level = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != false {
            my_size += 1 + 1;
        }
        if self.oscillating != false {
            my_size += 1 + 1;
        }
        if self.speed != ::protobuf::EnumOrUnknown::new(FanSpeed::FAN_SPEED_LOW) {
            my_size += ::protobuf::rt::int32_size(4, self.speed.value());
        }
        if self.direction != ::protobuf::EnumOrUnknown::new(FanDirection::FAN_DIRECTION_FORWARD) {
            my_size += ::protobuf::rt::int32_size(5, self.direction.value());
        }
        if self.speed_level != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.speed_level);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        if self.oscillating != false {
            os.write_bool(3, self.oscillating)?;
        }
        if self.speed != ::protobuf::EnumOrUnknown::new(FanSpeed::FAN_SPEED_LOW) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.speed))?;
        }
        if self.direction != ::protobuf::EnumOrUnknown::new(FanDirection::FAN_DIRECTION_FORWARD) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.direction))?;
        }
        if self.speed_level != 0 {
            os.write_int32(6, self.speed_level)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FanStateResponse {
        FanStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.oscillating = false;
        self.speed = ::protobuf::EnumOrUnknown::new(FanSpeed::FAN_SPEED_LOW);
        self.direction = ::protobuf::EnumOrUnknown::new(FanDirection::FAN_DIRECTION_FORWARD);
        self.speed_level = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FanStateResponse {
        static instance: FanStateResponse = FanStateResponse {
            key: 0,
            state: false,
            oscillating: false,
            speed: ::protobuf::EnumOrUnknown::from_i32(0),
            direction: ::protobuf::EnumOrUnknown::from_i32(0),
            speed_level: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FanStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FanStateResponse").unwrap()).clone()
    }
}

impl Display for FanStateResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FanStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:FanCommandRequest)
pub struct FanCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:FanCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:FanCommandRequest.has_state)
    pub has_state: bool,
    // @@protoc_insertion_point(field:FanCommandRequest.state)
    pub state: bool,
    // @@protoc_insertion_point(field:FanCommandRequest.has_speed)
    pub has_speed: bool,
    // @@protoc_insertion_point(field:FanCommandRequest.speed)
    pub speed: ::protobuf::EnumOrUnknown<FanSpeed>,
    // @@protoc_insertion_point(field:FanCommandRequest.has_oscillating)
    pub has_oscillating: bool,
    // @@protoc_insertion_point(field:FanCommandRequest.oscillating)
    pub oscillating: bool,
    // @@protoc_insertion_point(field:FanCommandRequest.has_direction)
    pub has_direction: bool,
    // @@protoc_insertion_point(field:FanCommandRequest.direction)
    pub direction: ::protobuf::EnumOrUnknown<FanDirection>,
    // @@protoc_insertion_point(field:FanCommandRequest.has_speed_level)
    pub has_speed_level: bool,
    // @@protoc_insertion_point(field:FanCommandRequest.speed_level)
    pub speed_level: i32,
    // special fields
    // @@protoc_insertion_point(special_field:FanCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a FanCommandRequest {
    fn default() -> &'a FanCommandRequest {
        <FanCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl FanCommandRequest {
    pub fn new() -> FanCommandRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(11);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &FanCommandRequest| { &m.key },
            |m: &mut FanCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_state",
            |m: &FanCommandRequest| { &m.has_state },
            |m: &mut FanCommandRequest| { &mut m.has_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &FanCommandRequest| { &m.state },
            |m: &mut FanCommandRequest| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_speed",
            |m: &FanCommandRequest| { &m.has_speed },
            |m: &mut FanCommandRequest| { &mut m.has_speed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "speed",
            |m: &FanCommandRequest| { &m.speed },
            |m: &mut FanCommandRequest| { &mut m.speed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_oscillating",
            |m: &FanCommandRequest| { &m.has_oscillating },
            |m: &mut FanCommandRequest| { &mut m.has_oscillating },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "oscillating",
            |m: &FanCommandRequest| { &m.oscillating },
            |m: &mut FanCommandRequest| { &mut m.oscillating },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_direction",
            |m: &FanCommandRequest| { &m.has_direction },
            |m: &mut FanCommandRequest| { &mut m.has_direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "direction",
            |m: &FanCommandRequest| { &m.direction },
            |m: &mut FanCommandRequest| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_speed_level",
            |m: &FanCommandRequest| { &m.has_speed_level },
            |m: &mut FanCommandRequest| { &mut m.has_speed_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "speed_level",
            |m: &FanCommandRequest| { &m.speed_level },
            |m: &mut FanCommandRequest| { &mut m.speed_level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FanCommandRequest>(
            "FanCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FanCommandRequest {
    const NAME: &'static str = "FanCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.has_state = is.read_bool()?;
                },
                24 => {
                    self.state = is.read_bool()?;
                },
                32 => {
                    self.has_speed = is.read_bool()?;
                },
                40 => {
                    self.speed = is.read_enum_or_unknown()?;
                },
                48 => {
                    self.has_oscillating = is.read_bool()?;
                },
                56 => {
                    self.oscillating = is.read_bool()?;
                },
                64 => {
                    self.has_direction = is.read_bool()?;
                },
                72 => {
                    self.direction = is.read_enum_or_unknown()?;
                },
                80 => {
                    self.has_speed_level = is.read_bool()?;
                },
                88 => {
                    self.speed_level = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.has_state != false {
            my_size += 1 + 1;
        }
        if self.state != false {
            my_size += 1 + 1;
        }
        if self.has_speed != false {
            my_size += 1 + 1;
        }
        if self.speed != ::protobuf::EnumOrUnknown::new(FanSpeed::FAN_SPEED_LOW) {
            my_size += ::protobuf::rt::int32_size(5, self.speed.value());
        }
        if self.has_oscillating != false {
            my_size += 1 + 1;
        }
        if self.oscillating != false {
            my_size += 1 + 1;
        }
        if self.has_direction != false {
            my_size += 1 + 1;
        }
        if self.direction != ::protobuf::EnumOrUnknown::new(FanDirection::FAN_DIRECTION_FORWARD) {
            my_size += ::protobuf::rt::int32_size(9, self.direction.value());
        }
        if self.has_speed_level != false {
            my_size += 1 + 1;
        }
        if self.speed_level != 0 {
            my_size += ::protobuf::rt::int32_size(11, self.speed_level);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_state != false {
            os.write_bool(2, self.has_state)?;
        }
        if self.state != false {
            os.write_bool(3, self.state)?;
        }
        if self.has_speed != false {
            os.write_bool(4, self.has_speed)?;
        }
        if self.speed != ::protobuf::EnumOrUnknown::new(FanSpeed::FAN_SPEED_LOW) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.speed))?;
        }
        if self.has_oscillating != false {
            os.write_bool(6, self.has_oscillating)?;
        }
        if self.oscillating != false {
            os.write_bool(7, self.oscillating)?;
        }
        if self.has_direction != false {
            os.write_bool(8, self.has_direction)?;
        }
        if self.direction != ::protobuf::EnumOrUnknown::new(FanDirection::FAN_DIRECTION_FORWARD) {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.direction))?;
        }
        if self.has_speed_level != false {
            os.write_bool(10, self.has_speed_level)?;
        }
        if self.speed_level != 0 {
            os.write_int32(11, self.speed_level)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FanCommandRequest {
        FanCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.has_state = false;
        self.state = false;
        self.has_speed = false;
        self.speed = ::protobuf::EnumOrUnknown::new(FanSpeed::FAN_SPEED_LOW);
        self.has_oscillating = false;
        self.oscillating = false;
        self.has_direction = false;
        self.direction = ::protobuf::EnumOrUnknown::new(FanDirection::FAN_DIRECTION_FORWARD);
        self.has_speed_level = false;
        self.speed_level = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FanCommandRequest {
        static instance: FanCommandRequest = FanCommandRequest {
            key: 0,
            has_state: false,
            state: false,
            has_speed: false,
            speed: ::protobuf::EnumOrUnknown::from_i32(0),
            has_oscillating: false,
            oscillating: false,
            has_direction: false,
            direction: ::protobuf::EnumOrUnknown::from_i32(0),
            has_speed_level: false,
            speed_level: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FanCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FanCommandRequest").unwrap()).clone()
    }
}

impl Display for FanCommandRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FanCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListEntitiesLightResponse)
pub struct ListEntitiesLightResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.object_id)
    pub object_id: String,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.name)
    pub name: String,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.unique_id)
    pub unique_id: String,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.supported_color_modes)
    pub supported_color_modes: Vec<::protobuf::EnumOrUnknown<ColorMode>>,
    ///  next four supports_* are for legacy clients, newer clients should use color modes
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.legacy_supports_brightness)
    pub legacy_supports_brightness: bool,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.legacy_supports_rgb)
    pub legacy_supports_rgb: bool,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.legacy_supports_white_value)
    pub legacy_supports_white_value: bool,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.legacy_supports_color_temperature)
    pub legacy_supports_color_temperature: bool,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.min_mireds)
    pub min_mireds: f32,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.max_mireds)
    pub max_mireds: f32,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.effects)
    pub effects: Vec<String>,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.icon)
    pub icon: String,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesLightResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ListEntitiesLightResponse {
    fn default() -> &'a ListEntitiesLightResponse {
        <ListEntitiesLightResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesLightResponse {
    pub fn new() -> ListEntitiesLightResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(15);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesLightResponse| { &m.object_id },
            |m: &mut ListEntitiesLightResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesLightResponse| { &m.key },
            |m: &mut ListEntitiesLightResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesLightResponse| { &m.name },
            |m: &mut ListEntitiesLightResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesLightResponse| { &m.unique_id },
            |m: &mut ListEntitiesLightResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_color_modes",
            |m: &ListEntitiesLightResponse| { &m.supported_color_modes },
            |m: &mut ListEntitiesLightResponse| { &mut m.supported_color_modes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_supports_brightness",
            |m: &ListEntitiesLightResponse| { &m.legacy_supports_brightness },
            |m: &mut ListEntitiesLightResponse| { &mut m.legacy_supports_brightness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_supports_rgb",
            |m: &ListEntitiesLightResponse| { &m.legacy_supports_rgb },
            |m: &mut ListEntitiesLightResponse| { &mut m.legacy_supports_rgb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_supports_white_value",
            |m: &ListEntitiesLightResponse| { &m.legacy_supports_white_value },
            |m: &mut ListEntitiesLightResponse| { &mut m.legacy_supports_white_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_supports_color_temperature",
            |m: &ListEntitiesLightResponse| { &m.legacy_supports_color_temperature },
            |m: &mut ListEntitiesLightResponse| { &mut m.legacy_supports_color_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min_mireds",
            |m: &ListEntitiesLightResponse| { &m.min_mireds },
            |m: &mut ListEntitiesLightResponse| { &mut m.min_mireds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_mireds",
            |m: &ListEntitiesLightResponse| { &m.max_mireds },
            |m: &mut ListEntitiesLightResponse| { &mut m.max_mireds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "effects",
            |m: &ListEntitiesLightResponse| { &m.effects },
            |m: &mut ListEntitiesLightResponse| { &mut m.effects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesLightResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesLightResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesLightResponse| { &m.icon },
            |m: &mut ListEntitiesLightResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesLightResponse| { &m.entity_category },
            |m: &mut ListEntitiesLightResponse| { &mut m.entity_category },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesLightResponse>(
            "ListEntitiesLightResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesLightResponse {
    const NAME: &'static str = "ListEntitiesLightResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                96 => {
                    self.supported_color_modes.push(is.read_enum_or_unknown()?);
                },
                98 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_color_modes)?;
                },
                40 => {
                    self.legacy_supports_brightness = is.read_bool()?;
                },
                48 => {
                    self.legacy_supports_rgb = is.read_bool()?;
                },
                56 => {
                    self.legacy_supports_white_value = is.read_bool()?;
                },
                64 => {
                    self.legacy_supports_color_temperature = is.read_bool()?;
                },
                77 => {
                    self.min_mireds = is.read_float()?;
                },
                85 => {
                    self.max_mireds = is.read_float()?;
                },
                90 => {
                    self.effects.push(is.read_string()?);
                },
                104 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                114 => {
                    self.icon = is.read_string()?;
                },
                120 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        for value in &self.supported_color_modes {
            my_size += ::protobuf::rt::int32_size(12, value.value());
        };
        if self.legacy_supports_brightness != false {
            my_size += 1 + 1;
        }
        if self.legacy_supports_rgb != false {
            my_size += 1 + 1;
        }
        if self.legacy_supports_white_value != false {
            my_size += 1 + 1;
        }
        if self.legacy_supports_color_temperature != false {
            my_size += 1 + 1;
        }
        if self.min_mireds != 0. {
            my_size += 1 + 4;
        }
        if self.max_mireds != 0. {
            my_size += 1 + 4;
        }
        for value in &self.effects {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.icon);
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(15, self.entity_category.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        for v in &self.supported_color_modes {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if self.legacy_supports_brightness != false {
            os.write_bool(5, self.legacy_supports_brightness)?;
        }
        if self.legacy_supports_rgb != false {
            os.write_bool(6, self.legacy_supports_rgb)?;
        }
        if self.legacy_supports_white_value != false {
            os.write_bool(7, self.legacy_supports_white_value)?;
        }
        if self.legacy_supports_color_temperature != false {
            os.write_bool(8, self.legacy_supports_color_temperature)?;
        }
        if self.min_mireds != 0. {
            os.write_float(9, self.min_mireds)?;
        }
        if self.max_mireds != 0. {
            os.write_float(10, self.max_mireds)?;
        }
        for v in &self.effects {
            os.write_string(11, &v)?;
        };
        if self.disabled_by_default != false {
            os.write_bool(13, self.disabled_by_default)?;
        }
        if !self.icon.is_empty() {
            os.write_string(14, &self.icon)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(15, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesLightResponse {
        ListEntitiesLightResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.supported_color_modes.clear();
        self.legacy_supports_brightness = false;
        self.legacy_supports_rgb = false;
        self.legacy_supports_white_value = false;
        self.legacy_supports_color_temperature = false;
        self.min_mireds = 0.;
        self.max_mireds = 0.;
        self.effects.clear();
        self.disabled_by_default = false;
        self.icon.clear();
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesLightResponse {
        static instance: ListEntitiesLightResponse = ListEntitiesLightResponse {
            object_id: String::new(),
            key: 0,
            name: String::new(),
            unique_id: String::new(),
            supported_color_modes: Vec::new(),
            legacy_supports_brightness: false,
            legacy_supports_rgb: false,
            legacy_supports_white_value: false,
            legacy_supports_color_temperature: false,
            min_mireds: 0.,
            max_mireds: 0.,
            effects: Vec::new(),
            disabled_by_default: false,
            icon: String::new(),
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesLightResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesLightResponse").unwrap()).clone()
    }
}

impl Display for ListEntitiesLightResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesLightResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:LightStateResponse)
pub struct LightStateResponse {
    // message fields
    // @@protoc_insertion_point(field:LightStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:LightStateResponse.state)
    pub state: bool,
    // @@protoc_insertion_point(field:LightStateResponse.brightness)
    pub brightness: f32,
    // @@protoc_insertion_point(field:LightStateResponse.color_mode)
    pub color_mode: ::protobuf::EnumOrUnknown<ColorMode>,
    // @@protoc_insertion_point(field:LightStateResponse.color_brightness)
    pub color_brightness: f32,
    // @@protoc_insertion_point(field:LightStateResponse.red)
    pub red: f32,
    // @@protoc_insertion_point(field:LightStateResponse.green)
    pub green: f32,
    // @@protoc_insertion_point(field:LightStateResponse.blue)
    pub blue: f32,
    // @@protoc_insertion_point(field:LightStateResponse.white)
    pub white: f32,
    // @@protoc_insertion_point(field:LightStateResponse.color_temperature)
    pub color_temperature: f32,
    // @@protoc_insertion_point(field:LightStateResponse.cold_white)
    pub cold_white: f32,
    // @@protoc_insertion_point(field:LightStateResponse.warm_white)
    pub warm_white: f32,
    // @@protoc_insertion_point(field:LightStateResponse.effect)
    pub effect: String,
    // special fields
    // @@protoc_insertion_point(special_field:LightStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a LightStateResponse {
    fn default() -> &'a LightStateResponse {
        <LightStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl LightStateResponse {
    pub fn new() -> LightStateResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(13);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &LightStateResponse| { &m.key },
            |m: &mut LightStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &LightStateResponse| { &m.state },
            |m: &mut LightStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "brightness",
            |m: &LightStateResponse| { &m.brightness },
            |m: &mut LightStateResponse| { &mut m.brightness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "color_mode",
            |m: &LightStateResponse| { &m.color_mode },
            |m: &mut LightStateResponse| { &mut m.color_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "color_brightness",
            |m: &LightStateResponse| { &m.color_brightness },
            |m: &mut LightStateResponse| { &mut m.color_brightness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "red",
            |m: &LightStateResponse| { &m.red },
            |m: &mut LightStateResponse| { &mut m.red },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "green",
            |m: &LightStateResponse| { &m.green },
            |m: &mut LightStateResponse| { &mut m.green },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "blue",
            |m: &LightStateResponse| { &m.blue },
            |m: &mut LightStateResponse| { &mut m.blue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "white",
            |m: &LightStateResponse| { &m.white },
            |m: &mut LightStateResponse| { &mut m.white },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "color_temperature",
            |m: &LightStateResponse| { &m.color_temperature },
            |m: &mut LightStateResponse| { &mut m.color_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cold_white",
            |m: &LightStateResponse| { &m.cold_white },
            |m: &mut LightStateResponse| { &mut m.cold_white },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "warm_white",
            |m: &LightStateResponse| { &m.warm_white },
            |m: &mut LightStateResponse| { &mut m.warm_white },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "effect",
            |m: &LightStateResponse| { &m.effect },
            |m: &mut LightStateResponse| { &mut m.effect },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LightStateResponse>(
            "LightStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LightStateResponse {
    const NAME: &'static str = "LightStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.state = is.read_bool()?;
                },
                29 => {
                    self.brightness = is.read_float()?;
                },
                88 => {
                    self.color_mode = is.read_enum_or_unknown()?;
                },
                85 => {
                    self.color_brightness = is.read_float()?;
                },
                37 => {
                    self.red = is.read_float()?;
                },
                45 => {
                    self.green = is.read_float()?;
                },
                53 => {
                    self.blue = is.read_float()?;
                },
                61 => {
                    self.white = is.read_float()?;
                },
                69 => {
                    self.color_temperature = is.read_float()?;
                },
                101 => {
                    self.cold_white = is.read_float()?;
                },
                109 => {
                    self.warm_white = is.read_float()?;
                },
                74 => {
                    self.effect = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != false {
            my_size += 1 + 1;
        }
        if self.brightness != 0. {
            my_size += 1 + 4;
        }
        if self.color_mode != ::protobuf::EnumOrUnknown::new(ColorMode::COLOR_MODE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(11, self.color_mode.value());
        }
        if self.color_brightness != 0. {
            my_size += 1 + 4;
        }
        if self.red != 0. {
            my_size += 1 + 4;
        }
        if self.green != 0. {
            my_size += 1 + 4;
        }
        if self.blue != 0. {
            my_size += 1 + 4;
        }
        if self.white != 0. {
            my_size += 1 + 4;
        }
        if self.color_temperature != 0. {
            my_size += 1 + 4;
        }
        if self.cold_white != 0. {
            my_size += 1 + 4;
        }
        if self.warm_white != 0. {
            my_size += 1 + 4;
        }
        if !self.effect.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.effect);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        if self.brightness != 0. {
            os.write_float(3, self.brightness)?;
        }
        if self.color_mode != ::protobuf::EnumOrUnknown::new(ColorMode::COLOR_MODE_UNKNOWN) {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&self.color_mode))?;
        }
        if self.color_brightness != 0. {
            os.write_float(10, self.color_brightness)?;
        }
        if self.red != 0. {
            os.write_float(4, self.red)?;
        }
        if self.green != 0. {
            os.write_float(5, self.green)?;
        }
        if self.blue != 0. {
            os.write_float(6, self.blue)?;
        }
        if self.white != 0. {
            os.write_float(7, self.white)?;
        }
        if self.color_temperature != 0. {
            os.write_float(8, self.color_temperature)?;
        }
        if self.cold_white != 0. {
            os.write_float(12, self.cold_white)?;
        }
        if self.warm_white != 0. {
            os.write_float(13, self.warm_white)?;
        }
        if !self.effect.is_empty() {
            os.write_string(9, &self.effect)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LightStateResponse {
        LightStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.brightness = 0.;
        self.color_mode = ::protobuf::EnumOrUnknown::new(ColorMode::COLOR_MODE_UNKNOWN);
        self.color_brightness = 0.;
        self.red = 0.;
        self.green = 0.;
        self.blue = 0.;
        self.white = 0.;
        self.color_temperature = 0.;
        self.cold_white = 0.;
        self.warm_white = 0.;
        self.effect.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LightStateResponse {
        static instance: LightStateResponse = LightStateResponse {
            key: 0,
            state: false,
            brightness: 0.,
            color_mode: ::protobuf::EnumOrUnknown::from_i32(0),
            color_brightness: 0.,
            red: 0.,
            green: 0.,
            blue: 0.,
            white: 0.,
            color_temperature: 0.,
            cold_white: 0.,
            warm_white: 0.,
            effect: String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LightStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LightStateResponse").unwrap()).clone()
    }
}

impl Display for LightStateResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LightStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:LightCommandRequest)
pub struct LightCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:LightCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_state)
    pub has_state: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.state)
    pub state: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.has_brightness)
    pub has_brightness: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.brightness)
    pub brightness: f32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_color_mode)
    pub has_color_mode: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.color_mode)
    pub color_mode: ::protobuf::EnumOrUnknown<ColorMode>,
    // @@protoc_insertion_point(field:LightCommandRequest.has_color_brightness)
    pub has_color_brightness: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.color_brightness)
    pub color_brightness: f32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_rgb)
    pub has_rgb: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.red)
    pub red: f32,
    // @@protoc_insertion_point(field:LightCommandRequest.green)
    pub green: f32,
    // @@protoc_insertion_point(field:LightCommandRequest.blue)
    pub blue: f32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_white)
    pub has_white: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.white)
    pub white: f32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_color_temperature)
    pub has_color_temperature: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.color_temperature)
    pub color_temperature: f32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_cold_white)
    pub has_cold_white: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.cold_white)
    pub cold_white: f32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_warm_white)
    pub has_warm_white: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.warm_white)
    pub warm_white: f32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_transition_length)
    pub has_transition_length: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.transition_length)
    pub transition_length: u32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_flash_length)
    pub has_flash_length: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.flash_length)
    pub flash_length: u32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_effect)
    pub has_effect: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.effect)
    pub effect: String,
    // special fields
    // @@protoc_insertion_point(special_field:LightCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a LightCommandRequest {
    fn default() -> &'a LightCommandRequest {
        <LightCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl LightCommandRequest {
    pub fn new() -> LightCommandRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(27);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &LightCommandRequest| { &m.key },
            |m: &mut LightCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_state",
            |m: &LightCommandRequest| { &m.has_state },
            |m: &mut LightCommandRequest| { &mut m.has_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &LightCommandRequest| { &m.state },
            |m: &mut LightCommandRequest| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_brightness",
            |m: &LightCommandRequest| { &m.has_brightness },
            |m: &mut LightCommandRequest| { &mut m.has_brightness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "brightness",
            |m: &LightCommandRequest| { &m.brightness },
            |m: &mut LightCommandRequest| { &mut m.brightness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_color_mode",
            |m: &LightCommandRequest| { &m.has_color_mode },
            |m: &mut LightCommandRequest| { &mut m.has_color_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "color_mode",
            |m: &LightCommandRequest| { &m.color_mode },
            |m: &mut LightCommandRequest| { &mut m.color_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_color_brightness",
            |m: &LightCommandRequest| { &m.has_color_brightness },
            |m: &mut LightCommandRequest| { &mut m.has_color_brightness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "color_brightness",
            |m: &LightCommandRequest| { &m.color_brightness },
            |m: &mut LightCommandRequest| { &mut m.color_brightness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_rgb",
            |m: &LightCommandRequest| { &m.has_rgb },
            |m: &mut LightCommandRequest| { &mut m.has_rgb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "red",
            |m: &LightCommandRequest| { &m.red },
            |m: &mut LightCommandRequest| { &mut m.red },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "green",
            |m: &LightCommandRequest| { &m.green },
            |m: &mut LightCommandRequest| { &mut m.green },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "blue",
            |m: &LightCommandRequest| { &m.blue },
            |m: &mut LightCommandRequest| { &mut m.blue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_white",
            |m: &LightCommandRequest| { &m.has_white },
            |m: &mut LightCommandRequest| { &mut m.has_white },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "white",
            |m: &LightCommandRequest| { &m.white },
            |m: &mut LightCommandRequest| { &mut m.white },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_color_temperature",
            |m: &LightCommandRequest| { &m.has_color_temperature },
            |m: &mut LightCommandRequest| { &mut m.has_color_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "color_temperature",
            |m: &LightCommandRequest| { &m.color_temperature },
            |m: &mut LightCommandRequest| { &mut m.color_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_cold_white",
            |m: &LightCommandRequest| { &m.has_cold_white },
            |m: &mut LightCommandRequest| { &mut m.has_cold_white },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cold_white",
            |m: &LightCommandRequest| { &m.cold_white },
            |m: &mut LightCommandRequest| { &mut m.cold_white },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_warm_white",
            |m: &LightCommandRequest| { &m.has_warm_white },
            |m: &mut LightCommandRequest| { &mut m.has_warm_white },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "warm_white",
            |m: &LightCommandRequest| { &m.warm_white },
            |m: &mut LightCommandRequest| { &mut m.warm_white },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_transition_length",
            |m: &LightCommandRequest| { &m.has_transition_length },
            |m: &mut LightCommandRequest| { &mut m.has_transition_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transition_length",
            |m: &LightCommandRequest| { &m.transition_length },
            |m: &mut LightCommandRequest| { &mut m.transition_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_flash_length",
            |m: &LightCommandRequest| { &m.has_flash_length },
            |m: &mut LightCommandRequest| { &mut m.has_flash_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "flash_length",
            |m: &LightCommandRequest| { &m.flash_length },
            |m: &mut LightCommandRequest| { &mut m.flash_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_effect",
            |m: &LightCommandRequest| { &m.has_effect },
            |m: &mut LightCommandRequest| { &mut m.has_effect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "effect",
            |m: &LightCommandRequest| { &m.effect },
            |m: &mut LightCommandRequest| { &mut m.effect },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LightCommandRequest>(
            "LightCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LightCommandRequest {
    const NAME: &'static str = "LightCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.has_state = is.read_bool()?;
                },
                24 => {
                    self.state = is.read_bool()?;
                },
                32 => {
                    self.has_brightness = is.read_bool()?;
                },
                45 => {
                    self.brightness = is.read_float()?;
                },
                176 => {
                    self.has_color_mode = is.read_bool()?;
                },
                184 => {
                    self.color_mode = is.read_enum_or_unknown()?;
                },
                160 => {
                    self.has_color_brightness = is.read_bool()?;
                },
                173 => {
                    self.color_brightness = is.read_float()?;
                },
                48 => {
                    self.has_rgb = is.read_bool()?;
                },
                61 => {
                    self.red = is.read_float()?;
                },
                69 => {
                    self.green = is.read_float()?;
                },
                77 => {
                    self.blue = is.read_float()?;
                },
                80 => {
                    self.has_white = is.read_bool()?;
                },
                93 => {
                    self.white = is.read_float()?;
                },
                96 => {
                    self.has_color_temperature = is.read_bool()?;
                },
                109 => {
                    self.color_temperature = is.read_float()?;
                },
                192 => {
                    self.has_cold_white = is.read_bool()?;
                },
                205 => {
                    self.cold_white = is.read_float()?;
                },
                208 => {
                    self.has_warm_white = is.read_bool()?;
                },
                221 => {
                    self.warm_white = is.read_float()?;
                },
                112 => {
                    self.has_transition_length = is.read_bool()?;
                },
                120 => {
                    self.transition_length = is.read_uint32()?;
                },
                128 => {
                    self.has_flash_length = is.read_bool()?;
                },
                136 => {
                    self.flash_length = is.read_uint32()?;
                },
                144 => {
                    self.has_effect = is.read_bool()?;
                },
                154 => {
                    self.effect = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.has_state != false {
            my_size += 1 + 1;
        }
        if self.state != false {
            my_size += 1 + 1;
        }
        if self.has_brightness != false {
            my_size += 1 + 1;
        }
        if self.brightness != 0. {
            my_size += 1 + 4;
        }
        if self.has_color_mode != false {
            my_size += 2 + 1;
        }
        if self.color_mode != ::protobuf::EnumOrUnknown::new(ColorMode::COLOR_MODE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(23, self.color_mode.value());
        }
        if self.has_color_brightness != false {
            my_size += 2 + 1;
        }
        if self.color_brightness != 0. {
            my_size += 2 + 4;
        }
        if self.has_rgb != false {
            my_size += 1 + 1;
        }
        if self.red != 0. {
            my_size += 1 + 4;
        }
        if self.green != 0. {
            my_size += 1 + 4;
        }
        if self.blue != 0. {
            my_size += 1 + 4;
        }
        if self.has_white != false {
            my_size += 1 + 1;
        }
        if self.white != 0. {
            my_size += 1 + 4;
        }
        if self.has_color_temperature != false {
            my_size += 1 + 1;
        }
        if self.color_temperature != 0. {
            my_size += 1 + 4;
        }
        if self.has_cold_white != false {
            my_size += 2 + 1;
        }
        if self.cold_white != 0. {
            my_size += 2 + 4;
        }
        if self.has_warm_white != false {
            my_size += 2 + 1;
        }
        if self.warm_white != 0. {
            my_size += 2 + 4;
        }
        if self.has_transition_length != false {
            my_size += 1 + 1;
        }
        if self.transition_length != 0 {
            my_size += ::protobuf::rt::uint32_size(15, self.transition_length);
        }
        if self.has_flash_length != false {
            my_size += 2 + 1;
        }
        if self.flash_length != 0 {
            my_size += ::protobuf::rt::uint32_size(17, self.flash_length);
        }
        if self.has_effect != false {
            my_size += 2 + 1;
        }
        if !self.effect.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.effect);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_state != false {
            os.write_bool(2, self.has_state)?;
        }
        if self.state != false {
            os.write_bool(3, self.state)?;
        }
        if self.has_brightness != false {
            os.write_bool(4, self.has_brightness)?;
        }
        if self.brightness != 0. {
            os.write_float(5, self.brightness)?;
        }
        if self.has_color_mode != false {
            os.write_bool(22, self.has_color_mode)?;
        }
        if self.color_mode != ::protobuf::EnumOrUnknown::new(ColorMode::COLOR_MODE_UNKNOWN) {
            os.write_enum(23, ::protobuf::EnumOrUnknown::value(&self.color_mode))?;
        }
        if self.has_color_brightness != false {
            os.write_bool(20, self.has_color_brightness)?;
        }
        if self.color_brightness != 0. {
            os.write_float(21, self.color_brightness)?;
        }
        if self.has_rgb != false {
            os.write_bool(6, self.has_rgb)?;
        }
        if self.red != 0. {
            os.write_float(7, self.red)?;
        }
        if self.green != 0. {
            os.write_float(8, self.green)?;
        }
        if self.blue != 0. {
            os.write_float(9, self.blue)?;
        }
        if self.has_white != false {
            os.write_bool(10, self.has_white)?;
        }
        if self.white != 0. {
            os.write_float(11, self.white)?;
        }
        if self.has_color_temperature != false {
            os.write_bool(12, self.has_color_temperature)?;
        }
        if self.color_temperature != 0. {
            os.write_float(13, self.color_temperature)?;
        }
        if self.has_cold_white != false {
            os.write_bool(24, self.has_cold_white)?;
        }
        if self.cold_white != 0. {
            os.write_float(25, self.cold_white)?;
        }
        if self.has_warm_white != false {
            os.write_bool(26, self.has_warm_white)?;
        }
        if self.warm_white != 0. {
            os.write_float(27, self.warm_white)?;
        }
        if self.has_transition_length != false {
            os.write_bool(14, self.has_transition_length)?;
        }
        if self.transition_length != 0 {
            os.write_uint32(15, self.transition_length)?;
        }
        if self.has_flash_length != false {
            os.write_bool(16, self.has_flash_length)?;
        }
        if self.flash_length != 0 {
            os.write_uint32(17, self.flash_length)?;
        }
        if self.has_effect != false {
            os.write_bool(18, self.has_effect)?;
        }
        if !self.effect.is_empty() {
            os.write_string(19, &self.effect)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LightCommandRequest {
        LightCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.has_state = false;
        self.state = false;
        self.has_brightness = false;
        self.brightness = 0.;
        self.has_color_mode = false;
        self.color_mode = ::protobuf::EnumOrUnknown::new(ColorMode::COLOR_MODE_UNKNOWN);
        self.has_color_brightness = false;
        self.color_brightness = 0.;
        self.has_rgb = false;
        self.red = 0.;
        self.green = 0.;
        self.blue = 0.;
        self.has_white = false;
        self.white = 0.;
        self.has_color_temperature = false;
        self.color_temperature = 0.;
        self.has_cold_white = false;
        self.cold_white = 0.;
        self.has_warm_white = false;
        self.warm_white = 0.;
        self.has_transition_length = false;
        self.transition_length = 0;
        self.has_flash_length = false;
        self.flash_length = 0;
        self.has_effect = false;
        self.effect.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LightCommandRequest {
        static instance: LightCommandRequest = LightCommandRequest {
            key: 0,
            has_state: false,
            state: false,
            has_brightness: false,
            brightness: 0.,
            has_color_mode: false,
            color_mode: ::protobuf::EnumOrUnknown::from_i32(0),
            has_color_brightness: false,
            color_brightness: 0.,
            has_rgb: false,
            red: 0.,
            green: 0.,
            blue: 0.,
            has_white: false,
            white: 0.,
            has_color_temperature: false,
            color_temperature: 0.,
            has_cold_white: false,
            cold_white: 0.,
            has_warm_white: false,
            warm_white: 0.,
            has_transition_length: false,
            transition_length: 0,
            has_flash_length: false,
            flash_length: 0,
            has_effect: false,
            effect: String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LightCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LightCommandRequest").unwrap()).clone()
    }
}

impl Display for LightCommandRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LightCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListEntitiesSensorResponse)
pub struct ListEntitiesSensorResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.object_id)
    pub object_id: String,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.name)
    pub name: String,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.unique_id)
    pub unique_id: String,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.icon)
    pub icon: String,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.unit_of_measurement)
    pub unit_of_measurement: String,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.accuracy_decimals)
    pub accuracy_decimals: i32,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.force_update)
    pub force_update: bool,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.device_class)
    pub device_class: String,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.state_class)
    pub state_class: ::protobuf::EnumOrUnknown<SensorStateClass>,
    ///  Last reset type removed in 2021.9.0
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.legacy_last_reset_type)
    pub legacy_last_reset_type: ::protobuf::EnumOrUnknown<SensorLastResetType>,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesSensorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ListEntitiesSensorResponse {
    fn default() -> &'a ListEntitiesSensorResponse {
        <ListEntitiesSensorResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesSensorResponse {
    pub fn new() -> ListEntitiesSensorResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(13);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesSensorResponse| { &m.object_id },
            |m: &mut ListEntitiesSensorResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesSensorResponse| { &m.key },
            |m: &mut ListEntitiesSensorResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesSensorResponse| { &m.name },
            |m: &mut ListEntitiesSensorResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesSensorResponse| { &m.unique_id },
            |m: &mut ListEntitiesSensorResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesSensorResponse| { &m.icon },
            |m: &mut ListEntitiesSensorResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unit_of_measurement",
            |m: &ListEntitiesSensorResponse| { &m.unit_of_measurement },
            |m: &mut ListEntitiesSensorResponse| { &mut m.unit_of_measurement },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "accuracy_decimals",
            |m: &ListEntitiesSensorResponse| { &m.accuracy_decimals },
            |m: &mut ListEntitiesSensorResponse| { &mut m.accuracy_decimals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "force_update",
            |m: &ListEntitiesSensorResponse| { &m.force_update },
            |m: &mut ListEntitiesSensorResponse| { &mut m.force_update },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_class",
            |m: &ListEntitiesSensorResponse| { &m.device_class },
            |m: &mut ListEntitiesSensorResponse| { &mut m.device_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_class",
            |m: &ListEntitiesSensorResponse| { &m.state_class },
            |m: &mut ListEntitiesSensorResponse| { &mut m.state_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_last_reset_type",
            |m: &ListEntitiesSensorResponse| { &m.legacy_last_reset_type },
            |m: &mut ListEntitiesSensorResponse| { &mut m.legacy_last_reset_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesSensorResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesSensorResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesSensorResponse| { &m.entity_category },
            |m: &mut ListEntitiesSensorResponse| { &mut m.entity_category },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesSensorResponse>(
            "ListEntitiesSensorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesSensorResponse {
    const NAME: &'static str = "ListEntitiesSensorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                50 => {
                    self.unit_of_measurement = is.read_string()?;
                },
                56 => {
                    self.accuracy_decimals = is.read_int32()?;
                },
                64 => {
                    self.force_update = is.read_bool()?;
                },
                74 => {
                    self.device_class = is.read_string()?;
                },
                80 => {
                    self.state_class = is.read_enum_or_unknown()?;
                },
                88 => {
                    self.legacy_last_reset_type = is.read_enum_or_unknown()?;
                },
                96 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                104 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if !self.unit_of_measurement.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.unit_of_measurement);
        }
        if self.accuracy_decimals != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.accuracy_decimals);
        }
        if self.force_update != false {
            my_size += 1 + 1;
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.device_class);
        }
        if self.state_class != ::protobuf::EnumOrUnknown::new(SensorStateClass::STATE_CLASS_NONE) {
            my_size += ::protobuf::rt::int32_size(10, self.state_class.value());
        }
        if self.legacy_last_reset_type != ::protobuf::EnumOrUnknown::new(SensorLastResetType::LAST_RESET_NONE) {
            my_size += ::protobuf::rt::int32_size(11, self.legacy_last_reset_type.value());
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(13, self.entity_category.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if !self.unit_of_measurement.is_empty() {
            os.write_string(6, &self.unit_of_measurement)?;
        }
        if self.accuracy_decimals != 0 {
            os.write_int32(7, self.accuracy_decimals)?;
        }
        if self.force_update != false {
            os.write_bool(8, self.force_update)?;
        }
        if !self.device_class.is_empty() {
            os.write_string(9, &self.device_class)?;
        }
        if self.state_class != ::protobuf::EnumOrUnknown::new(SensorStateClass::STATE_CLASS_NONE) {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&self.state_class))?;
        }
        if self.legacy_last_reset_type != ::protobuf::EnumOrUnknown::new(SensorLastResetType::LAST_RESET_NONE) {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&self.legacy_last_reset_type))?;
        }
        if self.disabled_by_default != false {
            os.write_bool(12, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(13, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesSensorResponse {
        ListEntitiesSensorResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.unit_of_measurement.clear();
        self.accuracy_decimals = 0;
        self.force_update = false;
        self.device_class.clear();
        self.state_class = ::protobuf::EnumOrUnknown::new(SensorStateClass::STATE_CLASS_NONE);
        self.legacy_last_reset_type = ::protobuf::EnumOrUnknown::new(SensorLastResetType::LAST_RESET_NONE);
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesSensorResponse {
        static instance: ListEntitiesSensorResponse = ListEntitiesSensorResponse {
            object_id: String::new(),
            key: 0,
            name: String::new(),
            unique_id: String::new(),
            icon: String::new(),
            unit_of_measurement: String::new(),
            accuracy_decimals: 0,
            force_update: false,
            device_class: String::new(),
            state_class: ::protobuf::EnumOrUnknown::from_i32(0),
            legacy_last_reset_type: ::protobuf::EnumOrUnknown::from_i32(0),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesSensorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesSensorResponse").unwrap()).clone()
    }
}

impl Display for ListEntitiesSensorResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesSensorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SensorStateResponse)
pub struct SensorStateResponse {
    // message fields
    // @@protoc_insertion_point(field:SensorStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:SensorStateResponse.state)
    pub state: f32,
    ///  If the sensor does not have a valid state yet.
    ///  Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
    // @@protoc_insertion_point(field:SensorStateResponse.missing_state)
    pub missing_state: bool,
    // special fields
    // @@protoc_insertion_point(special_field:SensorStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a SensorStateResponse {
    fn default() -> &'a SensorStateResponse {
        <SensorStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SensorStateResponse {
    pub fn new() -> SensorStateResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(3);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &SensorStateResponse| { &m.key },
            |m: &mut SensorStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &SensorStateResponse| { &m.state },
            |m: &mut SensorStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "missing_state",
            |m: &SensorStateResponse| { &m.missing_state },
            |m: &mut SensorStateResponse| { &mut m.missing_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SensorStateResponse>(
            "SensorStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SensorStateResponse {
    const NAME: &'static str = "SensorStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                21 => {
                    self.state = is.read_float()?;
                },
                24 => {
                    self.missing_state = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != 0. {
            my_size += 1 + 4;
        }
        if self.missing_state != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != 0. {
            os.write_float(2, self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SensorStateResponse {
        SensorStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = 0.;
        self.missing_state = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SensorStateResponse {
        static instance: SensorStateResponse = SensorStateResponse {
            key: 0,
            state: 0.,
            missing_state: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SensorStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SensorStateResponse").unwrap()).clone()
    }
}

impl Display for SensorStateResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SensorStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ==================== SWITCH ====================
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListEntitiesSwitchResponse)
pub struct ListEntitiesSwitchResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesSwitchResponse.object_id)
    pub object_id: String,
    // @@protoc_insertion_point(field:ListEntitiesSwitchResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesSwitchResponse.name)
    pub name: String,
    // @@protoc_insertion_point(field:ListEntitiesSwitchResponse.unique_id)
    pub unique_id: String,
    // @@protoc_insertion_point(field:ListEntitiesSwitchResponse.icon)
    pub icon: String,
    // @@protoc_insertion_point(field:ListEntitiesSwitchResponse.assumed_state)
    pub assumed_state: bool,
    // @@protoc_insertion_point(field:ListEntitiesSwitchResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesSwitchResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesSwitchResponse.device_class)
    pub device_class: String,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesSwitchResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ListEntitiesSwitchResponse {
    fn default() -> &'a ListEntitiesSwitchResponse {
        <ListEntitiesSwitchResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesSwitchResponse {
    pub fn new() -> ListEntitiesSwitchResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(9);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesSwitchResponse| { &m.object_id },
            |m: &mut ListEntitiesSwitchResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesSwitchResponse| { &m.key },
            |m: &mut ListEntitiesSwitchResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesSwitchResponse| { &m.name },
            |m: &mut ListEntitiesSwitchResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesSwitchResponse| { &m.unique_id },
            |m: &mut ListEntitiesSwitchResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesSwitchResponse| { &m.icon },
            |m: &mut ListEntitiesSwitchResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "assumed_state",
            |m: &ListEntitiesSwitchResponse| { &m.assumed_state },
            |m: &mut ListEntitiesSwitchResponse| { &mut m.assumed_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesSwitchResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesSwitchResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesSwitchResponse| { &m.entity_category },
            |m: &mut ListEntitiesSwitchResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_class",
            |m: &ListEntitiesSwitchResponse| { &m.device_class },
            |m: &mut ListEntitiesSwitchResponse| { &mut m.device_class },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesSwitchResponse>(
            "ListEntitiesSwitchResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesSwitchResponse {
    const NAME: &'static str = "ListEntitiesSwitchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                48 => {
                    self.assumed_state = is.read_bool()?;
                },
                56 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                64 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                74 => {
                    self.device_class = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.assumed_state != false {
            my_size += 1 + 1;
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(8, self.entity_category.value());
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.device_class);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.assumed_state != false {
            os.write_bool(6, self.assumed_state)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(7, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if !self.device_class.is_empty() {
            os.write_string(9, &self.device_class)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesSwitchResponse {
        ListEntitiesSwitchResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.assumed_state = false;
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.device_class.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesSwitchResponse {
        static instance: ListEntitiesSwitchResponse = ListEntitiesSwitchResponse {
            object_id: String::new(),
            key: 0,
            name: String::new(),
            unique_id: String::new(),
            icon: String::new(),
            assumed_state: false,
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            device_class: String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesSwitchResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesSwitchResponse").unwrap()).clone()
    }
}

impl Display for ListEntitiesSwitchResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesSwitchResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SwitchStateResponse)
pub struct SwitchStateResponse {
    // message fields
    // @@protoc_insertion_point(field:SwitchStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:SwitchStateResponse.state)
    pub state: bool,
    // special fields
    // @@protoc_insertion_point(special_field:SwitchStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a SwitchStateResponse {
    fn default() -> &'a SwitchStateResponse {
        <SwitchStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SwitchStateResponse {
    pub fn new() -> SwitchStateResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(2);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &SwitchStateResponse| { &m.key },
            |m: &mut SwitchStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &SwitchStateResponse| { &m.state },
            |m: &mut SwitchStateResponse| { &mut m.state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwitchStateResponse>(
            "SwitchStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwitchStateResponse {
    const NAME: &'static str = "SwitchStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.state = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwitchStateResponse {
        SwitchStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwitchStateResponse {
        static instance: SwitchStateResponse = SwitchStateResponse {
            key: 0,
            state: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwitchStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwitchStateResponse").unwrap()).clone()
    }
}

impl Display for SwitchStateResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SwitchCommandRequest)
pub struct SwitchCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:SwitchCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:SwitchCommandRequest.state)
    pub state: bool,
    // special fields
    // @@protoc_insertion_point(special_field:SwitchCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a SwitchCommandRequest {
    fn default() -> &'a SwitchCommandRequest {
        <SwitchCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl SwitchCommandRequest {
    pub fn new() -> SwitchCommandRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(2);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &SwitchCommandRequest| { &m.key },
            |m: &mut SwitchCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &SwitchCommandRequest| { &m.state },
            |m: &mut SwitchCommandRequest| { &mut m.state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwitchCommandRequest>(
            "SwitchCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwitchCommandRequest {
    const NAME: &'static str = "SwitchCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.state = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwitchCommandRequest {
        SwitchCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwitchCommandRequest {
        static instance: SwitchCommandRequest = SwitchCommandRequest {
            key: 0,
            state: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwitchCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwitchCommandRequest").unwrap()).clone()
    }
}

impl Display for SwitchCommandRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ==================== TEXT SENSOR ====================
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListEntitiesTextSensorResponse)
pub struct ListEntitiesTextSensorResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesTextSensorResponse.object_id)
    pub object_id: String,
    // @@protoc_insertion_point(field:ListEntitiesTextSensorResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesTextSensorResponse.name)
    pub name: String,
    // @@protoc_insertion_point(field:ListEntitiesTextSensorResponse.unique_id)
    pub unique_id: String,
    // @@protoc_insertion_point(field:ListEntitiesTextSensorResponse.icon)
    pub icon: String,
    // @@protoc_insertion_point(field:ListEntitiesTextSensorResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesTextSensorResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesTextSensorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ListEntitiesTextSensorResponse {
    fn default() -> &'a ListEntitiesTextSensorResponse {
        <ListEntitiesTextSensorResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesTextSensorResponse {
    pub fn new() -> ListEntitiesTextSensorResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(7);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesTextSensorResponse| { &m.object_id },
            |m: &mut ListEntitiesTextSensorResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesTextSensorResponse| { &m.key },
            |m: &mut ListEntitiesTextSensorResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesTextSensorResponse| { &m.name },
            |m: &mut ListEntitiesTextSensorResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesTextSensorResponse| { &m.unique_id },
            |m: &mut ListEntitiesTextSensorResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesTextSensorResponse| { &m.icon },
            |m: &mut ListEntitiesTextSensorResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesTextSensorResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesTextSensorResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesTextSensorResponse| { &m.entity_category },
            |m: &mut ListEntitiesTextSensorResponse| { &mut m.entity_category },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesTextSensorResponse>(
            "ListEntitiesTextSensorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesTextSensorResponse {
    const NAME: &'static str = "ListEntitiesTextSensorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                48 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                56 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.entity_category.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesTextSensorResponse {
        ListEntitiesTextSensorResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesTextSensorResponse {
        static instance: ListEntitiesTextSensorResponse = ListEntitiesTextSensorResponse {
            object_id: String::new(),
            key: 0,
            name: String::new(),
            unique_id: String::new(),
            icon: String::new(),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesTextSensorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesTextSensorResponse").unwrap()).clone()
    }
}

impl Display for ListEntitiesTextSensorResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesTextSensorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:TextSensorStateResponse)
pub struct TextSensorStateResponse {
    // message fields
    // @@protoc_insertion_point(field:TextSensorStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:TextSensorStateResponse.state)
    pub state: String,
    ///  If the text sensor does not have a valid state yet.
    ///  Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
    // @@protoc_insertion_point(field:TextSensorStateResponse.missing_state)
    pub missing_state: bool,
    // special fields
    // @@protoc_insertion_point(special_field:TextSensorStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a TextSensorStateResponse {
    fn default() -> &'a TextSensorStateResponse {
        <TextSensorStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl TextSensorStateResponse {
    pub fn new() -> TextSensorStateResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(3);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &TextSensorStateResponse| { &m.key },
            |m: &mut TextSensorStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &TextSensorStateResponse| { &m.state },
            |m: &mut TextSensorStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "missing_state",
            |m: &TextSensorStateResponse| { &m.missing_state },
            |m: &mut TextSensorStateResponse| { &mut m.missing_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TextSensorStateResponse>(
            "TextSensorStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TextSensorStateResponse {
    const NAME: &'static str = "TextSensorStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                18 => {
                    self.state = is.read_string()?;
                },
                24 => {
                    self.missing_state = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state);
        }
        if self.missing_state != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if !self.state.is_empty() {
            os.write_string(2, &self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TextSensorStateResponse {
        TextSensorStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state.clear();
        self.missing_state = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TextSensorStateResponse {
        static instance: TextSensorStateResponse = TextSensorStateResponse {
            key: 0,
            state: String::new(),
            missing_state: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TextSensorStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TextSensorStateResponse").unwrap()).clone()
    }
}

impl Display for TextSensorStateResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TextSensorStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SubscribeLogsRequest)
pub struct SubscribeLogsRequest {
    // message fields
    // @@protoc_insertion_point(field:SubscribeLogsRequest.level)
    pub level: ::protobuf::EnumOrUnknown<LogLevel>,
    // @@protoc_insertion_point(field:SubscribeLogsRequest.dump_config)
    pub dump_config: bool,
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeLogsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a SubscribeLogsRequest {
    fn default() -> &'a SubscribeLogsRequest {
        <SubscribeLogsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeLogsRequest {
    pub fn new() -> SubscribeLogsRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(2);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "level",
            |m: &SubscribeLogsRequest| { &m.level },
            |m: &mut SubscribeLogsRequest| { &mut m.level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dump_config",
            |m: &SubscribeLogsRequest| { &m.dump_config },
            |m: &mut SubscribeLogsRequest| { &mut m.dump_config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeLogsRequest>(
            "SubscribeLogsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeLogsRequest {
    const NAME: &'static str = "SubscribeLogsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.level = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.dump_config = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.level != ::protobuf::EnumOrUnknown::new(LogLevel::LOG_LEVEL_NONE) {
            my_size += ::protobuf::rt::int32_size(1, self.level.value());
        }
        if self.dump_config != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.level != ::protobuf::EnumOrUnknown::new(LogLevel::LOG_LEVEL_NONE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.level))?;
        }
        if self.dump_config != false {
            os.write_bool(2, self.dump_config)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeLogsRequest {
        SubscribeLogsRequest::new()
    }

    fn clear(&mut self) {
        self.level = ::protobuf::EnumOrUnknown::new(LogLevel::LOG_LEVEL_NONE);
        self.dump_config = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeLogsRequest {
        static instance: SubscribeLogsRequest = SubscribeLogsRequest {
            level: ::protobuf::EnumOrUnknown::from_i32(0),
            dump_config: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeLogsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeLogsRequest").unwrap()).clone()
    }
}

impl Display for SubscribeLogsRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeLogsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SubscribeLogsResponse)
pub struct SubscribeLogsResponse {
    // message fields
    // @@protoc_insertion_point(field:SubscribeLogsResponse.level)
    pub level: ::protobuf::EnumOrUnknown<LogLevel>,
    // @@protoc_insertion_point(field:SubscribeLogsResponse.message)
    pub message: String,
    // @@protoc_insertion_point(field:SubscribeLogsResponse.send_failed)
    pub send_failed: bool,
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeLogsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a SubscribeLogsResponse {
    fn default() -> &'a SubscribeLogsResponse {
        <SubscribeLogsResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeLogsResponse {
    pub fn new() -> SubscribeLogsResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(3);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "level",
            |m: &SubscribeLogsResponse| { &m.level },
            |m: &mut SubscribeLogsResponse| { &mut m.level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &SubscribeLogsResponse| { &m.message },
            |m: &mut SubscribeLogsResponse| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "send_failed",
            |m: &SubscribeLogsResponse| { &m.send_failed },
            |m: &mut SubscribeLogsResponse| { &mut m.send_failed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeLogsResponse>(
            "SubscribeLogsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeLogsResponse {
    const NAME: &'static str = "SubscribeLogsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.level = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.message = is.read_string()?;
                },
                32 => {
                    self.send_failed = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.level != ::protobuf::EnumOrUnknown::new(LogLevel::LOG_LEVEL_NONE) {
            my_size += ::protobuf::rt::int32_size(1, self.level.value());
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        if self.send_failed != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.level != ::protobuf::EnumOrUnknown::new(LogLevel::LOG_LEVEL_NONE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.level))?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        if self.send_failed != false {
            os.write_bool(4, self.send_failed)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeLogsResponse {
        SubscribeLogsResponse::new()
    }

    fn clear(&mut self) {
        self.level = ::protobuf::EnumOrUnknown::new(LogLevel::LOG_LEVEL_NONE);
        self.message.clear();
        self.send_failed = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeLogsResponse {
        static instance: SubscribeLogsResponse = SubscribeLogsResponse {
            level: ::protobuf::EnumOrUnknown::from_i32(0),
            message: String::new(),
            send_failed: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeLogsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeLogsResponse").unwrap()).clone()
    }
}

impl Display for SubscribeLogsResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeLogsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ==================== HOMEASSISTANT.SERVICE ====================
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SubscribeHomeassistantServicesRequest)
pub struct SubscribeHomeassistantServicesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeHomeassistantServicesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a SubscribeHomeassistantServicesRequest {
    fn default() -> &'a SubscribeHomeassistantServicesRequest {
        <SubscribeHomeassistantServicesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeHomeassistantServicesRequest {
    pub fn new() -> SubscribeHomeassistantServicesRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::new();
        let mut oneofs = Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeHomeassistantServicesRequest>(
            "SubscribeHomeassistantServicesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeHomeassistantServicesRequest {
    const NAME: &'static str = "SubscribeHomeassistantServicesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeHomeassistantServicesRequest {
        SubscribeHomeassistantServicesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeHomeassistantServicesRequest {
        static instance: SubscribeHomeassistantServicesRequest = SubscribeHomeassistantServicesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeHomeassistantServicesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeHomeassistantServicesRequest").unwrap()).clone()
    }
}

impl Display for SubscribeHomeassistantServicesRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeHomeassistantServicesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HomeassistantServiceMap)
pub struct HomeassistantServiceMap {
    // message fields
    // @@protoc_insertion_point(field:HomeassistantServiceMap.key)
    pub key: String,
    // @@protoc_insertion_point(field:HomeassistantServiceMap.value)
    pub value: String,
    // special fields
    // @@protoc_insertion_point(special_field:HomeassistantServiceMap.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a HomeassistantServiceMap {
    fn default() -> &'a HomeassistantServiceMap {
        <HomeassistantServiceMap as ::protobuf::Message>::default_instance()
    }
}

impl HomeassistantServiceMap {
    pub fn new() -> HomeassistantServiceMap {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(2);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &HomeassistantServiceMap| { &m.key },
            |m: &mut HomeassistantServiceMap| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &HomeassistantServiceMap| { &m.value },
            |m: &mut HomeassistantServiceMap| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HomeassistantServiceMap>(
            "HomeassistantServiceMap",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HomeassistantServiceMap {
    const NAME: &'static str = "HomeassistantServiceMap";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_string()?;
                },
                18 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HomeassistantServiceMap {
        HomeassistantServiceMap::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HomeassistantServiceMap {
        static instance: HomeassistantServiceMap = HomeassistantServiceMap {
            key: String::new(),
            value: String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HomeassistantServiceMap {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HomeassistantServiceMap").unwrap()).clone()
    }
}

impl Display for HomeassistantServiceMap {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HomeassistantServiceMap {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HomeassistantServiceResponse)
pub struct HomeassistantServiceResponse {
    // message fields
    // @@protoc_insertion_point(field:HomeassistantServiceResponse.service)
    pub service: String,
    // @@protoc_insertion_point(field:HomeassistantServiceResponse.data)
    pub data: Vec<HomeassistantServiceMap>,
    // @@protoc_insertion_point(field:HomeassistantServiceResponse.data_template)
    pub data_template: Vec<HomeassistantServiceMap>,
    // @@protoc_insertion_point(field:HomeassistantServiceResponse.variables)
    pub variables: Vec<HomeassistantServiceMap>,
    // @@protoc_insertion_point(field:HomeassistantServiceResponse.is_event)
    pub is_event: bool,
    // special fields
    // @@protoc_insertion_point(special_field:HomeassistantServiceResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a HomeassistantServiceResponse {
    fn default() -> &'a HomeassistantServiceResponse {
        <HomeassistantServiceResponse as ::protobuf::Message>::default_instance()
    }
}

impl HomeassistantServiceResponse {
    pub fn new() -> HomeassistantServiceResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(5);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "service",
            |m: &HomeassistantServiceResponse| { &m.service },
            |m: &mut HomeassistantServiceResponse| { &mut m.service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data",
            |m: &HomeassistantServiceResponse| { &m.data },
            |m: &mut HomeassistantServiceResponse| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_template",
            |m: &HomeassistantServiceResponse| { &m.data_template },
            |m: &mut HomeassistantServiceResponse| { &mut m.data_template },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "variables",
            |m: &HomeassistantServiceResponse| { &m.variables },
            |m: &mut HomeassistantServiceResponse| { &mut m.variables },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_event",
            |m: &HomeassistantServiceResponse| { &m.is_event },
            |m: &mut HomeassistantServiceResponse| { &mut m.is_event },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HomeassistantServiceResponse>(
            "HomeassistantServiceResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HomeassistantServiceResponse {
    const NAME: &'static str = "HomeassistantServiceResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.service = is.read_string()?;
                },
                18 => {
                    self.data.push(is.read_message()?);
                },
                26 => {
                    self.data_template.push(is.read_message()?);
                },
                34 => {
                    self.variables.push(is.read_message()?);
                },
                40 => {
                    self.is_event = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.data_template {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.variables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.is_event != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.service.is_empty() {
            os.write_string(1, &self.service)?;
        }
        for v in &self.data {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.data_template {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.variables {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if self.is_event != false {
            os.write_bool(5, self.is_event)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HomeassistantServiceResponse {
        HomeassistantServiceResponse::new()
    }

    fn clear(&mut self) {
        self.service.clear();
        self.data.clear();
        self.data_template.clear();
        self.variables.clear();
        self.is_event = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HomeassistantServiceResponse {
        static instance: HomeassistantServiceResponse = HomeassistantServiceResponse {
            service: String::new(),
            data: Vec::new(),
            data_template: Vec::new(),
            variables: Vec::new(),
            is_event: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HomeassistantServiceResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HomeassistantServiceResponse").unwrap()).clone()
    }
}

impl Display for HomeassistantServiceResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HomeassistantServiceResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ==================== IMPORT HOME ASSISTANT STATES ====================
///  1. Client sends `SubscribeHomeAssistantStatesRequest`
///  2. Server responds with zero or more `SubscribeHomeAssistantStateResponse` (async)
///  3. Client sends `HomeAssistantStateResponse` for state changes.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SubscribeHomeAssistantStatesRequest)
pub struct SubscribeHomeAssistantStatesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeHomeAssistantStatesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a SubscribeHomeAssistantStatesRequest {
    fn default() -> &'a SubscribeHomeAssistantStatesRequest {
        <SubscribeHomeAssistantStatesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeHomeAssistantStatesRequest {
    pub fn new() -> SubscribeHomeAssistantStatesRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::new();
        let mut oneofs = Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeHomeAssistantStatesRequest>(
            "SubscribeHomeAssistantStatesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeHomeAssistantStatesRequest {
    const NAME: &'static str = "SubscribeHomeAssistantStatesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeHomeAssistantStatesRequest {
        SubscribeHomeAssistantStatesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeHomeAssistantStatesRequest {
        static instance: SubscribeHomeAssistantStatesRequest = SubscribeHomeAssistantStatesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeHomeAssistantStatesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeHomeAssistantStatesRequest").unwrap()).clone()
    }
}

impl Display for SubscribeHomeAssistantStatesRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeHomeAssistantStatesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SubscribeHomeAssistantStateResponse)
pub struct SubscribeHomeAssistantStateResponse {
    // message fields
    // @@protoc_insertion_point(field:SubscribeHomeAssistantStateResponse.entity_id)
    pub entity_id: String,
    // @@protoc_insertion_point(field:SubscribeHomeAssistantStateResponse.attribute)
    pub attribute: String,
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeHomeAssistantStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a SubscribeHomeAssistantStateResponse {
    fn default() -> &'a SubscribeHomeAssistantStateResponse {
        <SubscribeHomeAssistantStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeHomeAssistantStateResponse {
    pub fn new() -> SubscribeHomeAssistantStateResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(2);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_id",
            |m: &SubscribeHomeAssistantStateResponse| { &m.entity_id },
            |m: &mut SubscribeHomeAssistantStateResponse| { &mut m.entity_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "attribute",
            |m: &SubscribeHomeAssistantStateResponse| { &m.attribute },
            |m: &mut SubscribeHomeAssistantStateResponse| { &mut m.attribute },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeHomeAssistantStateResponse>(
            "SubscribeHomeAssistantStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeHomeAssistantStateResponse {
    const NAME: &'static str = "SubscribeHomeAssistantStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entity_id = is.read_string()?;
                },
                18 => {
                    self.attribute = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.entity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entity_id);
        }
        if !self.attribute.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.attribute);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.entity_id.is_empty() {
            os.write_string(1, &self.entity_id)?;
        }
        if !self.attribute.is_empty() {
            os.write_string(2, &self.attribute)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeHomeAssistantStateResponse {
        SubscribeHomeAssistantStateResponse::new()
    }

    fn clear(&mut self) {
        self.entity_id.clear();
        self.attribute.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeHomeAssistantStateResponse {
        static instance: SubscribeHomeAssistantStateResponse = SubscribeHomeAssistantStateResponse {
            entity_id: String::new(),
            attribute: String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeHomeAssistantStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeHomeAssistantStateResponse").unwrap()).clone()
    }
}

impl Display for SubscribeHomeAssistantStateResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeHomeAssistantStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:HomeAssistantStateResponse)
pub struct HomeAssistantStateResponse {
    // message fields
    // @@protoc_insertion_point(field:HomeAssistantStateResponse.entity_id)
    pub entity_id: String,
    // @@protoc_insertion_point(field:HomeAssistantStateResponse.state)
    pub state: String,
    // @@protoc_insertion_point(field:HomeAssistantStateResponse.attribute)
    pub attribute: String,
    // special fields
    // @@protoc_insertion_point(special_field:HomeAssistantStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a HomeAssistantStateResponse {
    fn default() -> &'a HomeAssistantStateResponse {
        <HomeAssistantStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl HomeAssistantStateResponse {
    pub fn new() -> HomeAssistantStateResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(3);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_id",
            |m: &HomeAssistantStateResponse| { &m.entity_id },
            |m: &mut HomeAssistantStateResponse| { &mut m.entity_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &HomeAssistantStateResponse| { &m.state },
            |m: &mut HomeAssistantStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "attribute",
            |m: &HomeAssistantStateResponse| { &m.attribute },
            |m: &mut HomeAssistantStateResponse| { &mut m.attribute },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HomeAssistantStateResponse>(
            "HomeAssistantStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HomeAssistantStateResponse {
    const NAME: &'static str = "HomeAssistantStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entity_id = is.read_string()?;
                },
                18 => {
                    self.state = is.read_string()?;
                },
                26 => {
                    self.attribute = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.entity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entity_id);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state);
        }
        if !self.attribute.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.attribute);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.entity_id.is_empty() {
            os.write_string(1, &self.entity_id)?;
        }
        if !self.state.is_empty() {
            os.write_string(2, &self.state)?;
        }
        if !self.attribute.is_empty() {
            os.write_string(3, &self.attribute)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HomeAssistantStateResponse {
        HomeAssistantStateResponse::new()
    }

    fn clear(&mut self) {
        self.entity_id.clear();
        self.state.clear();
        self.attribute.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HomeAssistantStateResponse {
        static instance: HomeAssistantStateResponse = HomeAssistantStateResponse {
            entity_id: String::new(),
            state: String::new(),
            attribute: String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HomeAssistantStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HomeAssistantStateResponse").unwrap()).clone()
    }
}

impl Display for HomeAssistantStateResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HomeAssistantStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ==================== IMPORT TIME ====================
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:GetTimeRequest)
pub struct GetTimeRequest {
    // special fields
    // @@protoc_insertion_point(special_field:GetTimeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a GetTimeRequest {
    fn default() -> &'a GetTimeRequest {
        <GetTimeRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTimeRequest {
    pub fn new() -> GetTimeRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::new();
        let mut oneofs = Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTimeRequest>(
            "GetTimeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTimeRequest {
    const NAME: &'static str = "GetTimeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTimeRequest {
        GetTimeRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTimeRequest {
        static instance: GetTimeRequest = GetTimeRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTimeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTimeRequest").unwrap()).clone()
    }
}

impl Display for GetTimeRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTimeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:GetTimeResponse)
pub struct GetTimeResponse {
    // message fields
    // @@protoc_insertion_point(field:GetTimeResponse.epoch_seconds)
    pub epoch_seconds: u32,
    // special fields
    // @@protoc_insertion_point(special_field:GetTimeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a GetTimeResponse {
    fn default() -> &'a GetTimeResponse {
        <GetTimeResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetTimeResponse {
    pub fn new() -> GetTimeResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(1);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "epoch_seconds",
            |m: &GetTimeResponse| { &m.epoch_seconds },
            |m: &mut GetTimeResponse| { &mut m.epoch_seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTimeResponse>(
            "GetTimeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTimeResponse {
    const NAME: &'static str = "GetTimeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.epoch_seconds = is.read_fixed32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.epoch_seconds != 0 {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.epoch_seconds != 0 {
            os.write_fixed32(1, self.epoch_seconds)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTimeResponse {
        GetTimeResponse::new()
    }

    fn clear(&mut self) {
        self.epoch_seconds = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTimeResponse {
        static instance: GetTimeResponse = GetTimeResponse {
            epoch_seconds: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTimeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTimeResponse").unwrap()).clone()
    }
}

impl Display for GetTimeResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTimeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListEntitiesServicesArgument)
pub struct ListEntitiesServicesArgument {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesServicesArgument.name)
    pub name: String,
    // @@protoc_insertion_point(field:ListEntitiesServicesArgument.type)
    pub type_: ::protobuf::EnumOrUnknown<ServiceArgType>,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesServicesArgument.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ListEntitiesServicesArgument {
    fn default() -> &'a ListEntitiesServicesArgument {
        <ListEntitiesServicesArgument as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesServicesArgument {
    pub fn new() -> ListEntitiesServicesArgument {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(2);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesServicesArgument| { &m.name },
            |m: &mut ListEntitiesServicesArgument| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &ListEntitiesServicesArgument| { &m.type_ },
            |m: &mut ListEntitiesServicesArgument| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesServicesArgument>(
            "ListEntitiesServicesArgument",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesServicesArgument {
    const NAME: &'static str = "ListEntitiesServicesArgument";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                16 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(ServiceArgType::SERVICE_ARG_TYPE_BOOL) {
            my_size += ::protobuf::rt::int32_size(2, self.type_.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(ServiceArgType::SERVICE_ARG_TYPE_BOOL) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesServicesArgument {
        ListEntitiesServicesArgument::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(ServiceArgType::SERVICE_ARG_TYPE_BOOL);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesServicesArgument {
        static instance: ListEntitiesServicesArgument = ListEntitiesServicesArgument {
            name: String::new(),
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesServicesArgument {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesServicesArgument").unwrap()).clone()
    }
}

impl Display for ListEntitiesServicesArgument {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesServicesArgument {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListEntitiesServicesResponse)
pub struct ListEntitiesServicesResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesServicesResponse.name)
    pub name: String,
    // @@protoc_insertion_point(field:ListEntitiesServicesResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesServicesResponse.args)
    pub args: Vec<ListEntitiesServicesArgument>,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesServicesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ListEntitiesServicesResponse {
    fn default() -> &'a ListEntitiesServicesResponse {
        <ListEntitiesServicesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesServicesResponse {
    pub fn new() -> ListEntitiesServicesResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(3);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesServicesResponse| { &m.name },
            |m: &mut ListEntitiesServicesResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesServicesResponse| { &m.key },
            |m: &mut ListEntitiesServicesResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "args",
            |m: &ListEntitiesServicesResponse| { &m.args },
            |m: &mut ListEntitiesServicesResponse| { &mut m.args },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesServicesResponse>(
            "ListEntitiesServicesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesServicesResponse {
    const NAME: &'static str = "ListEntitiesServicesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.args.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        for value in &self.args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        for v in &self.args {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesServicesResponse {
        ListEntitiesServicesResponse::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.key = 0;
        self.args.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesServicesResponse {
        static instance: ListEntitiesServicesResponse = ListEntitiesServicesResponse {
            name: String::new(),
            key: 0,
            args: Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesServicesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesServicesResponse").unwrap()).clone()
    }
}

impl Display for ListEntitiesServicesResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesServicesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ExecuteServiceArgument)
pub struct ExecuteServiceArgument {
    // message fields
    // @@protoc_insertion_point(field:ExecuteServiceArgument.bool_)
    pub bool_: bool,
    // @@protoc_insertion_point(field:ExecuteServiceArgument.legacy_int)
    pub legacy_int: i32,
    // @@protoc_insertion_point(field:ExecuteServiceArgument.float_)
    pub float_: f32,
    // @@protoc_insertion_point(field:ExecuteServiceArgument.string_)
    pub string_: String,
    ///  ESPHome 1.14 (api v1.3) make int a signed value
    // @@protoc_insertion_point(field:ExecuteServiceArgument.int_)
    pub int_: i32,
    // @@protoc_insertion_point(field:ExecuteServiceArgument.bool_array)
    pub bool_array: Vec<bool>,
    // @@protoc_insertion_point(field:ExecuteServiceArgument.int_array)
    pub int_array: Vec<i32>,
    // @@protoc_insertion_point(field:ExecuteServiceArgument.float_array)
    pub float_array: Vec<f32>,
    // @@protoc_insertion_point(field:ExecuteServiceArgument.string_array)
    pub string_array: Vec<String>,
    // special fields
    // @@protoc_insertion_point(special_field:ExecuteServiceArgument.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ExecuteServiceArgument {
    fn default() -> &'a ExecuteServiceArgument {
        <ExecuteServiceArgument as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteServiceArgument {
    pub fn new() -> ExecuteServiceArgument {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(9);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bool_",
            |m: &ExecuteServiceArgument| { &m.bool_ },
            |m: &mut ExecuteServiceArgument| { &mut m.bool_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_int",
            |m: &ExecuteServiceArgument| { &m.legacy_int },
            |m: &mut ExecuteServiceArgument| { &mut m.legacy_int },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "float_",
            |m: &ExecuteServiceArgument| { &m.float_ },
            |m: &mut ExecuteServiceArgument| { &mut m.float_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "string_",
            |m: &ExecuteServiceArgument| { &m.string_ },
            |m: &mut ExecuteServiceArgument| { &mut m.string_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "int_",
            |m: &ExecuteServiceArgument| { &m.int_ },
            |m: &mut ExecuteServiceArgument| { &mut m.int_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bool_array",
            |m: &ExecuteServiceArgument| { &m.bool_array },
            |m: &mut ExecuteServiceArgument| { &mut m.bool_array },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "int_array",
            |m: &ExecuteServiceArgument| { &m.int_array },
            |m: &mut ExecuteServiceArgument| { &mut m.int_array },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "float_array",
            |m: &ExecuteServiceArgument| { &m.float_array },
            |m: &mut ExecuteServiceArgument| { &mut m.float_array },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "string_array",
            |m: &ExecuteServiceArgument| { &m.string_array },
            |m: &mut ExecuteServiceArgument| { &mut m.string_array },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecuteServiceArgument>(
            "ExecuteServiceArgument",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExecuteServiceArgument {
    const NAME: &'static str = "ExecuteServiceArgument";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bool_ = is.read_bool()?;
                },
                16 => {
                    self.legacy_int = is.read_int32()?;
                },
                29 => {
                    self.float_ = is.read_float()?;
                },
                34 => {
                    self.string_ = is.read_string()?;
                },
                40 => {
                    self.int_ = is.read_sint32()?;
                },
                50 => {
                    is.read_repeated_packed_bool_into(&mut self.bool_array)?;
                },
                48 => {
                    self.bool_array.push(is.read_bool()?);
                },
                58 => {
                    is.read_repeated_packed_sint32_into(&mut self.int_array)?;
                },
                56 => {
                    self.int_array.push(is.read_sint32()?);
                },
                66 => {
                    is.read_repeated_packed_float_into(&mut self.float_array)?;
                },
                69 => {
                    self.float_array.push(is.read_float()?);
                },
                74 => {
                    self.string_array.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.bool_ != false {
            my_size += 1 + 1;
        }
        if self.legacy_int != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.legacy_int);
        }
        if self.float_ != 0. {
            my_size += 1 + 4;
        }
        if !self.string_.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.string_);
        }
        if self.int_ != 0 {
            my_size += ::protobuf::rt::sint32_size(5, self.int_);
        }
        my_size += 2 * self.bool_array.len() as u64;
        for value in &self.int_array {
            my_size += ::protobuf::rt::sint32_size(7, *value);
        };
        my_size += 5 * self.float_array.len() as u64;
        for value in &self.string_array {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.bool_ != false {
            os.write_bool(1, self.bool_)?;
        }
        if self.legacy_int != 0 {
            os.write_int32(2, self.legacy_int)?;
        }
        if self.float_ != 0. {
            os.write_float(3, self.float_)?;
        }
        if !self.string_.is_empty() {
            os.write_string(4, &self.string_)?;
        }
        if self.int_ != 0 {
            os.write_sint32(5, self.int_)?;
        }
        for v in &self.bool_array {
            os.write_bool(6, *v)?;
        };
        for v in &self.int_array {
            os.write_sint32(7, *v)?;
        };
        for v in &self.float_array {
            os.write_float(8, *v)?;
        };
        for v in &self.string_array {
            os.write_string(9, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExecuteServiceArgument {
        ExecuteServiceArgument::new()
    }

    fn clear(&mut self) {
        self.bool_ = false;
        self.legacy_int = 0;
        self.float_ = 0.;
        self.string_.clear();
        self.int_ = 0;
        self.bool_array.clear();
        self.int_array.clear();
        self.float_array.clear();
        self.string_array.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExecuteServiceArgument {
        static instance: ExecuteServiceArgument = ExecuteServiceArgument {
            bool_: false,
            legacy_int: 0,
            float_: 0.,
            string_: String::new(),
            int_: 0,
            bool_array: Vec::new(),
            int_array: Vec::new(),
            float_array: Vec::new(),
            string_array: Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExecuteServiceArgument {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExecuteServiceArgument").unwrap()).clone()
    }
}

impl Display for ExecuteServiceArgument {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteServiceArgument {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ExecuteServiceRequest)
pub struct ExecuteServiceRequest {
    // message fields
    // @@protoc_insertion_point(field:ExecuteServiceRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ExecuteServiceRequest.args)
    pub args: Vec<ExecuteServiceArgument>,
    // special fields
    // @@protoc_insertion_point(special_field:ExecuteServiceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ExecuteServiceRequest {
    fn default() -> &'a ExecuteServiceRequest {
        <ExecuteServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteServiceRequest {
    pub fn new() -> ExecuteServiceRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(2);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ExecuteServiceRequest| { &m.key },
            |m: &mut ExecuteServiceRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "args",
            |m: &ExecuteServiceRequest| { &m.args },
            |m: &mut ExecuteServiceRequest| { &mut m.args },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecuteServiceRequest>(
            "ExecuteServiceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExecuteServiceRequest {
    const NAME: &'static str = "ExecuteServiceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                18 => {
                    self.args.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        for value in &self.args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        for v in &self.args {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExecuteServiceRequest {
        ExecuteServiceRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.args.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExecuteServiceRequest {
        static instance: ExecuteServiceRequest = ExecuteServiceRequest {
            key: 0,
            args: Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExecuteServiceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExecuteServiceRequest").unwrap()).clone()
    }
}

impl Display for ExecuteServiceRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteServiceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ==================== CAMERA ====================
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListEntitiesCameraResponse)
pub struct ListEntitiesCameraResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesCameraResponse.object_id)
    pub object_id: String,
    // @@protoc_insertion_point(field:ListEntitiesCameraResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesCameraResponse.name)
    pub name: String,
    // @@protoc_insertion_point(field:ListEntitiesCameraResponse.unique_id)
    pub unique_id: String,
    // @@protoc_insertion_point(field:ListEntitiesCameraResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesCameraResponse.icon)
    pub icon: String,
    // @@protoc_insertion_point(field:ListEntitiesCameraResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesCameraResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ListEntitiesCameraResponse {
    fn default() -> &'a ListEntitiesCameraResponse {
        <ListEntitiesCameraResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesCameraResponse {
    pub fn new() -> ListEntitiesCameraResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(7);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesCameraResponse| { &m.object_id },
            |m: &mut ListEntitiesCameraResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesCameraResponse| { &m.key },
            |m: &mut ListEntitiesCameraResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesCameraResponse| { &m.name },
            |m: &mut ListEntitiesCameraResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesCameraResponse| { &m.unique_id },
            |m: &mut ListEntitiesCameraResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesCameraResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesCameraResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesCameraResponse| { &m.icon },
            |m: &mut ListEntitiesCameraResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesCameraResponse| { &m.entity_category },
            |m: &mut ListEntitiesCameraResponse| { &mut m.entity_category },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesCameraResponse>(
            "ListEntitiesCameraResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesCameraResponse {
    const NAME: &'static str = "ListEntitiesCameraResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                40 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                50 => {
                    self.icon = is.read_string()?;
                },
                56 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.icon);
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.entity_category.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(5, self.disabled_by_default)?;
        }
        if !self.icon.is_empty() {
            os.write_string(6, &self.icon)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesCameraResponse {
        ListEntitiesCameraResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.disabled_by_default = false;
        self.icon.clear();
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesCameraResponse {
        static instance: ListEntitiesCameraResponse = ListEntitiesCameraResponse {
            object_id: String::new(),
            key: 0,
            name: String::new(),
            unique_id: String::new(),
            disabled_by_default: false,
            icon: String::new(),
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesCameraResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesCameraResponse").unwrap()).clone()
    }
}

impl Display for ListEntitiesCameraResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesCameraResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CameraImageResponse)
pub struct CameraImageResponse {
    // message fields
    // @@protoc_insertion_point(field:CameraImageResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:CameraImageResponse.data)
    pub data: Vec<u8>,
    // @@protoc_insertion_point(field:CameraImageResponse.done)
    pub done: bool,
    // special fields
    // @@protoc_insertion_point(special_field:CameraImageResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a CameraImageResponse {
    fn default() -> &'a CameraImageResponse {
        <CameraImageResponse as ::protobuf::Message>::default_instance()
    }
}

impl CameraImageResponse {
    pub fn new() -> CameraImageResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(3);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &CameraImageResponse| { &m.key },
            |m: &mut CameraImageResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &CameraImageResponse| { &m.data },
            |m: &mut CameraImageResponse| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "done",
            |m: &CameraImageResponse| { &m.done },
            |m: &mut CameraImageResponse| { &mut m.done },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CameraImageResponse>(
            "CameraImageResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CameraImageResponse {
    const NAME: &'static str = "CameraImageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                18 => {
                    self.data = is.read_bytes()?;
                },
                24 => {
                    self.done = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if self.done != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if self.done != false {
            os.write_bool(3, self.done)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CameraImageResponse {
        CameraImageResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.data.clear();
        self.done = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CameraImageResponse {
        static instance: CameraImageResponse = CameraImageResponse {
            key: 0,
            data: Vec::new(),
            done: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CameraImageResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CameraImageResponse").unwrap()).clone()
    }
}

impl Display for CameraImageResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CameraImageResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CameraImageRequest)
pub struct CameraImageRequest {
    // message fields
    // @@protoc_insertion_point(field:CameraImageRequest.single)
    pub single: bool,
    // @@protoc_insertion_point(field:CameraImageRequest.stream)
    pub stream: bool,
    // special fields
    // @@protoc_insertion_point(special_field:CameraImageRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a CameraImageRequest {
    fn default() -> &'a CameraImageRequest {
        <CameraImageRequest as ::protobuf::Message>::default_instance()
    }
}

impl CameraImageRequest {
    pub fn new() -> CameraImageRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(2);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "single",
            |m: &CameraImageRequest| { &m.single },
            |m: &mut CameraImageRequest| { &mut m.single },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stream",
            |m: &CameraImageRequest| { &m.stream },
            |m: &mut CameraImageRequest| { &mut m.stream },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CameraImageRequest>(
            "CameraImageRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CameraImageRequest {
    const NAME: &'static str = "CameraImageRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.single = is.read_bool()?;
                },
                16 => {
                    self.stream = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.single != false {
            my_size += 1 + 1;
        }
        if self.stream != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.single != false {
            os.write_bool(1, self.single)?;
        }
        if self.stream != false {
            os.write_bool(2, self.stream)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CameraImageRequest {
        CameraImageRequest::new()
    }

    fn clear(&mut self) {
        self.single = false;
        self.stream = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CameraImageRequest {
        static instance: CameraImageRequest = CameraImageRequest {
            single: false,
            stream: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CameraImageRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CameraImageRequest").unwrap()).clone()
    }
}

impl Display for CameraImageRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CameraImageRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListEntitiesClimateResponse)
pub struct ListEntitiesClimateResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.object_id)
    pub object_id: String,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.name)
    pub name: String,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.unique_id)
    pub unique_id: String,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supports_current_temperature)
    pub supports_current_temperature: bool,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supports_two_point_target_temperature)
    pub supports_two_point_target_temperature: bool,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supported_modes)
    pub supported_modes: Vec<::protobuf::EnumOrUnknown<ClimateMode>>,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.visual_min_temperature)
    pub visual_min_temperature: f32,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.visual_max_temperature)
    pub visual_max_temperature: f32,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.visual_temperature_step)
    pub visual_temperature_step: f32,
    ///  for older peer versions - in new system this
    ///  is if CLIMATE_PRESET_AWAY exists is supported_presets
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.legacy_supports_away)
    pub legacy_supports_away: bool,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supports_action)
    pub supports_action: bool,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supported_fan_modes)
    pub supported_fan_modes: Vec<::protobuf::EnumOrUnknown<ClimateFanMode>>,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supported_swing_modes)
    pub supported_swing_modes: Vec<::protobuf::EnumOrUnknown<ClimateSwingMode>>,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supported_custom_fan_modes)
    pub supported_custom_fan_modes: Vec<String>,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supported_presets)
    pub supported_presets: Vec<::protobuf::EnumOrUnknown<ClimatePreset>>,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supported_custom_presets)
    pub supported_custom_presets: Vec<String>,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.icon)
    pub icon: String,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesClimateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ListEntitiesClimateResponse {
    fn default() -> &'a ListEntitiesClimateResponse {
        <ListEntitiesClimateResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesClimateResponse {
    pub fn new() -> ListEntitiesClimateResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(20);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesClimateResponse| { &m.object_id },
            |m: &mut ListEntitiesClimateResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesClimateResponse| { &m.key },
            |m: &mut ListEntitiesClimateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesClimateResponse| { &m.name },
            |m: &mut ListEntitiesClimateResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesClimateResponse| { &m.unique_id },
            |m: &mut ListEntitiesClimateResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_current_temperature",
            |m: &ListEntitiesClimateResponse| { &m.supports_current_temperature },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supports_current_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_two_point_target_temperature",
            |m: &ListEntitiesClimateResponse| { &m.supports_two_point_target_temperature },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supports_two_point_target_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_modes",
            |m: &ListEntitiesClimateResponse| { &m.supported_modes },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supported_modes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "visual_min_temperature",
            |m: &ListEntitiesClimateResponse| { &m.visual_min_temperature },
            |m: &mut ListEntitiesClimateResponse| { &mut m.visual_min_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "visual_max_temperature",
            |m: &ListEntitiesClimateResponse| { &m.visual_max_temperature },
            |m: &mut ListEntitiesClimateResponse| { &mut m.visual_max_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "visual_temperature_step",
            |m: &ListEntitiesClimateResponse| { &m.visual_temperature_step },
            |m: &mut ListEntitiesClimateResponse| { &mut m.visual_temperature_step },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_supports_away",
            |m: &ListEntitiesClimateResponse| { &m.legacy_supports_away },
            |m: &mut ListEntitiesClimateResponse| { &mut m.legacy_supports_away },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_action",
            |m: &ListEntitiesClimateResponse| { &m.supports_action },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supports_action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_fan_modes",
            |m: &ListEntitiesClimateResponse| { &m.supported_fan_modes },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supported_fan_modes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_swing_modes",
            |m: &ListEntitiesClimateResponse| { &m.supported_swing_modes },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supported_swing_modes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_custom_fan_modes",
            |m: &ListEntitiesClimateResponse| { &m.supported_custom_fan_modes },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supported_custom_fan_modes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_presets",
            |m: &ListEntitiesClimateResponse| { &m.supported_presets },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supported_presets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_custom_presets",
            |m: &ListEntitiesClimateResponse| { &m.supported_custom_presets },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supported_custom_presets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesClimateResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesClimateResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesClimateResponse| { &m.icon },
            |m: &mut ListEntitiesClimateResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesClimateResponse| { &m.entity_category },
            |m: &mut ListEntitiesClimateResponse| { &mut m.entity_category },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesClimateResponse>(
            "ListEntitiesClimateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesClimateResponse {
    const NAME: &'static str = "ListEntitiesClimateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                40 => {
                    self.supports_current_temperature = is.read_bool()?;
                },
                48 => {
                    self.supports_two_point_target_temperature = is.read_bool()?;
                },
                56 => {
                    self.supported_modes.push(is.read_enum_or_unknown()?);
                },
                58 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_modes)?;
                },
                69 => {
                    self.visual_min_temperature = is.read_float()?;
                },
                77 => {
                    self.visual_max_temperature = is.read_float()?;
                },
                85 => {
                    self.visual_temperature_step = is.read_float()?;
                },
                88 => {
                    self.legacy_supports_away = is.read_bool()?;
                },
                96 => {
                    self.supports_action = is.read_bool()?;
                },
                104 => {
                    self.supported_fan_modes.push(is.read_enum_or_unknown()?);
                },
                106 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_fan_modes)?;
                },
                112 => {
                    self.supported_swing_modes.push(is.read_enum_or_unknown()?);
                },
                114 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_swing_modes)?;
                },
                122 => {
                    self.supported_custom_fan_modes.push(is.read_string()?);
                },
                128 => {
                    self.supported_presets.push(is.read_enum_or_unknown()?);
                },
                130 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_presets)?;
                },
                138 => {
                    self.supported_custom_presets.push(is.read_string()?);
                },
                144 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                154 => {
                    self.icon = is.read_string()?;
                },
                160 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if self.supports_current_temperature != false {
            my_size += 1 + 1;
        }
        if self.supports_two_point_target_temperature != false {
            my_size += 1 + 1;
        }
        for value in &self.supported_modes {
            my_size += ::protobuf::rt::int32_size(7, value.value());
        };
        if self.visual_min_temperature != 0. {
            my_size += 1 + 4;
        }
        if self.visual_max_temperature != 0. {
            my_size += 1 + 4;
        }
        if self.visual_temperature_step != 0. {
            my_size += 1 + 4;
        }
        if self.legacy_supports_away != false {
            my_size += 1 + 1;
        }
        if self.supports_action != false {
            my_size += 1 + 1;
        }
        for value in &self.supported_fan_modes {
            my_size += ::protobuf::rt::int32_size(13, value.value());
        };
        for value in &self.supported_swing_modes {
            my_size += ::protobuf::rt::int32_size(14, value.value());
        };
        for value in &self.supported_custom_fan_modes {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        for value in &self.supported_presets {
            my_size += ::protobuf::rt::int32_size(16, value.value());
        };
        for value in &self.supported_custom_presets {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        if self.disabled_by_default != false {
            my_size += 2 + 1;
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.icon);
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(20, self.entity_category.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if self.supports_current_temperature != false {
            os.write_bool(5, self.supports_current_temperature)?;
        }
        if self.supports_two_point_target_temperature != false {
            os.write_bool(6, self.supports_two_point_target_temperature)?;
        }
        for v in &self.supported_modes {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if self.visual_min_temperature != 0. {
            os.write_float(8, self.visual_min_temperature)?;
        }
        if self.visual_max_temperature != 0. {
            os.write_float(9, self.visual_max_temperature)?;
        }
        if self.visual_temperature_step != 0. {
            os.write_float(10, self.visual_temperature_step)?;
        }
        if self.legacy_supports_away != false {
            os.write_bool(11, self.legacy_supports_away)?;
        }
        if self.supports_action != false {
            os.write_bool(12, self.supports_action)?;
        }
        for v in &self.supported_fan_modes {
            os.write_enum(13, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.supported_swing_modes {
            os.write_enum(14, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.supported_custom_fan_modes {
            os.write_string(15, &v)?;
        };
        for v in &self.supported_presets {
            os.write_enum(16, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.supported_custom_presets {
            os.write_string(17, &v)?;
        };
        if self.disabled_by_default != false {
            os.write_bool(18, self.disabled_by_default)?;
        }
        if !self.icon.is_empty() {
            os.write_string(19, &self.icon)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(20, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesClimateResponse {
        ListEntitiesClimateResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.supports_current_temperature = false;
        self.supports_two_point_target_temperature = false;
        self.supported_modes.clear();
        self.visual_min_temperature = 0.;
        self.visual_max_temperature = 0.;
        self.visual_temperature_step = 0.;
        self.legacy_supports_away = false;
        self.supports_action = false;
        self.supported_fan_modes.clear();
        self.supported_swing_modes.clear();
        self.supported_custom_fan_modes.clear();
        self.supported_presets.clear();
        self.supported_custom_presets.clear();
        self.disabled_by_default = false;
        self.icon.clear();
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesClimateResponse {
        static instance: ListEntitiesClimateResponse = ListEntitiesClimateResponse {
            object_id: String::new(),
            key: 0,
            name: String::new(),
            unique_id: String::new(),
            supports_current_temperature: false,
            supports_two_point_target_temperature: false,
            supported_modes: Vec::new(),
            visual_min_temperature: 0.,
            visual_max_temperature: 0.,
            visual_temperature_step: 0.,
            legacy_supports_away: false,
            supports_action: false,
            supported_fan_modes: Vec::new(),
            supported_swing_modes: Vec::new(),
            supported_custom_fan_modes: Vec::new(),
            supported_presets: Vec::new(),
            supported_custom_presets: Vec::new(),
            disabled_by_default: false,
            icon: String::new(),
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesClimateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesClimateResponse").unwrap()).clone()
    }
}

impl Display for ListEntitiesClimateResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesClimateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ClimateStateResponse)
pub struct ClimateStateResponse {
    // message fields
    // @@protoc_insertion_point(field:ClimateStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ClimateStateResponse.mode)
    pub mode: ::protobuf::EnumOrUnknown<ClimateMode>,
    // @@protoc_insertion_point(field:ClimateStateResponse.current_temperature)
    pub current_temperature: f32,
    // @@protoc_insertion_point(field:ClimateStateResponse.target_temperature)
    pub target_temperature: f32,
    // @@protoc_insertion_point(field:ClimateStateResponse.target_temperature_low)
    pub target_temperature_low: f32,
    // @@protoc_insertion_point(field:ClimateStateResponse.target_temperature_high)
    pub target_temperature_high: f32,
    ///  For older peers, equal to preset == CLIMATE_PRESET_AWAY
    // @@protoc_insertion_point(field:ClimateStateResponse.legacy_away)
    pub legacy_away: bool,
    // @@protoc_insertion_point(field:ClimateStateResponse.action)
    pub action: ::protobuf::EnumOrUnknown<ClimateAction>,
    // @@protoc_insertion_point(field:ClimateStateResponse.fan_mode)
    pub fan_mode: ::protobuf::EnumOrUnknown<ClimateFanMode>,
    // @@protoc_insertion_point(field:ClimateStateResponse.swing_mode)
    pub swing_mode: ::protobuf::EnumOrUnknown<ClimateSwingMode>,
    // @@protoc_insertion_point(field:ClimateStateResponse.custom_fan_mode)
    pub custom_fan_mode: String,
    // @@protoc_insertion_point(field:ClimateStateResponse.preset)
    pub preset: ::protobuf::EnumOrUnknown<ClimatePreset>,
    // @@protoc_insertion_point(field:ClimateStateResponse.custom_preset)
    pub custom_preset: String,
    // special fields
    // @@protoc_insertion_point(special_field:ClimateStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ClimateStateResponse {
    fn default() -> &'a ClimateStateResponse {
        <ClimateStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl ClimateStateResponse {
    pub fn new() -> ClimateStateResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(13);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ClimateStateResponse| { &m.key },
            |m: &mut ClimateStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &ClimateStateResponse| { &m.mode },
            |m: &mut ClimateStateResponse| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "current_temperature",
            |m: &ClimateStateResponse| { &m.current_temperature },
            |m: &mut ClimateStateResponse| { &mut m.current_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_temperature",
            |m: &ClimateStateResponse| { &m.target_temperature },
            |m: &mut ClimateStateResponse| { &mut m.target_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_temperature_low",
            |m: &ClimateStateResponse| { &m.target_temperature_low },
            |m: &mut ClimateStateResponse| { &mut m.target_temperature_low },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_temperature_high",
            |m: &ClimateStateResponse| { &m.target_temperature_high },
            |m: &mut ClimateStateResponse| { &mut m.target_temperature_high },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_away",
            |m: &ClimateStateResponse| { &m.legacy_away },
            |m: &mut ClimateStateResponse| { &mut m.legacy_away },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &ClimateStateResponse| { &m.action },
            |m: &mut ClimateStateResponse| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fan_mode",
            |m: &ClimateStateResponse| { &m.fan_mode },
            |m: &mut ClimateStateResponse| { &mut m.fan_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "swing_mode",
            |m: &ClimateStateResponse| { &m.swing_mode },
            |m: &mut ClimateStateResponse| { &mut m.swing_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "custom_fan_mode",
            |m: &ClimateStateResponse| { &m.custom_fan_mode },
            |m: &mut ClimateStateResponse| { &mut m.custom_fan_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "preset",
            |m: &ClimateStateResponse| { &m.preset },
            |m: &mut ClimateStateResponse| { &mut m.preset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "custom_preset",
            |m: &ClimateStateResponse| { &m.custom_preset },
            |m: &mut ClimateStateResponse| { &mut m.custom_preset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClimateStateResponse>(
            "ClimateStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClimateStateResponse {
    const NAME: &'static str = "ClimateStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.mode = is.read_enum_or_unknown()?;
                },
                29 => {
                    self.current_temperature = is.read_float()?;
                },
                37 => {
                    self.target_temperature = is.read_float()?;
                },
                45 => {
                    self.target_temperature_low = is.read_float()?;
                },
                53 => {
                    self.target_temperature_high = is.read_float()?;
                },
                56 => {
                    self.legacy_away = is.read_bool()?;
                },
                64 => {
                    self.action = is.read_enum_or_unknown()?;
                },
                72 => {
                    self.fan_mode = is.read_enum_or_unknown()?;
                },
                80 => {
                    self.swing_mode = is.read_enum_or_unknown()?;
                },
                90 => {
                    self.custom_fan_mode = is.read_string()?;
                },
                96 => {
                    self.preset = is.read_enum_or_unknown()?;
                },
                106 => {
                    self.custom_preset = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.mode != ::protobuf::EnumOrUnknown::new(ClimateMode::CLIMATE_MODE_OFF) {
            my_size += ::protobuf::rt::int32_size(2, self.mode.value());
        }
        if self.current_temperature != 0. {
            my_size += 1 + 4;
        }
        if self.target_temperature != 0. {
            my_size += 1 + 4;
        }
        if self.target_temperature_low != 0. {
            my_size += 1 + 4;
        }
        if self.target_temperature_high != 0. {
            my_size += 1 + 4;
        }
        if self.legacy_away != false {
            my_size += 1 + 1;
        }
        if self.action != ::protobuf::EnumOrUnknown::new(ClimateAction::CLIMATE_ACTION_OFF) {
            my_size += ::protobuf::rt::int32_size(8, self.action.value());
        }
        if self.fan_mode != ::protobuf::EnumOrUnknown::new(ClimateFanMode::CLIMATE_FAN_ON) {
            my_size += ::protobuf::rt::int32_size(9, self.fan_mode.value());
        }
        if self.swing_mode != ::protobuf::EnumOrUnknown::new(ClimateSwingMode::CLIMATE_SWING_OFF) {
            my_size += ::protobuf::rt::int32_size(10, self.swing_mode.value());
        }
        if !self.custom_fan_mode.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.custom_fan_mode);
        }
        if self.preset != ::protobuf::EnumOrUnknown::new(ClimatePreset::CLIMATE_PRESET_NONE) {
            my_size += ::protobuf::rt::int32_size(12, self.preset.value());
        }
        if !self.custom_preset.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.custom_preset);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.mode != ::protobuf::EnumOrUnknown::new(ClimateMode::CLIMATE_MODE_OFF) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.mode))?;
        }
        if self.current_temperature != 0. {
            os.write_float(3, self.current_temperature)?;
        }
        if self.target_temperature != 0. {
            os.write_float(4, self.target_temperature)?;
        }
        if self.target_temperature_low != 0. {
            os.write_float(5, self.target_temperature_low)?;
        }
        if self.target_temperature_high != 0. {
            os.write_float(6, self.target_temperature_high)?;
        }
        if self.legacy_away != false {
            os.write_bool(7, self.legacy_away)?;
        }
        if self.action != ::protobuf::EnumOrUnknown::new(ClimateAction::CLIMATE_ACTION_OFF) {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.action))?;
        }
        if self.fan_mode != ::protobuf::EnumOrUnknown::new(ClimateFanMode::CLIMATE_FAN_ON) {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.fan_mode))?;
        }
        if self.swing_mode != ::protobuf::EnumOrUnknown::new(ClimateSwingMode::CLIMATE_SWING_OFF) {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&self.swing_mode))?;
        }
        if !self.custom_fan_mode.is_empty() {
            os.write_string(11, &self.custom_fan_mode)?;
        }
        if self.preset != ::protobuf::EnumOrUnknown::new(ClimatePreset::CLIMATE_PRESET_NONE) {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&self.preset))?;
        }
        if !self.custom_preset.is_empty() {
            os.write_string(13, &self.custom_preset)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClimateStateResponse {
        ClimateStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.mode = ::protobuf::EnumOrUnknown::new(ClimateMode::CLIMATE_MODE_OFF);
        self.current_temperature = 0.;
        self.target_temperature = 0.;
        self.target_temperature_low = 0.;
        self.target_temperature_high = 0.;
        self.legacy_away = false;
        self.action = ::protobuf::EnumOrUnknown::new(ClimateAction::CLIMATE_ACTION_OFF);
        self.fan_mode = ::protobuf::EnumOrUnknown::new(ClimateFanMode::CLIMATE_FAN_ON);
        self.swing_mode = ::protobuf::EnumOrUnknown::new(ClimateSwingMode::CLIMATE_SWING_OFF);
        self.custom_fan_mode.clear();
        self.preset = ::protobuf::EnumOrUnknown::new(ClimatePreset::CLIMATE_PRESET_NONE);
        self.custom_preset.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClimateStateResponse {
        static instance: ClimateStateResponse = ClimateStateResponse {
            key: 0,
            mode: ::protobuf::EnumOrUnknown::from_i32(0),
            current_temperature: 0.,
            target_temperature: 0.,
            target_temperature_low: 0.,
            target_temperature_high: 0.,
            legacy_away: false,
            action: ::protobuf::EnumOrUnknown::from_i32(0),
            fan_mode: ::protobuf::EnumOrUnknown::from_i32(0),
            swing_mode: ::protobuf::EnumOrUnknown::from_i32(0),
            custom_fan_mode: String::new(),
            preset: ::protobuf::EnumOrUnknown::from_i32(0),
            custom_preset: String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClimateStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClimateStateResponse").unwrap()).clone()
    }
}

impl Display for ClimateStateResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClimateStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ClimateCommandRequest)
pub struct ClimateCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:ClimateCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_mode)
    pub has_mode: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.mode)
    pub mode: ::protobuf::EnumOrUnknown<ClimateMode>,
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_target_temperature)
    pub has_target_temperature: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.target_temperature)
    pub target_temperature: f32,
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_target_temperature_low)
    pub has_target_temperature_low: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.target_temperature_low)
    pub target_temperature_low: f32,
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_target_temperature_high)
    pub has_target_temperature_high: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.target_temperature_high)
    pub target_temperature_high: f32,
    ///  legacy, for older peers, newer ones should use CLIMATE_PRESET_AWAY in preset
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_legacy_away)
    pub has_legacy_away: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.legacy_away)
    pub legacy_away: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_fan_mode)
    pub has_fan_mode: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.fan_mode)
    pub fan_mode: ::protobuf::EnumOrUnknown<ClimateFanMode>,
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_swing_mode)
    pub has_swing_mode: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.swing_mode)
    pub swing_mode: ::protobuf::EnumOrUnknown<ClimateSwingMode>,
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_custom_fan_mode)
    pub has_custom_fan_mode: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.custom_fan_mode)
    pub custom_fan_mode: String,
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_preset)
    pub has_preset: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.preset)
    pub preset: ::protobuf::EnumOrUnknown<ClimatePreset>,
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_custom_preset)
    pub has_custom_preset: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.custom_preset)
    pub custom_preset: String,
    // special fields
    // @@protoc_insertion_point(special_field:ClimateCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ClimateCommandRequest {
    fn default() -> &'a ClimateCommandRequest {
        <ClimateCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl ClimateCommandRequest {
    pub fn new() -> ClimateCommandRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(21);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ClimateCommandRequest| { &m.key },
            |m: &mut ClimateCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_mode",
            |m: &ClimateCommandRequest| { &m.has_mode },
            |m: &mut ClimateCommandRequest| { &mut m.has_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &ClimateCommandRequest| { &m.mode },
            |m: &mut ClimateCommandRequest| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_target_temperature",
            |m: &ClimateCommandRequest| { &m.has_target_temperature },
            |m: &mut ClimateCommandRequest| { &mut m.has_target_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_temperature",
            |m: &ClimateCommandRequest| { &m.target_temperature },
            |m: &mut ClimateCommandRequest| { &mut m.target_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_target_temperature_low",
            |m: &ClimateCommandRequest| { &m.has_target_temperature_low },
            |m: &mut ClimateCommandRequest| { &mut m.has_target_temperature_low },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_temperature_low",
            |m: &ClimateCommandRequest| { &m.target_temperature_low },
            |m: &mut ClimateCommandRequest| { &mut m.target_temperature_low },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_target_temperature_high",
            |m: &ClimateCommandRequest| { &m.has_target_temperature_high },
            |m: &mut ClimateCommandRequest| { &mut m.has_target_temperature_high },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_temperature_high",
            |m: &ClimateCommandRequest| { &m.target_temperature_high },
            |m: &mut ClimateCommandRequest| { &mut m.target_temperature_high },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_legacy_away",
            |m: &ClimateCommandRequest| { &m.has_legacy_away },
            |m: &mut ClimateCommandRequest| { &mut m.has_legacy_away },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_away",
            |m: &ClimateCommandRequest| { &m.legacy_away },
            |m: &mut ClimateCommandRequest| { &mut m.legacy_away },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_fan_mode",
            |m: &ClimateCommandRequest| { &m.has_fan_mode },
            |m: &mut ClimateCommandRequest| { &mut m.has_fan_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fan_mode",
            |m: &ClimateCommandRequest| { &m.fan_mode },
            |m: &mut ClimateCommandRequest| { &mut m.fan_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_swing_mode",
            |m: &ClimateCommandRequest| { &m.has_swing_mode },
            |m: &mut ClimateCommandRequest| { &mut m.has_swing_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "swing_mode",
            |m: &ClimateCommandRequest| { &m.swing_mode },
            |m: &mut ClimateCommandRequest| { &mut m.swing_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_custom_fan_mode",
            |m: &ClimateCommandRequest| { &m.has_custom_fan_mode },
            |m: &mut ClimateCommandRequest| { &mut m.has_custom_fan_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "custom_fan_mode",
            |m: &ClimateCommandRequest| { &m.custom_fan_mode },
            |m: &mut ClimateCommandRequest| { &mut m.custom_fan_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_preset",
            |m: &ClimateCommandRequest| { &m.has_preset },
            |m: &mut ClimateCommandRequest| { &mut m.has_preset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "preset",
            |m: &ClimateCommandRequest| { &m.preset },
            |m: &mut ClimateCommandRequest| { &mut m.preset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_custom_preset",
            |m: &ClimateCommandRequest| { &m.has_custom_preset },
            |m: &mut ClimateCommandRequest| { &mut m.has_custom_preset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "custom_preset",
            |m: &ClimateCommandRequest| { &m.custom_preset },
            |m: &mut ClimateCommandRequest| { &mut m.custom_preset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClimateCommandRequest>(
            "ClimateCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClimateCommandRequest {
    const NAME: &'static str = "ClimateCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.has_mode = is.read_bool()?;
                },
                24 => {
                    self.mode = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.has_target_temperature = is.read_bool()?;
                },
                45 => {
                    self.target_temperature = is.read_float()?;
                },
                48 => {
                    self.has_target_temperature_low = is.read_bool()?;
                },
                61 => {
                    self.target_temperature_low = is.read_float()?;
                },
                64 => {
                    self.has_target_temperature_high = is.read_bool()?;
                },
                77 => {
                    self.target_temperature_high = is.read_float()?;
                },
                80 => {
                    self.has_legacy_away = is.read_bool()?;
                },
                88 => {
                    self.legacy_away = is.read_bool()?;
                },
                96 => {
                    self.has_fan_mode = is.read_bool()?;
                },
                104 => {
                    self.fan_mode = is.read_enum_or_unknown()?;
                },
                112 => {
                    self.has_swing_mode = is.read_bool()?;
                },
                120 => {
                    self.swing_mode = is.read_enum_or_unknown()?;
                },
                128 => {
                    self.has_custom_fan_mode = is.read_bool()?;
                },
                138 => {
                    self.custom_fan_mode = is.read_string()?;
                },
                144 => {
                    self.has_preset = is.read_bool()?;
                },
                152 => {
                    self.preset = is.read_enum_or_unknown()?;
                },
                160 => {
                    self.has_custom_preset = is.read_bool()?;
                },
                170 => {
                    self.custom_preset = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.has_mode != false {
            my_size += 1 + 1;
        }
        if self.mode != ::protobuf::EnumOrUnknown::new(ClimateMode::CLIMATE_MODE_OFF) {
            my_size += ::protobuf::rt::int32_size(3, self.mode.value());
        }
        if self.has_target_temperature != false {
            my_size += 1 + 1;
        }
        if self.target_temperature != 0. {
            my_size += 1 + 4;
        }
        if self.has_target_temperature_low != false {
            my_size += 1 + 1;
        }
        if self.target_temperature_low != 0. {
            my_size += 1 + 4;
        }
        if self.has_target_temperature_high != false {
            my_size += 1 + 1;
        }
        if self.target_temperature_high != 0. {
            my_size += 1 + 4;
        }
        if self.has_legacy_away != false {
            my_size += 1 + 1;
        }
        if self.legacy_away != false {
            my_size += 1 + 1;
        }
        if self.has_fan_mode != false {
            my_size += 1 + 1;
        }
        if self.fan_mode != ::protobuf::EnumOrUnknown::new(ClimateFanMode::CLIMATE_FAN_ON) {
            my_size += ::protobuf::rt::int32_size(13, self.fan_mode.value());
        }
        if self.has_swing_mode != false {
            my_size += 1 + 1;
        }
        if self.swing_mode != ::protobuf::EnumOrUnknown::new(ClimateSwingMode::CLIMATE_SWING_OFF) {
            my_size += ::protobuf::rt::int32_size(15, self.swing_mode.value());
        }
        if self.has_custom_fan_mode != false {
            my_size += 2 + 1;
        }
        if !self.custom_fan_mode.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.custom_fan_mode);
        }
        if self.has_preset != false {
            my_size += 2 + 1;
        }
        if self.preset != ::protobuf::EnumOrUnknown::new(ClimatePreset::CLIMATE_PRESET_NONE) {
            my_size += ::protobuf::rt::int32_size(19, self.preset.value());
        }
        if self.has_custom_preset != false {
            my_size += 2 + 1;
        }
        if !self.custom_preset.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.custom_preset);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_mode != false {
            os.write_bool(2, self.has_mode)?;
        }
        if self.mode != ::protobuf::EnumOrUnknown::new(ClimateMode::CLIMATE_MODE_OFF) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.mode))?;
        }
        if self.has_target_temperature != false {
            os.write_bool(4, self.has_target_temperature)?;
        }
        if self.target_temperature != 0. {
            os.write_float(5, self.target_temperature)?;
        }
        if self.has_target_temperature_low != false {
            os.write_bool(6, self.has_target_temperature_low)?;
        }
        if self.target_temperature_low != 0. {
            os.write_float(7, self.target_temperature_low)?;
        }
        if self.has_target_temperature_high != false {
            os.write_bool(8, self.has_target_temperature_high)?;
        }
        if self.target_temperature_high != 0. {
            os.write_float(9, self.target_temperature_high)?;
        }
        if self.has_legacy_away != false {
            os.write_bool(10, self.has_legacy_away)?;
        }
        if self.legacy_away != false {
            os.write_bool(11, self.legacy_away)?;
        }
        if self.has_fan_mode != false {
            os.write_bool(12, self.has_fan_mode)?;
        }
        if self.fan_mode != ::protobuf::EnumOrUnknown::new(ClimateFanMode::CLIMATE_FAN_ON) {
            os.write_enum(13, ::protobuf::EnumOrUnknown::value(&self.fan_mode))?;
        }
        if self.has_swing_mode != false {
            os.write_bool(14, self.has_swing_mode)?;
        }
        if self.swing_mode != ::protobuf::EnumOrUnknown::new(ClimateSwingMode::CLIMATE_SWING_OFF) {
            os.write_enum(15, ::protobuf::EnumOrUnknown::value(&self.swing_mode))?;
        }
        if self.has_custom_fan_mode != false {
            os.write_bool(16, self.has_custom_fan_mode)?;
        }
        if !self.custom_fan_mode.is_empty() {
            os.write_string(17, &self.custom_fan_mode)?;
        }
        if self.has_preset != false {
            os.write_bool(18, self.has_preset)?;
        }
        if self.preset != ::protobuf::EnumOrUnknown::new(ClimatePreset::CLIMATE_PRESET_NONE) {
            os.write_enum(19, ::protobuf::EnumOrUnknown::value(&self.preset))?;
        }
        if self.has_custom_preset != false {
            os.write_bool(20, self.has_custom_preset)?;
        }
        if !self.custom_preset.is_empty() {
            os.write_string(21, &self.custom_preset)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClimateCommandRequest {
        ClimateCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.has_mode = false;
        self.mode = ::protobuf::EnumOrUnknown::new(ClimateMode::CLIMATE_MODE_OFF);
        self.has_target_temperature = false;
        self.target_temperature = 0.;
        self.has_target_temperature_low = false;
        self.target_temperature_low = 0.;
        self.has_target_temperature_high = false;
        self.target_temperature_high = 0.;
        self.has_legacy_away = false;
        self.legacy_away = false;
        self.has_fan_mode = false;
        self.fan_mode = ::protobuf::EnumOrUnknown::new(ClimateFanMode::CLIMATE_FAN_ON);
        self.has_swing_mode = false;
        self.swing_mode = ::protobuf::EnumOrUnknown::new(ClimateSwingMode::CLIMATE_SWING_OFF);
        self.has_custom_fan_mode = false;
        self.custom_fan_mode.clear();
        self.has_preset = false;
        self.preset = ::protobuf::EnumOrUnknown::new(ClimatePreset::CLIMATE_PRESET_NONE);
        self.has_custom_preset = false;
        self.custom_preset.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClimateCommandRequest {
        static instance: ClimateCommandRequest = ClimateCommandRequest {
            key: 0,
            has_mode: false,
            mode: ::protobuf::EnumOrUnknown::from_i32(0),
            has_target_temperature: false,
            target_temperature: 0.,
            has_target_temperature_low: false,
            target_temperature_low: 0.,
            has_target_temperature_high: false,
            target_temperature_high: 0.,
            has_legacy_away: false,
            legacy_away: false,
            has_fan_mode: false,
            fan_mode: ::protobuf::EnumOrUnknown::from_i32(0),
            has_swing_mode: false,
            swing_mode: ::protobuf::EnumOrUnknown::from_i32(0),
            has_custom_fan_mode: false,
            custom_fan_mode: String::new(),
            has_preset: false,
            preset: ::protobuf::EnumOrUnknown::from_i32(0),
            has_custom_preset: false,
            custom_preset: String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClimateCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClimateCommandRequest").unwrap()).clone()
    }
}

impl Display for ClimateCommandRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClimateCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListEntitiesNumberResponse)
pub struct ListEntitiesNumberResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.object_id)
    pub object_id: String,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.name)
    pub name: String,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.unique_id)
    pub unique_id: String,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.icon)
    pub icon: String,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.min_value)
    pub min_value: f32,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.max_value)
    pub max_value: f32,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.step)
    pub step: f32,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.unit_of_measurement)
    pub unit_of_measurement: String,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.mode)
    pub mode: ::protobuf::EnumOrUnknown<NumberMode>,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesNumberResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ListEntitiesNumberResponse {
    fn default() -> &'a ListEntitiesNumberResponse {
        <ListEntitiesNumberResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesNumberResponse {
    pub fn new() -> ListEntitiesNumberResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(12);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesNumberResponse| { &m.object_id },
            |m: &mut ListEntitiesNumberResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesNumberResponse| { &m.key },
            |m: &mut ListEntitiesNumberResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesNumberResponse| { &m.name },
            |m: &mut ListEntitiesNumberResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesNumberResponse| { &m.unique_id },
            |m: &mut ListEntitiesNumberResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesNumberResponse| { &m.icon },
            |m: &mut ListEntitiesNumberResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min_value",
            |m: &ListEntitiesNumberResponse| { &m.min_value },
            |m: &mut ListEntitiesNumberResponse| { &mut m.min_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_value",
            |m: &ListEntitiesNumberResponse| { &m.max_value },
            |m: &mut ListEntitiesNumberResponse| { &mut m.max_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "step",
            |m: &ListEntitiesNumberResponse| { &m.step },
            |m: &mut ListEntitiesNumberResponse| { &mut m.step },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesNumberResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesNumberResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesNumberResponse| { &m.entity_category },
            |m: &mut ListEntitiesNumberResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unit_of_measurement",
            |m: &ListEntitiesNumberResponse| { &m.unit_of_measurement },
            |m: &mut ListEntitiesNumberResponse| { &mut m.unit_of_measurement },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &ListEntitiesNumberResponse| { &m.mode },
            |m: &mut ListEntitiesNumberResponse| { &mut m.mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesNumberResponse>(
            "ListEntitiesNumberResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesNumberResponse {
    const NAME: &'static str = "ListEntitiesNumberResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                53 => {
                    self.min_value = is.read_float()?;
                },
                61 => {
                    self.max_value = is.read_float()?;
                },
                69 => {
                    self.step = is.read_float()?;
                },
                72 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                80 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                90 => {
                    self.unit_of_measurement = is.read_string()?;
                },
                96 => {
                    self.mode = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.min_value != 0. {
            my_size += 1 + 4;
        }
        if self.max_value != 0. {
            my_size += 1 + 4;
        }
        if self.step != 0. {
            my_size += 1 + 4;
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(10, self.entity_category.value());
        }
        if !self.unit_of_measurement.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.unit_of_measurement);
        }
        if self.mode != ::protobuf::EnumOrUnknown::new(NumberMode::NUMBER_MODE_AUTO) {
            my_size += ::protobuf::rt::int32_size(12, self.mode.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.min_value != 0. {
            os.write_float(6, self.min_value)?;
        }
        if self.max_value != 0. {
            os.write_float(7, self.max_value)?;
        }
        if self.step != 0. {
            os.write_float(8, self.step)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(9, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if !self.unit_of_measurement.is_empty() {
            os.write_string(11, &self.unit_of_measurement)?;
        }
        if self.mode != ::protobuf::EnumOrUnknown::new(NumberMode::NUMBER_MODE_AUTO) {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&self.mode))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesNumberResponse {
        ListEntitiesNumberResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.min_value = 0.;
        self.max_value = 0.;
        self.step = 0.;
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.unit_of_measurement.clear();
        self.mode = ::protobuf::EnumOrUnknown::new(NumberMode::NUMBER_MODE_AUTO);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesNumberResponse {
        static instance: ListEntitiesNumberResponse = ListEntitiesNumberResponse {
            object_id: String::new(),
            key: 0,
            name: String::new(),
            unique_id: String::new(),
            icon: String::new(),
            min_value: 0.,
            max_value: 0.,
            step: 0.,
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            unit_of_measurement: String::new(),
            mode: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesNumberResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesNumberResponse").unwrap()).clone()
    }
}

impl Display for ListEntitiesNumberResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesNumberResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:NumberStateResponse)
pub struct NumberStateResponse {
    // message fields
    // @@protoc_insertion_point(field:NumberStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:NumberStateResponse.state)
    pub state: f32,
    ///  If the number does not have a valid state yet.
    ///  Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
    // @@protoc_insertion_point(field:NumberStateResponse.missing_state)
    pub missing_state: bool,
    // special fields
    // @@protoc_insertion_point(special_field:NumberStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a NumberStateResponse {
    fn default() -> &'a NumberStateResponse {
        <NumberStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl NumberStateResponse {
    pub fn new() -> NumberStateResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(3);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &NumberStateResponse| { &m.key },
            |m: &mut NumberStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &NumberStateResponse| { &m.state },
            |m: &mut NumberStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "missing_state",
            |m: &NumberStateResponse| { &m.missing_state },
            |m: &mut NumberStateResponse| { &mut m.missing_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NumberStateResponse>(
            "NumberStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NumberStateResponse {
    const NAME: &'static str = "NumberStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                21 => {
                    self.state = is.read_float()?;
                },
                24 => {
                    self.missing_state = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != 0. {
            my_size += 1 + 4;
        }
        if self.missing_state != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != 0. {
            os.write_float(2, self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NumberStateResponse {
        NumberStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = 0.;
        self.missing_state = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NumberStateResponse {
        static instance: NumberStateResponse = NumberStateResponse {
            key: 0,
            state: 0.,
            missing_state: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NumberStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NumberStateResponse").unwrap()).clone()
    }
}

impl Display for NumberStateResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NumberStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:NumberCommandRequest)
pub struct NumberCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:NumberCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:NumberCommandRequest.state)
    pub state: f32,
    // special fields
    // @@protoc_insertion_point(special_field:NumberCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a NumberCommandRequest {
    fn default() -> &'a NumberCommandRequest {
        <NumberCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl NumberCommandRequest {
    pub fn new() -> NumberCommandRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(2);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &NumberCommandRequest| { &m.key },
            |m: &mut NumberCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &NumberCommandRequest| { &m.state },
            |m: &mut NumberCommandRequest| { &mut m.state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NumberCommandRequest>(
            "NumberCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NumberCommandRequest {
    const NAME: &'static str = "NumberCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                21 => {
                    self.state = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != 0. {
            os.write_float(2, self.state)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NumberCommandRequest {
        NumberCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NumberCommandRequest {
        static instance: NumberCommandRequest = NumberCommandRequest {
            key: 0,
            state: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NumberCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NumberCommandRequest").unwrap()).clone()
    }
}

impl Display for NumberCommandRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NumberCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ==================== SELECT ====================
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListEntitiesSelectResponse)
pub struct ListEntitiesSelectResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesSelectResponse.object_id)
    pub object_id: String,
    // @@protoc_insertion_point(field:ListEntitiesSelectResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesSelectResponse.name)
    pub name: String,
    // @@protoc_insertion_point(field:ListEntitiesSelectResponse.unique_id)
    pub unique_id: String,
    // @@protoc_insertion_point(field:ListEntitiesSelectResponse.icon)
    pub icon: String,
    // @@protoc_insertion_point(field:ListEntitiesSelectResponse.options)
    pub options: Vec<String>,
    // @@protoc_insertion_point(field:ListEntitiesSelectResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesSelectResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesSelectResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ListEntitiesSelectResponse {
    fn default() -> &'a ListEntitiesSelectResponse {
        <ListEntitiesSelectResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesSelectResponse {
    pub fn new() -> ListEntitiesSelectResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(8);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesSelectResponse| { &m.object_id },
            |m: &mut ListEntitiesSelectResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesSelectResponse| { &m.key },
            |m: &mut ListEntitiesSelectResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesSelectResponse| { &m.name },
            |m: &mut ListEntitiesSelectResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesSelectResponse| { &m.unique_id },
            |m: &mut ListEntitiesSelectResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesSelectResponse| { &m.icon },
            |m: &mut ListEntitiesSelectResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "options",
            |m: &ListEntitiesSelectResponse| { &m.options },
            |m: &mut ListEntitiesSelectResponse| { &mut m.options },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesSelectResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesSelectResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesSelectResponse| { &m.entity_category },
            |m: &mut ListEntitiesSelectResponse| { &mut m.entity_category },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesSelectResponse>(
            "ListEntitiesSelectResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesSelectResponse {
    const NAME: &'static str = "ListEntitiesSelectResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                50 => {
                    self.options.push(is.read_string()?);
                },
                56 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                64 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        for value in &self.options {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(8, self.entity_category.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        for v in &self.options {
            os.write_string(6, &v)?;
        };
        if self.disabled_by_default != false {
            os.write_bool(7, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesSelectResponse {
        ListEntitiesSelectResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.options.clear();
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesSelectResponse {
        static instance: ListEntitiesSelectResponse = ListEntitiesSelectResponse {
            object_id: String::new(),
            key: 0,
            name: String::new(),
            unique_id: String::new(),
            icon: String::new(),
            options: Vec::new(),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesSelectResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesSelectResponse").unwrap()).clone()
    }
}

impl Display for ListEntitiesSelectResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesSelectResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SelectStateResponse)
pub struct SelectStateResponse {
    // message fields
    // @@protoc_insertion_point(field:SelectStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:SelectStateResponse.state)
    pub state: String,
    ///  If the select does not have a valid state yet.
    ///  Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
    // @@protoc_insertion_point(field:SelectStateResponse.missing_state)
    pub missing_state: bool,
    // special fields
    // @@protoc_insertion_point(special_field:SelectStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a SelectStateResponse {
    fn default() -> &'a SelectStateResponse {
        <SelectStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SelectStateResponse {
    pub fn new() -> SelectStateResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(3);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &SelectStateResponse| { &m.key },
            |m: &mut SelectStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &SelectStateResponse| { &m.state },
            |m: &mut SelectStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "missing_state",
            |m: &SelectStateResponse| { &m.missing_state },
            |m: &mut SelectStateResponse| { &mut m.missing_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectStateResponse>(
            "SelectStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SelectStateResponse {
    const NAME: &'static str = "SelectStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                18 => {
                    self.state = is.read_string()?;
                },
                24 => {
                    self.missing_state = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state);
        }
        if self.missing_state != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if !self.state.is_empty() {
            os.write_string(2, &self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelectStateResponse {
        SelectStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state.clear();
        self.missing_state = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelectStateResponse {
        static instance: SelectStateResponse = SelectStateResponse {
            key: 0,
            state: String::new(),
            missing_state: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SelectStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SelectStateResponse").unwrap()).clone()
    }
}

impl Display for SelectStateResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SelectCommandRequest)
pub struct SelectCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:SelectCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:SelectCommandRequest.state)
    pub state: String,
    // special fields
    // @@protoc_insertion_point(special_field:SelectCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a SelectCommandRequest {
    fn default() -> &'a SelectCommandRequest {
        <SelectCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl SelectCommandRequest {
    pub fn new() -> SelectCommandRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(2);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &SelectCommandRequest| { &m.key },
            |m: &mut SelectCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &SelectCommandRequest| { &m.state },
            |m: &mut SelectCommandRequest| { &mut m.state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectCommandRequest>(
            "SelectCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SelectCommandRequest {
    const NAME: &'static str = "SelectCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                18 => {
                    self.state = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if !self.state.is_empty() {
            os.write_string(2, &self.state)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelectCommandRequest {
        SelectCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelectCommandRequest {
        static instance: SelectCommandRequest = SelectCommandRequest {
            key: 0,
            state: String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SelectCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SelectCommandRequest").unwrap()).clone()
    }
}

impl Display for SelectCommandRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListEntitiesLockResponse)
pub struct ListEntitiesLockResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.object_id)
    pub object_id: String,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.name)
    pub name: String,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.unique_id)
    pub unique_id: String,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.icon)
    pub icon: String,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.assumed_state)
    pub assumed_state: bool,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.supports_open)
    pub supports_open: bool,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.requires_code)
    pub requires_code: bool,
    ///  Not yet implemented:
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.code_format)
    pub code_format: String,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesLockResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ListEntitiesLockResponse {
    fn default() -> &'a ListEntitiesLockResponse {
        <ListEntitiesLockResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesLockResponse {
    pub fn new() -> ListEntitiesLockResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(11);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesLockResponse| { &m.object_id },
            |m: &mut ListEntitiesLockResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesLockResponse| { &m.key },
            |m: &mut ListEntitiesLockResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesLockResponse| { &m.name },
            |m: &mut ListEntitiesLockResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesLockResponse| { &m.unique_id },
            |m: &mut ListEntitiesLockResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesLockResponse| { &m.icon },
            |m: &mut ListEntitiesLockResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesLockResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesLockResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesLockResponse| { &m.entity_category },
            |m: &mut ListEntitiesLockResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "assumed_state",
            |m: &ListEntitiesLockResponse| { &m.assumed_state },
            |m: &mut ListEntitiesLockResponse| { &mut m.assumed_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_open",
            |m: &ListEntitiesLockResponse| { &m.supports_open },
            |m: &mut ListEntitiesLockResponse| { &mut m.supports_open },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requires_code",
            |m: &ListEntitiesLockResponse| { &m.requires_code },
            |m: &mut ListEntitiesLockResponse| { &mut m.requires_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code_format",
            |m: &ListEntitiesLockResponse| { &m.code_format },
            |m: &mut ListEntitiesLockResponse| { &mut m.code_format },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesLockResponse>(
            "ListEntitiesLockResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesLockResponse {
    const NAME: &'static str = "ListEntitiesLockResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                48 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                56 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                64 => {
                    self.assumed_state = is.read_bool()?;
                },
                72 => {
                    self.supports_open = is.read_bool()?;
                },
                80 => {
                    self.requires_code = is.read_bool()?;
                },
                90 => {
                    self.code_format = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.entity_category.value());
        }
        if self.assumed_state != false {
            my_size += 1 + 1;
        }
        if self.supports_open != false {
            my_size += 1 + 1;
        }
        if self.requires_code != false {
            my_size += 1 + 1;
        }
        if !self.code_format.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.code_format);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if self.assumed_state != false {
            os.write_bool(8, self.assumed_state)?;
        }
        if self.supports_open != false {
            os.write_bool(9, self.supports_open)?;
        }
        if self.requires_code != false {
            os.write_bool(10, self.requires_code)?;
        }
        if !self.code_format.is_empty() {
            os.write_string(11, &self.code_format)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesLockResponse {
        ListEntitiesLockResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.assumed_state = false;
        self.supports_open = false;
        self.requires_code = false;
        self.code_format.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesLockResponse {
        static instance: ListEntitiesLockResponse = ListEntitiesLockResponse {
            object_id: String::new(),
            key: 0,
            name: String::new(),
            unique_id: String::new(),
            icon: String::new(),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            assumed_state: false,
            supports_open: false,
            requires_code: false,
            code_format: String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesLockResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesLockResponse").unwrap()).clone()
    }
}

impl Display for ListEntitiesLockResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesLockResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:LockStateResponse)
pub struct LockStateResponse {
    // message fields
    // @@protoc_insertion_point(field:LockStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:LockStateResponse.state)
    pub state: ::protobuf::EnumOrUnknown<LockState>,
    // special fields
    // @@protoc_insertion_point(special_field:LockStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a LockStateResponse {
    fn default() -> &'a LockStateResponse {
        <LockStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl LockStateResponse {
    pub fn new() -> LockStateResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(2);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &LockStateResponse| { &m.key },
            |m: &mut LockStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &LockStateResponse| { &m.state },
            |m: &mut LockStateResponse| { &mut m.state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LockStateResponse>(
            "LockStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LockStateResponse {
    const NAME: &'static str = "LockStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.state = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != ::protobuf::EnumOrUnknown::new(LockState::LOCK_STATE_NONE) {
            my_size += ::protobuf::rt::int32_size(2, self.state.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != ::protobuf::EnumOrUnknown::new(LockState::LOCK_STATE_NONE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.state))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LockStateResponse {
        LockStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = ::protobuf::EnumOrUnknown::new(LockState::LOCK_STATE_NONE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LockStateResponse {
        static instance: LockStateResponse = LockStateResponse {
            key: 0,
            state: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LockStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LockStateResponse").unwrap()).clone()
    }
}

impl Display for LockStateResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LockStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:LockCommandRequest)
pub struct LockCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:LockCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:LockCommandRequest.command)
    pub command: ::protobuf::EnumOrUnknown<LockCommand>,
    ///  Not yet implemented:
    // @@protoc_insertion_point(field:LockCommandRequest.has_code)
    pub has_code: bool,
    // @@protoc_insertion_point(field:LockCommandRequest.code)
    pub code: String,
    // special fields
    // @@protoc_insertion_point(special_field:LockCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a LockCommandRequest {
    fn default() -> &'a LockCommandRequest {
        <LockCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl LockCommandRequest {
    pub fn new() -> LockCommandRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(4);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &LockCommandRequest| { &m.key },
            |m: &mut LockCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "command",
            |m: &LockCommandRequest| { &m.command },
            |m: &mut LockCommandRequest| { &mut m.command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_code",
            |m: &LockCommandRequest| { &m.has_code },
            |m: &mut LockCommandRequest| { &mut m.has_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &LockCommandRequest| { &m.code },
            |m: &mut LockCommandRequest| { &mut m.code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LockCommandRequest>(
            "LockCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LockCommandRequest {
    const NAME: &'static str = "LockCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.command = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.has_code = is.read_bool()?;
                },
                34 => {
                    self.code = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.command != ::protobuf::EnumOrUnknown::new(LockCommand::LOCK_UNLOCK) {
            my_size += ::protobuf::rt::int32_size(2, self.command.value());
        }
        if self.has_code != false {
            my_size += 1 + 1;
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.command != ::protobuf::EnumOrUnknown::new(LockCommand::LOCK_UNLOCK) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.command))?;
        }
        if self.has_code != false {
            os.write_bool(3, self.has_code)?;
        }
        if !self.code.is_empty() {
            os.write_string(4, &self.code)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LockCommandRequest {
        LockCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.command = ::protobuf::EnumOrUnknown::new(LockCommand::LOCK_UNLOCK);
        self.has_code = false;
        self.code.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LockCommandRequest {
        static instance: LockCommandRequest = LockCommandRequest {
            key: 0,
            command: ::protobuf::EnumOrUnknown::from_i32(0),
            has_code: false,
            code: String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LockCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LockCommandRequest").unwrap()).clone()
    }
}

impl Display for LockCommandRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LockCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ==================== BUTTON ====================
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListEntitiesButtonResponse)
pub struct ListEntitiesButtonResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesButtonResponse.object_id)
    pub object_id: String,
    // @@protoc_insertion_point(field:ListEntitiesButtonResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesButtonResponse.name)
    pub name: String,
    // @@protoc_insertion_point(field:ListEntitiesButtonResponse.unique_id)
    pub unique_id: String,
    // @@protoc_insertion_point(field:ListEntitiesButtonResponse.icon)
    pub icon: String,
    // @@protoc_insertion_point(field:ListEntitiesButtonResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesButtonResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesButtonResponse.device_class)
    pub device_class: String,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesButtonResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ListEntitiesButtonResponse {
    fn default() -> &'a ListEntitiesButtonResponse {
        <ListEntitiesButtonResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesButtonResponse {
    pub fn new() -> ListEntitiesButtonResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(8);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesButtonResponse| { &m.object_id },
            |m: &mut ListEntitiesButtonResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesButtonResponse| { &m.key },
            |m: &mut ListEntitiesButtonResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesButtonResponse| { &m.name },
            |m: &mut ListEntitiesButtonResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesButtonResponse| { &m.unique_id },
            |m: &mut ListEntitiesButtonResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesButtonResponse| { &m.icon },
            |m: &mut ListEntitiesButtonResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesButtonResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesButtonResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesButtonResponse| { &m.entity_category },
            |m: &mut ListEntitiesButtonResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_class",
            |m: &ListEntitiesButtonResponse| { &m.device_class },
            |m: &mut ListEntitiesButtonResponse| { &mut m.device_class },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesButtonResponse>(
            "ListEntitiesButtonResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesButtonResponse {
    const NAME: &'static str = "ListEntitiesButtonResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                48 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                56 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                66 => {
                    self.device_class = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.entity_category.value());
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.device_class);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if !self.device_class.is_empty() {
            os.write_string(8, &self.device_class)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesButtonResponse {
        ListEntitiesButtonResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.device_class.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesButtonResponse {
        static instance: ListEntitiesButtonResponse = ListEntitiesButtonResponse {
            object_id: String::new(),
            key: 0,
            name: String::new(),
            unique_id: String::new(),
            icon: String::new(),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            device_class: String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesButtonResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesButtonResponse").unwrap()).clone()
    }
}

impl Display for ListEntitiesButtonResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesButtonResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ButtonCommandRequest)
pub struct ButtonCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:ButtonCommandRequest.key)
    pub key: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ButtonCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ButtonCommandRequest {
    fn default() -> &'a ButtonCommandRequest {
        <ButtonCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl ButtonCommandRequest {
    pub fn new() -> ButtonCommandRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(1);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ButtonCommandRequest| { &m.key },
            |m: &mut ButtonCommandRequest| { &mut m.key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ButtonCommandRequest>(
            "ButtonCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ButtonCommandRequest {
    const NAME: &'static str = "ButtonCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ButtonCommandRequest {
        ButtonCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ButtonCommandRequest {
        static instance: ButtonCommandRequest = ButtonCommandRequest {
            key: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ButtonCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ButtonCommandRequest").unwrap()).clone()
    }
}

impl Display for ButtonCommandRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ButtonCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ListEntitiesMediaPlayerResponse)
pub struct ListEntitiesMediaPlayerResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesMediaPlayerResponse.object_id)
    pub object_id: String,
    // @@protoc_insertion_point(field:ListEntitiesMediaPlayerResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesMediaPlayerResponse.name)
    pub name: String,
    // @@protoc_insertion_point(field:ListEntitiesMediaPlayerResponse.unique_id)
    pub unique_id: String,
    // @@protoc_insertion_point(field:ListEntitiesMediaPlayerResponse.icon)
    pub icon: String,
    // @@protoc_insertion_point(field:ListEntitiesMediaPlayerResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesMediaPlayerResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesMediaPlayerResponse.supports_pause)
    pub supports_pause: bool,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesMediaPlayerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a ListEntitiesMediaPlayerResponse {
    fn default() -> &'a ListEntitiesMediaPlayerResponse {
        <ListEntitiesMediaPlayerResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesMediaPlayerResponse {
    pub fn new() -> ListEntitiesMediaPlayerResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(8);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesMediaPlayerResponse| { &m.object_id },
            |m: &mut ListEntitiesMediaPlayerResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesMediaPlayerResponse| { &m.key },
            |m: &mut ListEntitiesMediaPlayerResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesMediaPlayerResponse| { &m.name },
            |m: &mut ListEntitiesMediaPlayerResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesMediaPlayerResponse| { &m.unique_id },
            |m: &mut ListEntitiesMediaPlayerResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesMediaPlayerResponse| { &m.icon },
            |m: &mut ListEntitiesMediaPlayerResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesMediaPlayerResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesMediaPlayerResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesMediaPlayerResponse| { &m.entity_category },
            |m: &mut ListEntitiesMediaPlayerResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_pause",
            |m: &ListEntitiesMediaPlayerResponse| { &m.supports_pause },
            |m: &mut ListEntitiesMediaPlayerResponse| { &mut m.supports_pause },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesMediaPlayerResponse>(
            "ListEntitiesMediaPlayerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesMediaPlayerResponse {
    const NAME: &'static str = "ListEntitiesMediaPlayerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                48 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                56 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                64 => {
                    self.supports_pause = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.entity_category.value());
        }
        if self.supports_pause != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if self.supports_pause != false {
            os.write_bool(8, self.supports_pause)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesMediaPlayerResponse {
        ListEntitiesMediaPlayerResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.supports_pause = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesMediaPlayerResponse {
        static instance: ListEntitiesMediaPlayerResponse = ListEntitiesMediaPlayerResponse {
            object_id: String::new(),
            key: 0,
            name: String::new(),
            unique_id: String::new(),
            icon: String::new(),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            supports_pause: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesMediaPlayerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesMediaPlayerResponse").unwrap()).clone()
    }
}

impl Display for ListEntitiesMediaPlayerResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesMediaPlayerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MediaPlayerStateResponse)
pub struct MediaPlayerStateResponse {
    // message fields
    // @@protoc_insertion_point(field:MediaPlayerStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:MediaPlayerStateResponse.state)
    pub state: ::protobuf::EnumOrUnknown<MediaPlayerState>,
    // @@protoc_insertion_point(field:MediaPlayerStateResponse.volume)
    pub volume: f32,
    // @@protoc_insertion_point(field:MediaPlayerStateResponse.muted)
    pub muted: bool,
    // special fields
    // @@protoc_insertion_point(special_field:MediaPlayerStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a MediaPlayerStateResponse {
    fn default() -> &'a MediaPlayerStateResponse {
        <MediaPlayerStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl MediaPlayerStateResponse {
    pub fn new() -> MediaPlayerStateResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(4);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &MediaPlayerStateResponse| { &m.key },
            |m: &mut MediaPlayerStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &MediaPlayerStateResponse| { &m.state },
            |m: &mut MediaPlayerStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "volume",
            |m: &MediaPlayerStateResponse| { &m.volume },
            |m: &mut MediaPlayerStateResponse| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "muted",
            |m: &MediaPlayerStateResponse| { &m.muted },
            |m: &mut MediaPlayerStateResponse| { &mut m.muted },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaPlayerStateResponse>(
            "MediaPlayerStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaPlayerStateResponse {
    const NAME: &'static str = "MediaPlayerStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.state = is.read_enum_or_unknown()?;
                },
                29 => {
                    self.volume = is.read_float()?;
                },
                32 => {
                    self.muted = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != ::protobuf::EnumOrUnknown::new(MediaPlayerState::MEDIA_PLAYER_STATE_NONE) {
            my_size += ::protobuf::rt::int32_size(2, self.state.value());
        }
        if self.volume != 0. {
            my_size += 1 + 4;
        }
        if self.muted != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != ::protobuf::EnumOrUnknown::new(MediaPlayerState::MEDIA_PLAYER_STATE_NONE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.state))?;
        }
        if self.volume != 0. {
            os.write_float(3, self.volume)?;
        }
        if self.muted != false {
            os.write_bool(4, self.muted)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaPlayerStateResponse {
        MediaPlayerStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = ::protobuf::EnumOrUnknown::new(MediaPlayerState::MEDIA_PLAYER_STATE_NONE);
        self.volume = 0.;
        self.muted = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaPlayerStateResponse {
        static instance: MediaPlayerStateResponse = MediaPlayerStateResponse {
            key: 0,
            state: ::protobuf::EnumOrUnknown::from_i32(0),
            volume: 0.,
            muted: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaPlayerStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaPlayerStateResponse").unwrap()).clone()
    }
}

impl Display for MediaPlayerStateResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaPlayerStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MediaPlayerCommandRequest)
pub struct MediaPlayerCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:MediaPlayerCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:MediaPlayerCommandRequest.has_command)
    pub has_command: bool,
    // @@protoc_insertion_point(field:MediaPlayerCommandRequest.command)
    pub command: ::protobuf::EnumOrUnknown<MediaPlayerCommand>,
    // @@protoc_insertion_point(field:MediaPlayerCommandRequest.has_volume)
    pub has_volume: bool,
    // @@protoc_insertion_point(field:MediaPlayerCommandRequest.volume)
    pub volume: f32,
    // @@protoc_insertion_point(field:MediaPlayerCommandRequest.has_media_url)
    pub has_media_url: bool,
    // @@protoc_insertion_point(field:MediaPlayerCommandRequest.media_url)
    pub media_url: String,
    // special fields
    // @@protoc_insertion_point(special_field:MediaPlayerCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a MediaPlayerCommandRequest {
    fn default() -> &'a MediaPlayerCommandRequest {
        <MediaPlayerCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl MediaPlayerCommandRequest {
    pub fn new() -> MediaPlayerCommandRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(7);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &MediaPlayerCommandRequest| { &m.key },
            |m: &mut MediaPlayerCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_command",
            |m: &MediaPlayerCommandRequest| { &m.has_command },
            |m: &mut MediaPlayerCommandRequest| { &mut m.has_command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "command",
            |m: &MediaPlayerCommandRequest| { &m.command },
            |m: &mut MediaPlayerCommandRequest| { &mut m.command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_volume",
            |m: &MediaPlayerCommandRequest| { &m.has_volume },
            |m: &mut MediaPlayerCommandRequest| { &mut m.has_volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "volume",
            |m: &MediaPlayerCommandRequest| { &m.volume },
            |m: &mut MediaPlayerCommandRequest| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_media_url",
            |m: &MediaPlayerCommandRequest| { &m.has_media_url },
            |m: &mut MediaPlayerCommandRequest| { &mut m.has_media_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "media_url",
            |m: &MediaPlayerCommandRequest| { &m.media_url },
            |m: &mut MediaPlayerCommandRequest| { &mut m.media_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaPlayerCommandRequest>(
            "MediaPlayerCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaPlayerCommandRequest {
    const NAME: &'static str = "MediaPlayerCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.has_command = is.read_bool()?;
                },
                24 => {
                    self.command = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.has_volume = is.read_bool()?;
                },
                45 => {
                    self.volume = is.read_float()?;
                },
                48 => {
                    self.has_media_url = is.read_bool()?;
                },
                58 => {
                    self.media_url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.has_command != false {
            my_size += 1 + 1;
        }
        if self.command != ::protobuf::EnumOrUnknown::new(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_PLAY) {
            my_size += ::protobuf::rt::int32_size(3, self.command.value());
        }
        if self.has_volume != false {
            my_size += 1 + 1;
        }
        if self.volume != 0. {
            my_size += 1 + 4;
        }
        if self.has_media_url != false {
            my_size += 1 + 1;
        }
        if !self.media_url.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.media_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_command != false {
            os.write_bool(2, self.has_command)?;
        }
        if self.command != ::protobuf::EnumOrUnknown::new(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_PLAY) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.command))?;
        }
        if self.has_volume != false {
            os.write_bool(4, self.has_volume)?;
        }
        if self.volume != 0. {
            os.write_float(5, self.volume)?;
        }
        if self.has_media_url != false {
            os.write_bool(6, self.has_media_url)?;
        }
        if !self.media_url.is_empty() {
            os.write_string(7, &self.media_url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaPlayerCommandRequest {
        MediaPlayerCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.has_command = false;
        self.command = ::protobuf::EnumOrUnknown::new(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_PLAY);
        self.has_volume = false;
        self.volume = 0.;
        self.has_media_url = false;
        self.media_url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaPlayerCommandRequest {
        static instance: MediaPlayerCommandRequest = MediaPlayerCommandRequest {
            key: 0,
            has_command: false,
            command: ::protobuf::EnumOrUnknown::from_i32(0),
            has_volume: false,
            volume: 0.,
            has_media_url: false,
            media_url: String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaPlayerCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaPlayerCommandRequest").unwrap()).clone()
    }
}

impl Display for MediaPlayerCommandRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaPlayerCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  ==================== BLUETOOTH ====================
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SubscribeBluetoothLEAdvertisementsRequest)
pub struct SubscribeBluetoothLEAdvertisementsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeBluetoothLEAdvertisementsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a SubscribeBluetoothLEAdvertisementsRequest {
    fn default() -> &'a SubscribeBluetoothLEAdvertisementsRequest {
        <SubscribeBluetoothLEAdvertisementsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeBluetoothLEAdvertisementsRequest {
    pub fn new() -> SubscribeBluetoothLEAdvertisementsRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::new();
        let mut oneofs = Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeBluetoothLEAdvertisementsRequest>(
            "SubscribeBluetoothLEAdvertisementsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeBluetoothLEAdvertisementsRequest {
    const NAME: &'static str = "SubscribeBluetoothLEAdvertisementsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeBluetoothLEAdvertisementsRequest {
        SubscribeBluetoothLEAdvertisementsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeBluetoothLEAdvertisementsRequest {
        static instance: SubscribeBluetoothLEAdvertisementsRequest = SubscribeBluetoothLEAdvertisementsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeBluetoothLEAdvertisementsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeBluetoothLEAdvertisementsRequest").unwrap()).clone()
    }
}

impl Display for SubscribeBluetoothLEAdvertisementsRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeBluetoothLEAdvertisementsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BluetoothServiceData)
pub struct BluetoothServiceData {
    // message fields
    // @@protoc_insertion_point(field:BluetoothServiceData.uuid)
    pub uuid: String,
    // @@protoc_insertion_point(field:BluetoothServiceData.legacy_data)
    pub legacy_data: Vec<u32>,
    // @@protoc_insertion_point(field:BluetoothServiceData.data)
    pub data: Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothServiceData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a BluetoothServiceData {
    fn default() -> &'a BluetoothServiceData {
        <BluetoothServiceData as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothServiceData {
    pub fn new() -> BluetoothServiceData {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(3);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uuid",
            |m: &BluetoothServiceData| { &m.uuid },
            |m: &mut BluetoothServiceData| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "legacy_data",
            |m: &BluetoothServiceData| { &m.legacy_data },
            |m: &mut BluetoothServiceData| { &mut m.legacy_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &BluetoothServiceData| { &m.data },
            |m: &mut BluetoothServiceData| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothServiceData>(
            "BluetoothServiceData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothServiceData {
    const NAME: &'static str = "BluetoothServiceData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uuid = is.read_string()?;
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.legacy_data)?;
                },
                16 => {
                    self.legacy_data.push(is.read_uint32()?);
                },
                26 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uuid);
        }
        for value in &self.legacy_data {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.uuid.is_empty() {
            os.write_string(1, &self.uuid)?;
        }
        for v in &self.legacy_data {
            os.write_uint32(2, *v)?;
        };
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothServiceData {
        BluetoothServiceData::new()
    }

    fn clear(&mut self) {
        self.uuid.clear();
        self.legacy_data.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothServiceData {
        static instance: BluetoothServiceData = BluetoothServiceData {
            uuid: String::new(),
            legacy_data: Vec::new(),
            data: Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothServiceData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothServiceData").unwrap()).clone()
    }
}

impl Display for BluetoothServiceData {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothServiceData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BluetoothLEAdvertisementResponse)
pub struct BluetoothLEAdvertisementResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothLEAdvertisementResponse.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothLEAdvertisementResponse.name)
    pub name: String,
    // @@protoc_insertion_point(field:BluetoothLEAdvertisementResponse.rssi)
    pub rssi: i32,
    // @@protoc_insertion_point(field:BluetoothLEAdvertisementResponse.service_uuids)
    pub service_uuids: Vec<String>,
    // @@protoc_insertion_point(field:BluetoothLEAdvertisementResponse.service_data)
    pub service_data: Vec<BluetoothServiceData>,
    // @@protoc_insertion_point(field:BluetoothLEAdvertisementResponse.manufacturer_data)
    pub manufacturer_data: Vec<BluetoothServiceData>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothLEAdvertisementResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a BluetoothLEAdvertisementResponse {
    fn default() -> &'a BluetoothLEAdvertisementResponse {
        <BluetoothLEAdvertisementResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothLEAdvertisementResponse {
    pub fn new() -> BluetoothLEAdvertisementResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(6);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothLEAdvertisementResponse| { &m.address },
            |m: &mut BluetoothLEAdvertisementResponse| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &BluetoothLEAdvertisementResponse| { &m.name },
            |m: &mut BluetoothLEAdvertisementResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rssi",
            |m: &BluetoothLEAdvertisementResponse| { &m.rssi },
            |m: &mut BluetoothLEAdvertisementResponse| { &mut m.rssi },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "service_uuids",
            |m: &BluetoothLEAdvertisementResponse| { &m.service_uuids },
            |m: &mut BluetoothLEAdvertisementResponse| { &mut m.service_uuids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "service_data",
            |m: &BluetoothLEAdvertisementResponse| { &m.service_data },
            |m: &mut BluetoothLEAdvertisementResponse| { &mut m.service_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "manufacturer_data",
            |m: &BluetoothLEAdvertisementResponse| { &m.manufacturer_data },
            |m: &mut BluetoothLEAdvertisementResponse| { &mut m.manufacturer_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothLEAdvertisementResponse>(
            "BluetoothLEAdvertisementResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothLEAdvertisementResponse {
    const NAME: &'static str = "BluetoothLEAdvertisementResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                24 => {
                    self.rssi = is.read_sint32()?;
                },
                34 => {
                    self.service_uuids.push(is.read_string()?);
                },
                42 => {
                    self.service_data.push(is.read_message()?);
                },
                50 => {
                    self.manufacturer_data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.rssi != 0 {
            my_size += ::protobuf::rt::sint32_size(3, self.rssi);
        }
        for value in &self.service_uuids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.service_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.manufacturer_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.rssi != 0 {
            os.write_sint32(3, self.rssi)?;
        }
        for v in &self.service_uuids {
            os.write_string(4, &v)?;
        };
        for v in &self.service_data {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.manufacturer_data {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothLEAdvertisementResponse {
        BluetoothLEAdvertisementResponse::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.name.clear();
        self.rssi = 0;
        self.service_uuids.clear();
        self.service_data.clear();
        self.manufacturer_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothLEAdvertisementResponse {
        static instance: BluetoothLEAdvertisementResponse = BluetoothLEAdvertisementResponse {
            address: 0,
            name: String::new(),
            rssi: 0,
            service_uuids: Vec::new(),
            service_data: Vec::new(),
            manufacturer_data: Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothLEAdvertisementResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothLEAdvertisementResponse").unwrap()).clone()
    }
}

impl Display for BluetoothLEAdvertisementResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothLEAdvertisementResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BluetoothDeviceRequest)
pub struct BluetoothDeviceRequest {
    // message fields
    // @@protoc_insertion_point(field:BluetoothDeviceRequest.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothDeviceRequest.request_type)
    pub request_type: ::protobuf::EnumOrUnknown<BluetoothDeviceRequestType>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothDeviceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a BluetoothDeviceRequest {
    fn default() -> &'a BluetoothDeviceRequest {
        <BluetoothDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothDeviceRequest {
    pub fn new() -> BluetoothDeviceRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(2);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothDeviceRequest| { &m.address },
            |m: &mut BluetoothDeviceRequest| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "request_type",
            |m: &BluetoothDeviceRequest| { &m.request_type },
            |m: &mut BluetoothDeviceRequest| { &mut m.request_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothDeviceRequest>(
            "BluetoothDeviceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothDeviceRequest {
    const NAME: &'static str = "BluetoothDeviceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.request_type = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.request_type != ::protobuf::EnumOrUnknown::new(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT) {
            my_size += ::protobuf::rt::int32_size(2, self.request_type.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.request_type != ::protobuf::EnumOrUnknown::new(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.request_type))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothDeviceRequest {
        BluetoothDeviceRequest::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.request_type = ::protobuf::EnumOrUnknown::new(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothDeviceRequest {
        static instance: BluetoothDeviceRequest = BluetoothDeviceRequest {
            address: 0,
            request_type: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothDeviceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothDeviceRequest").unwrap()).clone()
    }
}

impl Display for BluetoothDeviceRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothDeviceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BluetoothDeviceConnectionResponse)
pub struct BluetoothDeviceConnectionResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothDeviceConnectionResponse.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothDeviceConnectionResponse.connected)
    pub connected: bool,
    // @@protoc_insertion_point(field:BluetoothDeviceConnectionResponse.mtu)
    pub mtu: u32,
    // @@protoc_insertion_point(field:BluetoothDeviceConnectionResponse.error)
    pub error: i32,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothDeviceConnectionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a BluetoothDeviceConnectionResponse {
    fn default() -> &'a BluetoothDeviceConnectionResponse {
        <BluetoothDeviceConnectionResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothDeviceConnectionResponse {
    pub fn new() -> BluetoothDeviceConnectionResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(4);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothDeviceConnectionResponse| { &m.address },
            |m: &mut BluetoothDeviceConnectionResponse| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "connected",
            |m: &BluetoothDeviceConnectionResponse| { &m.connected },
            |m: &mut BluetoothDeviceConnectionResponse| { &mut m.connected },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mtu",
            |m: &BluetoothDeviceConnectionResponse| { &m.mtu },
            |m: &mut BluetoothDeviceConnectionResponse| { &mut m.mtu },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &BluetoothDeviceConnectionResponse| { &m.error },
            |m: &mut BluetoothDeviceConnectionResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothDeviceConnectionResponse>(
            "BluetoothDeviceConnectionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothDeviceConnectionResponse {
    const NAME: &'static str = "BluetoothDeviceConnectionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.connected = is.read_bool()?;
                },
                24 => {
                    self.mtu = is.read_uint32()?;
                },
                32 => {
                    self.error = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.connected != false {
            my_size += 1 + 1;
        }
        if self.mtu != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.mtu);
        }
        if self.error != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.connected != false {
            os.write_bool(2, self.connected)?;
        }
        if self.mtu != 0 {
            os.write_uint32(3, self.mtu)?;
        }
        if self.error != 0 {
            os.write_int32(4, self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothDeviceConnectionResponse {
        BluetoothDeviceConnectionResponse::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.connected = false;
        self.mtu = 0;
        self.error = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothDeviceConnectionResponse {
        static instance: BluetoothDeviceConnectionResponse = BluetoothDeviceConnectionResponse {
            address: 0,
            connected: false,
            mtu: 0,
            error: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothDeviceConnectionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothDeviceConnectionResponse").unwrap()).clone()
    }
}

impl Display for BluetoothDeviceConnectionResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothDeviceConnectionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BluetoothGATTGetServicesRequest)
pub struct BluetoothGATTGetServicesRequest {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTGetServicesRequest.address)
    pub address: u64,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTGetServicesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a BluetoothGATTGetServicesRequest {
    fn default() -> &'a BluetoothGATTGetServicesRequest {
        <BluetoothGATTGetServicesRequest as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTGetServicesRequest {
    pub fn new() -> BluetoothGATTGetServicesRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(1);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTGetServicesRequest| { &m.address },
            |m: &mut BluetoothGATTGetServicesRequest| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTGetServicesRequest>(
            "BluetoothGATTGetServicesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTGetServicesRequest {
    const NAME: &'static str = "BluetoothGATTGetServicesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTGetServicesRequest {
        BluetoothGATTGetServicesRequest::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTGetServicesRequest {
        static instance: BluetoothGATTGetServicesRequest = BluetoothGATTGetServicesRequest {
            address: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTGetServicesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTGetServicesRequest").unwrap()).clone()
    }
}

impl Display for BluetoothGATTGetServicesRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTGetServicesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BluetoothGATTDescriptor)
pub struct BluetoothGATTDescriptor {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTDescriptor.uuid)
    pub uuid: Vec<u64>,
    // @@protoc_insertion_point(field:BluetoothGATTDescriptor.handle)
    pub handle: u32,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a BluetoothGATTDescriptor {
    fn default() -> &'a BluetoothGATTDescriptor {
        <BluetoothGATTDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTDescriptor {
    pub fn new() -> BluetoothGATTDescriptor {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(2);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uuid",
            |m: &BluetoothGATTDescriptor| { &m.uuid },
            |m: &mut BluetoothGATTDescriptor| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTDescriptor| { &m.handle },
            |m: &mut BluetoothGATTDescriptor| { &mut m.handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTDescriptor>(
            "BluetoothGATTDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTDescriptor {
    const NAME: &'static str = "BluetoothGATTDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.uuid)?;
                },
                8 => {
                    self.uuid.push(is.read_uint64()?);
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.uuid {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.uuid {
            os.write_uint64(1, *v)?;
        };
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTDescriptor {
        BluetoothGATTDescriptor::new()
    }

    fn clear(&mut self) {
        self.uuid.clear();
        self.handle = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTDescriptor {
        static instance: BluetoothGATTDescriptor = BluetoothGATTDescriptor {
            uuid: Vec::new(),
            handle: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTDescriptor").unwrap()).clone()
    }
}

impl Display for BluetoothGATTDescriptor {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BluetoothGATTCharacteristic)
pub struct BluetoothGATTCharacteristic {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTCharacteristic.uuid)
    pub uuid: Vec<u64>,
    // @@protoc_insertion_point(field:BluetoothGATTCharacteristic.handle)
    pub handle: u32,
    // @@protoc_insertion_point(field:BluetoothGATTCharacteristic.properties)
    pub properties: u32,
    // @@protoc_insertion_point(field:BluetoothGATTCharacteristic.descriptors)
    pub descriptors: Vec<BluetoothGATTDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTCharacteristic.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a BluetoothGATTCharacteristic {
    fn default() -> &'a BluetoothGATTCharacteristic {
        <BluetoothGATTCharacteristic as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTCharacteristic {
    pub fn new() -> BluetoothGATTCharacteristic {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(4);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uuid",
            |m: &BluetoothGATTCharacteristic| { &m.uuid },
            |m: &mut BluetoothGATTCharacteristic| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTCharacteristic| { &m.handle },
            |m: &mut BluetoothGATTCharacteristic| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "properties",
            |m: &BluetoothGATTCharacteristic| { &m.properties },
            |m: &mut BluetoothGATTCharacteristic| { &mut m.properties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "descriptors",
            |m: &BluetoothGATTCharacteristic| { &m.descriptors },
            |m: &mut BluetoothGATTCharacteristic| { &mut m.descriptors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTCharacteristic>(
            "BluetoothGATTCharacteristic",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTCharacteristic {
    const NAME: &'static str = "BluetoothGATTCharacteristic";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.uuid)?;
                },
                8 => {
                    self.uuid.push(is.read_uint64()?);
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                24 => {
                    self.properties = is.read_uint32()?;
                },
                34 => {
                    self.descriptors.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.uuid {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        if self.properties != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.properties);
        }
        for value in &self.descriptors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.uuid {
            os.write_uint64(1, *v)?;
        };
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        if self.properties != 0 {
            os.write_uint32(3, self.properties)?;
        }
        for v in &self.descriptors {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTCharacteristic {
        BluetoothGATTCharacteristic::new()
    }

    fn clear(&mut self) {
        self.uuid.clear();
        self.handle = 0;
        self.properties = 0;
        self.descriptors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTCharacteristic {
        static instance: BluetoothGATTCharacteristic = BluetoothGATTCharacteristic {
            uuid: Vec::new(),
            handle: 0,
            properties: 0,
            descriptors: Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTCharacteristic {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTCharacteristic").unwrap()).clone()
    }
}

impl Display for BluetoothGATTCharacteristic {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTCharacteristic {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BluetoothGATTService)
pub struct BluetoothGATTService {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTService.uuid)
    pub uuid: Vec<u64>,
    // @@protoc_insertion_point(field:BluetoothGATTService.handle)
    pub handle: u32,
    // @@protoc_insertion_point(field:BluetoothGATTService.characteristics)
    pub characteristics: Vec<BluetoothGATTCharacteristic>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTService.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a BluetoothGATTService {
    fn default() -> &'a BluetoothGATTService {
        <BluetoothGATTService as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTService {
    pub fn new() -> BluetoothGATTService {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(3);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uuid",
            |m: &BluetoothGATTService| { &m.uuid },
            |m: &mut BluetoothGATTService| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTService| { &m.handle },
            |m: &mut BluetoothGATTService| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "characteristics",
            |m: &BluetoothGATTService| { &m.characteristics },
            |m: &mut BluetoothGATTService| { &mut m.characteristics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTService>(
            "BluetoothGATTService",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTService {
    const NAME: &'static str = "BluetoothGATTService";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.uuid)?;
                },
                8 => {
                    self.uuid.push(is.read_uint64()?);
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                26 => {
                    self.characteristics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.uuid {
            my_size += ::protobuf::rt::uint64_size(1, *value);
        };
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        for value in &self.characteristics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.uuid {
            os.write_uint64(1, *v)?;
        };
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        for v in &self.characteristics {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTService {
        BluetoothGATTService::new()
    }

    fn clear(&mut self) {
        self.uuid.clear();
        self.handle = 0;
        self.characteristics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTService {
        static instance: BluetoothGATTService = BluetoothGATTService {
            uuid: Vec::new(),
            handle: 0,
            characteristics: Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTService {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTService").unwrap()).clone()
    }
}

impl Display for BluetoothGATTService {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTService {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BluetoothGATTGetServicesResponse)
pub struct BluetoothGATTGetServicesResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTGetServicesResponse.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothGATTGetServicesResponse.services)
    pub services: Vec<BluetoothGATTService>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTGetServicesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a BluetoothGATTGetServicesResponse {
    fn default() -> &'a BluetoothGATTGetServicesResponse {
        <BluetoothGATTGetServicesResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTGetServicesResponse {
    pub fn new() -> BluetoothGATTGetServicesResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(2);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTGetServicesResponse| { &m.address },
            |m: &mut BluetoothGATTGetServicesResponse| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "services",
            |m: &BluetoothGATTGetServicesResponse| { &m.services },
            |m: &mut BluetoothGATTGetServicesResponse| { &mut m.services },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTGetServicesResponse>(
            "BluetoothGATTGetServicesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTGetServicesResponse {
    const NAME: &'static str = "BluetoothGATTGetServicesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                18 => {
                    self.services.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        for value in &self.services {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        for v in &self.services {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTGetServicesResponse {
        BluetoothGATTGetServicesResponse::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.services.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTGetServicesResponse {
        static instance: BluetoothGATTGetServicesResponse = BluetoothGATTGetServicesResponse {
            address: 0,
            services: Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTGetServicesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTGetServicesResponse").unwrap()).clone()
    }
}

impl Display for BluetoothGATTGetServicesResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTGetServicesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BluetoothGATTGetServicesDoneResponse)
pub struct BluetoothGATTGetServicesDoneResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTGetServicesDoneResponse.address)
    pub address: u64,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTGetServicesDoneResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a BluetoothGATTGetServicesDoneResponse {
    fn default() -> &'a BluetoothGATTGetServicesDoneResponse {
        <BluetoothGATTGetServicesDoneResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTGetServicesDoneResponse {
    pub fn new() -> BluetoothGATTGetServicesDoneResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(1);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTGetServicesDoneResponse| { &m.address },
            |m: &mut BluetoothGATTGetServicesDoneResponse| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTGetServicesDoneResponse>(
            "BluetoothGATTGetServicesDoneResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTGetServicesDoneResponse {
    const NAME: &'static str = "BluetoothGATTGetServicesDoneResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTGetServicesDoneResponse {
        BluetoothGATTGetServicesDoneResponse::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTGetServicesDoneResponse {
        static instance: BluetoothGATTGetServicesDoneResponse = BluetoothGATTGetServicesDoneResponse {
            address: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTGetServicesDoneResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTGetServicesDoneResponse").unwrap()).clone()
    }
}

impl Display for BluetoothGATTGetServicesDoneResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTGetServicesDoneResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BluetoothGATTReadRequest)
pub struct BluetoothGATTReadRequest {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTReadRequest.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothGATTReadRequest.handle)
    pub handle: u32,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTReadRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a BluetoothGATTReadRequest {
    fn default() -> &'a BluetoothGATTReadRequest {
        <BluetoothGATTReadRequest as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTReadRequest {
    pub fn new() -> BluetoothGATTReadRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(2);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTReadRequest| { &m.address },
            |m: &mut BluetoothGATTReadRequest| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTReadRequest| { &m.handle },
            |m: &mut BluetoothGATTReadRequest| { &mut m.handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTReadRequest>(
            "BluetoothGATTReadRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTReadRequest {
    const NAME: &'static str = "BluetoothGATTReadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTReadRequest {
        BluetoothGATTReadRequest::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.handle = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTReadRequest {
        static instance: BluetoothGATTReadRequest = BluetoothGATTReadRequest {
            address: 0,
            handle: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTReadRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTReadRequest").unwrap()).clone()
    }
}

impl Display for BluetoothGATTReadRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTReadRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BluetoothGATTReadResponse)
pub struct BluetoothGATTReadResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTReadResponse.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothGATTReadResponse.handle)
    pub handle: u32,
    // @@protoc_insertion_point(field:BluetoothGATTReadResponse.data)
    pub data: Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTReadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a BluetoothGATTReadResponse {
    fn default() -> &'a BluetoothGATTReadResponse {
        <BluetoothGATTReadResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTReadResponse {
    pub fn new() -> BluetoothGATTReadResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(3);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTReadResponse| { &m.address },
            |m: &mut BluetoothGATTReadResponse| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTReadResponse| { &m.handle },
            |m: &mut BluetoothGATTReadResponse| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &BluetoothGATTReadResponse| { &m.data },
            |m: &mut BluetoothGATTReadResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTReadResponse>(
            "BluetoothGATTReadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTReadResponse {
    const NAME: &'static str = "BluetoothGATTReadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                26 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTReadResponse {
        BluetoothGATTReadResponse::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.handle = 0;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTReadResponse {
        static instance: BluetoothGATTReadResponse = BluetoothGATTReadResponse {
            address: 0,
            handle: 0,
            data: Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTReadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTReadResponse").unwrap()).clone()
    }
}

impl Display for BluetoothGATTReadResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTReadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BluetoothGATTWriteRequest)
pub struct BluetoothGATTWriteRequest {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTWriteRequest.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothGATTWriteRequest.handle)
    pub handle: u32,
    // @@protoc_insertion_point(field:BluetoothGATTWriteRequest.response)
    pub response: bool,
    // @@protoc_insertion_point(field:BluetoothGATTWriteRequest.data)
    pub data: Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTWriteRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a BluetoothGATTWriteRequest {
    fn default() -> &'a BluetoothGATTWriteRequest {
        <BluetoothGATTWriteRequest as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTWriteRequest {
    pub fn new() -> BluetoothGATTWriteRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(4);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTWriteRequest| { &m.address },
            |m: &mut BluetoothGATTWriteRequest| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTWriteRequest| { &m.handle },
            |m: &mut BluetoothGATTWriteRequest| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "response",
            |m: &BluetoothGATTWriteRequest| { &m.response },
            |m: &mut BluetoothGATTWriteRequest| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &BluetoothGATTWriteRequest| { &m.data },
            |m: &mut BluetoothGATTWriteRequest| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTWriteRequest>(
            "BluetoothGATTWriteRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTWriteRequest {
    const NAME: &'static str = "BluetoothGATTWriteRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                24 => {
                    self.response = is.read_bool()?;
                },
                34 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        if self.response != false {
            my_size += 1 + 1;
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        if self.response != false {
            os.write_bool(3, self.response)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(4, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTWriteRequest {
        BluetoothGATTWriteRequest::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.handle = 0;
        self.response = false;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTWriteRequest {
        static instance: BluetoothGATTWriteRequest = BluetoothGATTWriteRequest {
            address: 0,
            handle: 0,
            response: false,
            data: Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTWriteRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTWriteRequest").unwrap()).clone()
    }
}

impl Display for BluetoothGATTWriteRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTWriteRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BluetoothGATTReadDescriptorRequest)
pub struct BluetoothGATTReadDescriptorRequest {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTReadDescriptorRequest.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothGATTReadDescriptorRequest.handle)
    pub handle: u32,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTReadDescriptorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a BluetoothGATTReadDescriptorRequest {
    fn default() -> &'a BluetoothGATTReadDescriptorRequest {
        <BluetoothGATTReadDescriptorRequest as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTReadDescriptorRequest {
    pub fn new() -> BluetoothGATTReadDescriptorRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(2);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTReadDescriptorRequest| { &m.address },
            |m: &mut BluetoothGATTReadDescriptorRequest| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTReadDescriptorRequest| { &m.handle },
            |m: &mut BluetoothGATTReadDescriptorRequest| { &mut m.handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTReadDescriptorRequest>(
            "BluetoothGATTReadDescriptorRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTReadDescriptorRequest {
    const NAME: &'static str = "BluetoothGATTReadDescriptorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTReadDescriptorRequest {
        BluetoothGATTReadDescriptorRequest::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.handle = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTReadDescriptorRequest {
        static instance: BluetoothGATTReadDescriptorRequest = BluetoothGATTReadDescriptorRequest {
            address: 0,
            handle: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTReadDescriptorRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTReadDescriptorRequest").unwrap()).clone()
    }
}

impl Display for BluetoothGATTReadDescriptorRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTReadDescriptorRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BluetoothGATTWriteDescriptorRequest)
pub struct BluetoothGATTWriteDescriptorRequest {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTWriteDescriptorRequest.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothGATTWriteDescriptorRequest.handle)
    pub handle: u32,
    // @@protoc_insertion_point(field:BluetoothGATTWriteDescriptorRequest.data)
    pub data: Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTWriteDescriptorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a BluetoothGATTWriteDescriptorRequest {
    fn default() -> &'a BluetoothGATTWriteDescriptorRequest {
        <BluetoothGATTWriteDescriptorRequest as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTWriteDescriptorRequest {
    pub fn new() -> BluetoothGATTWriteDescriptorRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(3);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTWriteDescriptorRequest| { &m.address },
            |m: &mut BluetoothGATTWriteDescriptorRequest| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTWriteDescriptorRequest| { &m.handle },
            |m: &mut BluetoothGATTWriteDescriptorRequest| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &BluetoothGATTWriteDescriptorRequest| { &m.data },
            |m: &mut BluetoothGATTWriteDescriptorRequest| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTWriteDescriptorRequest>(
            "BluetoothGATTWriteDescriptorRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTWriteDescriptorRequest {
    const NAME: &'static str = "BluetoothGATTWriteDescriptorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                26 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTWriteDescriptorRequest {
        BluetoothGATTWriteDescriptorRequest::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.handle = 0;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTWriteDescriptorRequest {
        static instance: BluetoothGATTWriteDescriptorRequest = BluetoothGATTWriteDescriptorRequest {
            address: 0,
            handle: 0,
            data: Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTWriteDescriptorRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTWriteDescriptorRequest").unwrap()).clone()
    }
}

impl Display for BluetoothGATTWriteDescriptorRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTWriteDescriptorRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BluetoothGATTNotifyRequest)
pub struct BluetoothGATTNotifyRequest {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTNotifyRequest.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothGATTNotifyRequest.handle)
    pub handle: u32,
    // @@protoc_insertion_point(field:BluetoothGATTNotifyRequest.enable)
    pub enable: bool,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTNotifyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a BluetoothGATTNotifyRequest {
    fn default() -> &'a BluetoothGATTNotifyRequest {
        <BluetoothGATTNotifyRequest as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTNotifyRequest {
    pub fn new() -> BluetoothGATTNotifyRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(3);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTNotifyRequest| { &m.address },
            |m: &mut BluetoothGATTNotifyRequest| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTNotifyRequest| { &m.handle },
            |m: &mut BluetoothGATTNotifyRequest| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "enable",
            |m: &BluetoothGATTNotifyRequest| { &m.enable },
            |m: &mut BluetoothGATTNotifyRequest| { &mut m.enable },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTNotifyRequest>(
            "BluetoothGATTNotifyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTNotifyRequest {
    const NAME: &'static str = "BluetoothGATTNotifyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                24 => {
                    self.enable = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        if self.enable != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        if self.enable != false {
            os.write_bool(3, self.enable)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTNotifyRequest {
        BluetoothGATTNotifyRequest::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.handle = 0;
        self.enable = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTNotifyRequest {
        static instance: BluetoothGATTNotifyRequest = BluetoothGATTNotifyRequest {
            address: 0,
            handle: 0,
            enable: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTNotifyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTNotifyRequest").unwrap()).clone()
    }
}

impl Display for BluetoothGATTNotifyRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTNotifyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BluetoothGATTNotifyDataResponse)
pub struct BluetoothGATTNotifyDataResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTNotifyDataResponse.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothGATTNotifyDataResponse.handle)
    pub handle: u32,
    // @@protoc_insertion_point(field:BluetoothGATTNotifyDataResponse.data)
    pub data: Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTNotifyDataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a BluetoothGATTNotifyDataResponse {
    fn default() -> &'a BluetoothGATTNotifyDataResponse {
        <BluetoothGATTNotifyDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTNotifyDataResponse {
    pub fn new() -> BluetoothGATTNotifyDataResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(3);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTNotifyDataResponse| { &m.address },
            |m: &mut BluetoothGATTNotifyDataResponse| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTNotifyDataResponse| { &m.handle },
            |m: &mut BluetoothGATTNotifyDataResponse| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &BluetoothGATTNotifyDataResponse| { &m.data },
            |m: &mut BluetoothGATTNotifyDataResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTNotifyDataResponse>(
            "BluetoothGATTNotifyDataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTNotifyDataResponse {
    const NAME: &'static str = "BluetoothGATTNotifyDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                26 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTNotifyDataResponse {
        BluetoothGATTNotifyDataResponse::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.handle = 0;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTNotifyDataResponse {
        static instance: BluetoothGATTNotifyDataResponse = BluetoothGATTNotifyDataResponse {
            address: 0,
            handle: 0,
            data: Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTNotifyDataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTNotifyDataResponse").unwrap()).clone()
    }
}

impl Display for BluetoothGATTNotifyDataResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTNotifyDataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:SubscribeBluetoothConnectionsFreeRequest)
pub struct SubscribeBluetoothConnectionsFreeRequest {
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeBluetoothConnectionsFreeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a SubscribeBluetoothConnectionsFreeRequest {
    fn default() -> &'a SubscribeBluetoothConnectionsFreeRequest {
        <SubscribeBluetoothConnectionsFreeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeBluetoothConnectionsFreeRequest {
    pub fn new() -> SubscribeBluetoothConnectionsFreeRequest {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::new();
        let mut oneofs = Vec::new();
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeBluetoothConnectionsFreeRequest>(
            "SubscribeBluetoothConnectionsFreeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeBluetoothConnectionsFreeRequest {
    const NAME: &'static str = "SubscribeBluetoothConnectionsFreeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeBluetoothConnectionsFreeRequest {
        SubscribeBluetoothConnectionsFreeRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeBluetoothConnectionsFreeRequest {
        static instance: SubscribeBluetoothConnectionsFreeRequest = SubscribeBluetoothConnectionsFreeRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeBluetoothConnectionsFreeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeBluetoothConnectionsFreeRequest").unwrap()).clone()
    }
}

impl Display for SubscribeBluetoothConnectionsFreeRequest {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeBluetoothConnectionsFreeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BluetoothConnectionsFreeResponse)
pub struct BluetoothConnectionsFreeResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothConnectionsFreeResponse.free)
    pub free: u32,
    // @@protoc_insertion_point(field:BluetoothConnectionsFreeResponse.limit)
    pub limit: u32,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothConnectionsFreeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> Default for &'a BluetoothConnectionsFreeResponse {
    fn default() -> &'a BluetoothConnectionsFreeResponse {
        <BluetoothConnectionsFreeResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothConnectionsFreeResponse {
    pub fn new() -> BluetoothConnectionsFreeResponse {
        Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = Vec::with_capacity(2);
        let mut oneofs = Vec::new();
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "free",
            |m: &BluetoothConnectionsFreeResponse| { &m.free },
            |m: &mut BluetoothConnectionsFreeResponse| { &mut m.free },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &BluetoothConnectionsFreeResponse| { &m.limit },
            |m: &mut BluetoothConnectionsFreeResponse| { &mut m.limit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothConnectionsFreeResponse>(
            "BluetoothConnectionsFreeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothConnectionsFreeResponse {
    const NAME: &'static str = "BluetoothConnectionsFreeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.free = is.read_uint32()?;
                },
                16 => {
                    self.limit = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages

    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.free != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.free);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.free != 0 {
            os.write_uint32(1, self.free)?;
        }
        if self.limit != 0 {
            os.write_uint32(2, self.limit)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothConnectionsFreeResponse {
        BluetoothConnectionsFreeResponse::new()
    }

    fn clear(&mut self) {
        self.free = 0;
        self.limit = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothConnectionsFreeResponse {
        static instance: BluetoothConnectionsFreeResponse = BluetoothConnectionsFreeResponse {
            free: 0,
            limit: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothConnectionsFreeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothConnectionsFreeResponse").unwrap()).clone()
    }
}

impl Display for BluetoothConnectionsFreeResponse {
    fn fmt(&self, f: &mut Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothConnectionsFreeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EntityCategory)
pub enum EntityCategory {
    // @@protoc_insertion_point(enum_value:EntityCategory.ENTITY_CATEGORY_NONE)
    ENTITY_CATEGORY_NONE = 0,
    // @@protoc_insertion_point(enum_value:EntityCategory.ENTITY_CATEGORY_CONFIG)
    ENTITY_CATEGORY_CONFIG = 1,
    // @@protoc_insertion_point(enum_value:EntityCategory.ENTITY_CATEGORY_DIAGNOSTIC)
    ENTITY_CATEGORY_DIAGNOSTIC = 2,
}

impl ::protobuf::Enum for EntityCategory {
    const NAME: &'static str = "EntityCategory";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EntityCategory> {
        match value {
            0 => ::std::option::Option::Some(EntityCategory::ENTITY_CATEGORY_NONE),
            1 => ::std::option::Option::Some(EntityCategory::ENTITY_CATEGORY_CONFIG),
            2 => ::std::option::Option::Some(EntityCategory::ENTITY_CATEGORY_DIAGNOSTIC),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EntityCategory] = &[
        EntityCategory::ENTITY_CATEGORY_NONE,
        EntityCategory::ENTITY_CATEGORY_CONFIG,
        EntityCategory::ENTITY_CATEGORY_DIAGNOSTIC,
    ];
}

impl ::protobuf::EnumFull for EntityCategory {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EntityCategory").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for EntityCategory {
    fn default() -> Self {
        EntityCategory::ENTITY_CATEGORY_NONE
    }
}

impl EntityCategory {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EntityCategory>("EntityCategory")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:LegacyCoverState)
pub enum LegacyCoverState {
    // @@protoc_insertion_point(enum_value:LegacyCoverState.LEGACY_COVER_STATE_OPEN)
    LEGACY_COVER_STATE_OPEN = 0,
    // @@protoc_insertion_point(enum_value:LegacyCoverState.LEGACY_COVER_STATE_CLOSED)
    LEGACY_COVER_STATE_CLOSED = 1,
}

impl ::protobuf::Enum for LegacyCoverState {
    const NAME: &'static str = "LegacyCoverState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LegacyCoverState> {
        match value {
            0 => ::std::option::Option::Some(LegacyCoverState::LEGACY_COVER_STATE_OPEN),
            1 => ::std::option::Option::Some(LegacyCoverState::LEGACY_COVER_STATE_CLOSED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LegacyCoverState] = &[
        LegacyCoverState::LEGACY_COVER_STATE_OPEN,
        LegacyCoverState::LEGACY_COVER_STATE_CLOSED,
    ];
}

impl ::protobuf::EnumFull for LegacyCoverState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LegacyCoverState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for LegacyCoverState {
    fn default() -> Self {
        LegacyCoverState::LEGACY_COVER_STATE_OPEN
    }
}

impl LegacyCoverState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LegacyCoverState>("LegacyCoverState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:CoverOperation)
pub enum CoverOperation {
    // @@protoc_insertion_point(enum_value:CoverOperation.COVER_OPERATION_IDLE)
    COVER_OPERATION_IDLE = 0,
    // @@protoc_insertion_point(enum_value:CoverOperation.COVER_OPERATION_IS_OPENING)
    COVER_OPERATION_IS_OPENING = 1,
    // @@protoc_insertion_point(enum_value:CoverOperation.COVER_OPERATION_IS_CLOSING)
    COVER_OPERATION_IS_CLOSING = 2,
}

impl ::protobuf::Enum for CoverOperation {
    const NAME: &'static str = "CoverOperation";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CoverOperation> {
        match value {
            0 => ::std::option::Option::Some(CoverOperation::COVER_OPERATION_IDLE),
            1 => ::std::option::Option::Some(CoverOperation::COVER_OPERATION_IS_OPENING),
            2 => ::std::option::Option::Some(CoverOperation::COVER_OPERATION_IS_CLOSING),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CoverOperation] = &[
        CoverOperation::COVER_OPERATION_IDLE,
        CoverOperation::COVER_OPERATION_IS_OPENING,
        CoverOperation::COVER_OPERATION_IS_CLOSING,
    ];
}

impl ::protobuf::EnumFull for CoverOperation {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CoverOperation").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for CoverOperation {
    fn default() -> Self {
        CoverOperation::COVER_OPERATION_IDLE
    }
}

impl CoverOperation {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CoverOperation>("CoverOperation")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:LegacyCoverCommand)
pub enum LegacyCoverCommand {
    // @@protoc_insertion_point(enum_value:LegacyCoverCommand.LEGACY_COVER_COMMAND_OPEN)
    LEGACY_COVER_COMMAND_OPEN = 0,
    // @@protoc_insertion_point(enum_value:LegacyCoverCommand.LEGACY_COVER_COMMAND_CLOSE)
    LEGACY_COVER_COMMAND_CLOSE = 1,
    // @@protoc_insertion_point(enum_value:LegacyCoverCommand.LEGACY_COVER_COMMAND_STOP)
    LEGACY_COVER_COMMAND_STOP = 2,
}

impl ::protobuf::Enum for LegacyCoverCommand {
    const NAME: &'static str = "LegacyCoverCommand";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LegacyCoverCommand> {
        match value {
            0 => ::std::option::Option::Some(LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN),
            1 => ::std::option::Option::Some(LegacyCoverCommand::LEGACY_COVER_COMMAND_CLOSE),
            2 => ::std::option::Option::Some(LegacyCoverCommand::LEGACY_COVER_COMMAND_STOP),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LegacyCoverCommand] = &[
        LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN,
        LegacyCoverCommand::LEGACY_COVER_COMMAND_CLOSE,
        LegacyCoverCommand::LEGACY_COVER_COMMAND_STOP,
    ];
}

impl ::protobuf::EnumFull for LegacyCoverCommand {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LegacyCoverCommand").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for LegacyCoverCommand {
    fn default() -> Self {
        LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN
    }
}

impl LegacyCoverCommand {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LegacyCoverCommand>("LegacyCoverCommand")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:FanSpeed)
pub enum FanSpeed {
    // @@protoc_insertion_point(enum_value:FanSpeed.FAN_SPEED_LOW)
    FAN_SPEED_LOW = 0,
    // @@protoc_insertion_point(enum_value:FanSpeed.FAN_SPEED_MEDIUM)
    FAN_SPEED_MEDIUM = 1,
    // @@protoc_insertion_point(enum_value:FanSpeed.FAN_SPEED_HIGH)
    FAN_SPEED_HIGH = 2,
}

impl ::protobuf::Enum for FanSpeed {
    const NAME: &'static str = "FanSpeed";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FanSpeed> {
        match value {
            0 => ::std::option::Option::Some(FanSpeed::FAN_SPEED_LOW),
            1 => ::std::option::Option::Some(FanSpeed::FAN_SPEED_MEDIUM),
            2 => ::std::option::Option::Some(FanSpeed::FAN_SPEED_HIGH),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FanSpeed] = &[
        FanSpeed::FAN_SPEED_LOW,
        FanSpeed::FAN_SPEED_MEDIUM,
        FanSpeed::FAN_SPEED_HIGH,
    ];
}

impl ::protobuf::EnumFull for FanSpeed {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FanSpeed").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for FanSpeed {
    fn default() -> Self {
        FanSpeed::FAN_SPEED_LOW
    }
}

impl FanSpeed {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FanSpeed>("FanSpeed")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:FanDirection)
pub enum FanDirection {
    // @@protoc_insertion_point(enum_value:FanDirection.FAN_DIRECTION_FORWARD)
    FAN_DIRECTION_FORWARD = 0,
    // @@protoc_insertion_point(enum_value:FanDirection.FAN_DIRECTION_REVERSE)
    FAN_DIRECTION_REVERSE = 1,
}

impl ::protobuf::Enum for FanDirection {
    const NAME: &'static str = "FanDirection";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FanDirection> {
        match value {
            0 => ::std::option::Option::Some(FanDirection::FAN_DIRECTION_FORWARD),
            1 => ::std::option::Option::Some(FanDirection::FAN_DIRECTION_REVERSE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FanDirection] = &[
        FanDirection::FAN_DIRECTION_FORWARD,
        FanDirection::FAN_DIRECTION_REVERSE,
    ];
}

impl ::protobuf::EnumFull for FanDirection {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FanDirection").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for FanDirection {
    fn default() -> Self {
        FanDirection::FAN_DIRECTION_FORWARD
    }
}

impl FanDirection {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FanDirection>("FanDirection")
    }
}

///  ==================== LIGHT ====================
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ColorMode)
pub enum ColorMode {
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_UNKNOWN)
    COLOR_MODE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_ON_OFF)
    COLOR_MODE_ON_OFF = 1,
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_BRIGHTNESS)
    COLOR_MODE_BRIGHTNESS = 2,
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_WHITE)
    COLOR_MODE_WHITE = 7,
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_COLOR_TEMPERATURE)
    COLOR_MODE_COLOR_TEMPERATURE = 11,
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_COLD_WARM_WHITE)
    COLOR_MODE_COLD_WARM_WHITE = 19,
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_RGB)
    COLOR_MODE_RGB = 35,
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_RGB_WHITE)
    COLOR_MODE_RGB_WHITE = 39,
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_RGB_COLOR_TEMPERATURE)
    COLOR_MODE_RGB_COLOR_TEMPERATURE = 47,
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_RGB_COLD_WARM_WHITE)
    COLOR_MODE_RGB_COLD_WARM_WHITE = 51,
}

impl ::protobuf::Enum for ColorMode {
    const NAME: &'static str = "ColorMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ColorMode> {
        match value {
            0 => ::std::option::Option::Some(ColorMode::COLOR_MODE_UNKNOWN),
            1 => ::std::option::Option::Some(ColorMode::COLOR_MODE_ON_OFF),
            2 => ::std::option::Option::Some(ColorMode::COLOR_MODE_BRIGHTNESS),
            7 => ::std::option::Option::Some(ColorMode::COLOR_MODE_WHITE),
            11 => ::std::option::Option::Some(ColorMode::COLOR_MODE_COLOR_TEMPERATURE),
            19 => ::std::option::Option::Some(ColorMode::COLOR_MODE_COLD_WARM_WHITE),
            35 => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB),
            39 => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB_WHITE),
            47 => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB_COLOR_TEMPERATURE),
            51 => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB_COLD_WARM_WHITE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ColorMode] = &[
        ColorMode::COLOR_MODE_UNKNOWN,
        ColorMode::COLOR_MODE_ON_OFF,
        ColorMode::COLOR_MODE_BRIGHTNESS,
        ColorMode::COLOR_MODE_WHITE,
        ColorMode::COLOR_MODE_COLOR_TEMPERATURE,
        ColorMode::COLOR_MODE_COLD_WARM_WHITE,
        ColorMode::COLOR_MODE_RGB,
        ColorMode::COLOR_MODE_RGB_WHITE,
        ColorMode::COLOR_MODE_RGB_COLOR_TEMPERATURE,
        ColorMode::COLOR_MODE_RGB_COLD_WARM_WHITE,
    ];
}

impl ::protobuf::EnumFull for ColorMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ColorMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ColorMode::COLOR_MODE_UNKNOWN => 0,
            ColorMode::COLOR_MODE_ON_OFF => 1,
            ColorMode::COLOR_MODE_BRIGHTNESS => 2,
            ColorMode::COLOR_MODE_WHITE => 3,
            ColorMode::COLOR_MODE_COLOR_TEMPERATURE => 4,
            ColorMode::COLOR_MODE_COLD_WARM_WHITE => 5,
            ColorMode::COLOR_MODE_RGB => 6,
            ColorMode::COLOR_MODE_RGB_WHITE => 7,
            ColorMode::COLOR_MODE_RGB_COLOR_TEMPERATURE => 8,
            ColorMode::COLOR_MODE_RGB_COLD_WARM_WHITE => 9,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for ColorMode {
    fn default() -> Self {
        ColorMode::COLOR_MODE_UNKNOWN
    }
}

impl ColorMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ColorMode>("ColorMode")
    }
}

///  ==================== SENSOR ====================
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SensorStateClass)
pub enum SensorStateClass {
    // @@protoc_insertion_point(enum_value:SensorStateClass.STATE_CLASS_NONE)
    STATE_CLASS_NONE = 0,
    // @@protoc_insertion_point(enum_value:SensorStateClass.STATE_CLASS_MEASUREMENT)
    STATE_CLASS_MEASUREMENT = 1,
    // @@protoc_insertion_point(enum_value:SensorStateClass.STATE_CLASS_TOTAL_INCREASING)
    STATE_CLASS_TOTAL_INCREASING = 2,
    // @@protoc_insertion_point(enum_value:SensorStateClass.STATE_CLASS_TOTAL)
    STATE_CLASS_TOTAL = 3,
}

impl ::protobuf::Enum for SensorStateClass {
    const NAME: &'static str = "SensorStateClass";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SensorStateClass> {
        match value {
            0 => ::std::option::Option::Some(SensorStateClass::STATE_CLASS_NONE),
            1 => ::std::option::Option::Some(SensorStateClass::STATE_CLASS_MEASUREMENT),
            2 => ::std::option::Option::Some(SensorStateClass::STATE_CLASS_TOTAL_INCREASING),
            3 => ::std::option::Option::Some(SensorStateClass::STATE_CLASS_TOTAL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SensorStateClass] = &[
        SensorStateClass::STATE_CLASS_NONE,
        SensorStateClass::STATE_CLASS_MEASUREMENT,
        SensorStateClass::STATE_CLASS_TOTAL_INCREASING,
        SensorStateClass::STATE_CLASS_TOTAL,
    ];
}

impl ::protobuf::EnumFull for SensorStateClass {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SensorStateClass").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for SensorStateClass {
    fn default() -> Self {
        SensorStateClass::STATE_CLASS_NONE
    }
}

impl SensorStateClass {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SensorStateClass>("SensorStateClass")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SensorLastResetType)
pub enum SensorLastResetType {
    // @@protoc_insertion_point(enum_value:SensorLastResetType.LAST_RESET_NONE)
    LAST_RESET_NONE = 0,
    // @@protoc_insertion_point(enum_value:SensorLastResetType.LAST_RESET_NEVER)
    LAST_RESET_NEVER = 1,
    // @@protoc_insertion_point(enum_value:SensorLastResetType.LAST_RESET_AUTO)
    LAST_RESET_AUTO = 2,
}

impl ::protobuf::Enum for SensorLastResetType {
    const NAME: &'static str = "SensorLastResetType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SensorLastResetType> {
        match value {
            0 => ::std::option::Option::Some(SensorLastResetType::LAST_RESET_NONE),
            1 => ::std::option::Option::Some(SensorLastResetType::LAST_RESET_NEVER),
            2 => ::std::option::Option::Some(SensorLastResetType::LAST_RESET_AUTO),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SensorLastResetType] = &[
        SensorLastResetType::LAST_RESET_NONE,
        SensorLastResetType::LAST_RESET_NEVER,
        SensorLastResetType::LAST_RESET_AUTO,
    ];
}

impl ::protobuf::EnumFull for SensorLastResetType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SensorLastResetType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for SensorLastResetType {
    fn default() -> Self {
        SensorLastResetType::LAST_RESET_NONE
    }
}

impl SensorLastResetType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SensorLastResetType>("SensorLastResetType")
    }
}

///  ==================== SUBSCRIBE LOGS ====================
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:LogLevel)
pub enum LogLevel {
    // @@protoc_insertion_point(enum_value:LogLevel.LOG_LEVEL_NONE)
    LOG_LEVEL_NONE = 0,
    // @@protoc_insertion_point(enum_value:LogLevel.LOG_LEVEL_ERROR)
    LOG_LEVEL_ERROR = 1,
    // @@protoc_insertion_point(enum_value:LogLevel.LOG_LEVEL_WARN)
    LOG_LEVEL_WARN = 2,
    // @@protoc_insertion_point(enum_value:LogLevel.LOG_LEVEL_INFO)
    LOG_LEVEL_INFO = 3,
    // @@protoc_insertion_point(enum_value:LogLevel.LOG_LEVEL_CONFIG)
    LOG_LEVEL_CONFIG = 4,
    // @@protoc_insertion_point(enum_value:LogLevel.LOG_LEVEL_DEBUG)
    LOG_LEVEL_DEBUG = 5,
    // @@protoc_insertion_point(enum_value:LogLevel.LOG_LEVEL_VERBOSE)
    LOG_LEVEL_VERBOSE = 6,
    // @@protoc_insertion_point(enum_value:LogLevel.LOG_LEVEL_VERY_VERBOSE)
    LOG_LEVEL_VERY_VERBOSE = 7,
}

impl ::protobuf::Enum for LogLevel {
    const NAME: &'static str = "LogLevel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LogLevel> {
        match value {
            0 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_NONE),
            1 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_ERROR),
            2 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_WARN),
            3 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_INFO),
            4 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_CONFIG),
            5 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_DEBUG),
            6 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_VERBOSE),
            7 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_VERY_VERBOSE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LogLevel] = &[
        LogLevel::LOG_LEVEL_NONE,
        LogLevel::LOG_LEVEL_ERROR,
        LogLevel::LOG_LEVEL_WARN,
        LogLevel::LOG_LEVEL_INFO,
        LogLevel::LOG_LEVEL_CONFIG,
        LogLevel::LOG_LEVEL_DEBUG,
        LogLevel::LOG_LEVEL_VERBOSE,
        LogLevel::LOG_LEVEL_VERY_VERBOSE,
    ];
}

impl ::protobuf::EnumFull for LogLevel {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LogLevel").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for LogLevel {
    fn default() -> Self {
        LogLevel::LOG_LEVEL_NONE
    }
}

impl LogLevel {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LogLevel>("LogLevel")
    }
}

///  ==================== USER-DEFINES SERVICES ====================
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ServiceArgType)
pub enum ServiceArgType {
    // @@protoc_insertion_point(enum_value:ServiceArgType.SERVICE_ARG_TYPE_BOOL)
    SERVICE_ARG_TYPE_BOOL = 0,
    // @@protoc_insertion_point(enum_value:ServiceArgType.SERVICE_ARG_TYPE_INT)
    SERVICE_ARG_TYPE_INT = 1,
    // @@protoc_insertion_point(enum_value:ServiceArgType.SERVICE_ARG_TYPE_FLOAT)
    SERVICE_ARG_TYPE_FLOAT = 2,
    // @@protoc_insertion_point(enum_value:ServiceArgType.SERVICE_ARG_TYPE_STRING)
    SERVICE_ARG_TYPE_STRING = 3,
    // @@protoc_insertion_point(enum_value:ServiceArgType.SERVICE_ARG_TYPE_BOOL_ARRAY)
    SERVICE_ARG_TYPE_BOOL_ARRAY = 4,
    // @@protoc_insertion_point(enum_value:ServiceArgType.SERVICE_ARG_TYPE_INT_ARRAY)
    SERVICE_ARG_TYPE_INT_ARRAY = 5,
    // @@protoc_insertion_point(enum_value:ServiceArgType.SERVICE_ARG_TYPE_FLOAT_ARRAY)
    SERVICE_ARG_TYPE_FLOAT_ARRAY = 6,
    // @@protoc_insertion_point(enum_value:ServiceArgType.SERVICE_ARG_TYPE_STRING_ARRAY)
    SERVICE_ARG_TYPE_STRING_ARRAY = 7,
}

impl ::protobuf::Enum for ServiceArgType {
    const NAME: &'static str = "ServiceArgType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ServiceArgType> {
        match value {
            0 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_BOOL),
            1 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_INT),
            2 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_FLOAT),
            3 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_STRING),
            4 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_BOOL_ARRAY),
            5 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_INT_ARRAY),
            6 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_FLOAT_ARRAY),
            7 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_STRING_ARRAY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ServiceArgType] = &[
        ServiceArgType::SERVICE_ARG_TYPE_BOOL,
        ServiceArgType::SERVICE_ARG_TYPE_INT,
        ServiceArgType::SERVICE_ARG_TYPE_FLOAT,
        ServiceArgType::SERVICE_ARG_TYPE_STRING,
        ServiceArgType::SERVICE_ARG_TYPE_BOOL_ARRAY,
        ServiceArgType::SERVICE_ARG_TYPE_INT_ARRAY,
        ServiceArgType::SERVICE_ARG_TYPE_FLOAT_ARRAY,
        ServiceArgType::SERVICE_ARG_TYPE_STRING_ARRAY,
    ];
}

impl ::protobuf::EnumFull for ServiceArgType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ServiceArgType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for ServiceArgType {
    fn default() -> Self {
        ServiceArgType::SERVICE_ARG_TYPE_BOOL
    }
}

impl ServiceArgType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ServiceArgType>("ServiceArgType")
    }
}

///  ==================== CLIMATE ====================
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ClimateMode)
pub enum ClimateMode {
    // @@protoc_insertion_point(enum_value:ClimateMode.CLIMATE_MODE_OFF)
    CLIMATE_MODE_OFF = 0,
    // @@protoc_insertion_point(enum_value:ClimateMode.CLIMATE_MODE_HEAT_COOL)
    CLIMATE_MODE_HEAT_COOL = 1,
    // @@protoc_insertion_point(enum_value:ClimateMode.CLIMATE_MODE_COOL)
    CLIMATE_MODE_COOL = 2,
    // @@protoc_insertion_point(enum_value:ClimateMode.CLIMATE_MODE_HEAT)
    CLIMATE_MODE_HEAT = 3,
    // @@protoc_insertion_point(enum_value:ClimateMode.CLIMATE_MODE_FAN_ONLY)
    CLIMATE_MODE_FAN_ONLY = 4,
    // @@protoc_insertion_point(enum_value:ClimateMode.CLIMATE_MODE_DRY)
    CLIMATE_MODE_DRY = 5,
    // @@protoc_insertion_point(enum_value:ClimateMode.CLIMATE_MODE_AUTO)
    CLIMATE_MODE_AUTO = 6,
}

impl ::protobuf::Enum for ClimateMode {
    const NAME: &'static str = "ClimateMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimateMode> {
        match value {
            0 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_OFF),
            1 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_HEAT_COOL),
            2 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_COOL),
            3 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_HEAT),
            4 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_FAN_ONLY),
            5 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_DRY),
            6 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_AUTO),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ClimateMode] = &[
        ClimateMode::CLIMATE_MODE_OFF,
        ClimateMode::CLIMATE_MODE_HEAT_COOL,
        ClimateMode::CLIMATE_MODE_COOL,
        ClimateMode::CLIMATE_MODE_HEAT,
        ClimateMode::CLIMATE_MODE_FAN_ONLY,
        ClimateMode::CLIMATE_MODE_DRY,
        ClimateMode::CLIMATE_MODE_AUTO,
    ];
}

impl ::protobuf::EnumFull for ClimateMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ClimateMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for ClimateMode {
    fn default() -> Self {
        ClimateMode::CLIMATE_MODE_OFF
    }
}

impl ClimateMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClimateMode>("ClimateMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ClimateFanMode)
pub enum ClimateFanMode {
    // @@protoc_insertion_point(enum_value:ClimateFanMode.CLIMATE_FAN_ON)
    CLIMATE_FAN_ON = 0,
    // @@protoc_insertion_point(enum_value:ClimateFanMode.CLIMATE_FAN_OFF)
    CLIMATE_FAN_OFF = 1,
    // @@protoc_insertion_point(enum_value:ClimateFanMode.CLIMATE_FAN_AUTO)
    CLIMATE_FAN_AUTO = 2,
    // @@protoc_insertion_point(enum_value:ClimateFanMode.CLIMATE_FAN_LOW)
    CLIMATE_FAN_LOW = 3,
    // @@protoc_insertion_point(enum_value:ClimateFanMode.CLIMATE_FAN_MEDIUM)
    CLIMATE_FAN_MEDIUM = 4,
    // @@protoc_insertion_point(enum_value:ClimateFanMode.CLIMATE_FAN_HIGH)
    CLIMATE_FAN_HIGH = 5,
    // @@protoc_insertion_point(enum_value:ClimateFanMode.CLIMATE_FAN_MIDDLE)
    CLIMATE_FAN_MIDDLE = 6,
    // @@protoc_insertion_point(enum_value:ClimateFanMode.CLIMATE_FAN_FOCUS)
    CLIMATE_FAN_FOCUS = 7,
    // @@protoc_insertion_point(enum_value:ClimateFanMode.CLIMATE_FAN_DIFFUSE)
    CLIMATE_FAN_DIFFUSE = 8,
}

impl ::protobuf::Enum for ClimateFanMode {
    const NAME: &'static str = "ClimateFanMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimateFanMode> {
        match value {
            0 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_ON),
            1 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_OFF),
            2 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_AUTO),
            3 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_LOW),
            4 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_MEDIUM),
            5 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_HIGH),
            6 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_MIDDLE),
            7 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_FOCUS),
            8 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_DIFFUSE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ClimateFanMode] = &[
        ClimateFanMode::CLIMATE_FAN_ON,
        ClimateFanMode::CLIMATE_FAN_OFF,
        ClimateFanMode::CLIMATE_FAN_AUTO,
        ClimateFanMode::CLIMATE_FAN_LOW,
        ClimateFanMode::CLIMATE_FAN_MEDIUM,
        ClimateFanMode::CLIMATE_FAN_HIGH,
        ClimateFanMode::CLIMATE_FAN_MIDDLE,
        ClimateFanMode::CLIMATE_FAN_FOCUS,
        ClimateFanMode::CLIMATE_FAN_DIFFUSE,
    ];
}

impl ::protobuf::EnumFull for ClimateFanMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ClimateFanMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for ClimateFanMode {
    fn default() -> Self {
        ClimateFanMode::CLIMATE_FAN_ON
    }
}

impl ClimateFanMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClimateFanMode>("ClimateFanMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ClimateSwingMode)
pub enum ClimateSwingMode {
    // @@protoc_insertion_point(enum_value:ClimateSwingMode.CLIMATE_SWING_OFF)
    CLIMATE_SWING_OFF = 0,
    // @@protoc_insertion_point(enum_value:ClimateSwingMode.CLIMATE_SWING_BOTH)
    CLIMATE_SWING_BOTH = 1,
    // @@protoc_insertion_point(enum_value:ClimateSwingMode.CLIMATE_SWING_VERTICAL)
    CLIMATE_SWING_VERTICAL = 2,
    // @@protoc_insertion_point(enum_value:ClimateSwingMode.CLIMATE_SWING_HORIZONTAL)
    CLIMATE_SWING_HORIZONTAL = 3,
}

impl ::protobuf::Enum for ClimateSwingMode {
    const NAME: &'static str = "ClimateSwingMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimateSwingMode> {
        match value {
            0 => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_OFF),
            1 => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_BOTH),
            2 => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_VERTICAL),
            3 => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_HORIZONTAL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ClimateSwingMode] = &[
        ClimateSwingMode::CLIMATE_SWING_OFF,
        ClimateSwingMode::CLIMATE_SWING_BOTH,
        ClimateSwingMode::CLIMATE_SWING_VERTICAL,
        ClimateSwingMode::CLIMATE_SWING_HORIZONTAL,
    ];
}

impl ::protobuf::EnumFull for ClimateSwingMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ClimateSwingMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for ClimateSwingMode {
    fn default() -> Self {
        ClimateSwingMode::CLIMATE_SWING_OFF
    }
}

impl ClimateSwingMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClimateSwingMode>("ClimateSwingMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ClimateAction)
pub enum ClimateAction {
    // @@protoc_insertion_point(enum_value:ClimateAction.CLIMATE_ACTION_OFF)
    CLIMATE_ACTION_OFF = 0,
    // @@protoc_insertion_point(enum_value:ClimateAction.CLIMATE_ACTION_COOLING)
    CLIMATE_ACTION_COOLING = 2,
    // @@protoc_insertion_point(enum_value:ClimateAction.CLIMATE_ACTION_HEATING)
    CLIMATE_ACTION_HEATING = 3,
    // @@protoc_insertion_point(enum_value:ClimateAction.CLIMATE_ACTION_IDLE)
    CLIMATE_ACTION_IDLE = 4,
    // @@protoc_insertion_point(enum_value:ClimateAction.CLIMATE_ACTION_DRYING)
    CLIMATE_ACTION_DRYING = 5,
    // @@protoc_insertion_point(enum_value:ClimateAction.CLIMATE_ACTION_FAN)
    CLIMATE_ACTION_FAN = 6,
}

impl ::protobuf::Enum for ClimateAction {
    const NAME: &'static str = "ClimateAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimateAction> {
        match value {
            0 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_OFF),
            2 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_COOLING),
            3 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_HEATING),
            4 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_IDLE),
            5 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_DRYING),
            6 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_FAN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ClimateAction] = &[
        ClimateAction::CLIMATE_ACTION_OFF,
        ClimateAction::CLIMATE_ACTION_COOLING,
        ClimateAction::CLIMATE_ACTION_HEATING,
        ClimateAction::CLIMATE_ACTION_IDLE,
        ClimateAction::CLIMATE_ACTION_DRYING,
        ClimateAction::CLIMATE_ACTION_FAN,
    ];
}

impl ::protobuf::EnumFull for ClimateAction {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ClimateAction").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ClimateAction::CLIMATE_ACTION_OFF => 0,
            ClimateAction::CLIMATE_ACTION_COOLING => 1,
            ClimateAction::CLIMATE_ACTION_HEATING => 2,
            ClimateAction::CLIMATE_ACTION_IDLE => 3,
            ClimateAction::CLIMATE_ACTION_DRYING => 4,
            ClimateAction::CLIMATE_ACTION_FAN => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for ClimateAction {
    fn default() -> Self {
        ClimateAction::CLIMATE_ACTION_OFF
    }
}

impl ClimateAction {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClimateAction>("ClimateAction")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ClimatePreset)
pub enum ClimatePreset {
    // @@protoc_insertion_point(enum_value:ClimatePreset.CLIMATE_PRESET_NONE)
    CLIMATE_PRESET_NONE = 0,
    // @@protoc_insertion_point(enum_value:ClimatePreset.CLIMATE_PRESET_HOME)
    CLIMATE_PRESET_HOME = 1,
    // @@protoc_insertion_point(enum_value:ClimatePreset.CLIMATE_PRESET_AWAY)
    CLIMATE_PRESET_AWAY = 2,
    // @@protoc_insertion_point(enum_value:ClimatePreset.CLIMATE_PRESET_BOOST)
    CLIMATE_PRESET_BOOST = 3,
    // @@protoc_insertion_point(enum_value:ClimatePreset.CLIMATE_PRESET_COMFORT)
    CLIMATE_PRESET_COMFORT = 4,
    // @@protoc_insertion_point(enum_value:ClimatePreset.CLIMATE_PRESET_ECO)
    CLIMATE_PRESET_ECO = 5,
    // @@protoc_insertion_point(enum_value:ClimatePreset.CLIMATE_PRESET_SLEEP)
    CLIMATE_PRESET_SLEEP = 6,
    // @@protoc_insertion_point(enum_value:ClimatePreset.CLIMATE_PRESET_ACTIVITY)
    CLIMATE_PRESET_ACTIVITY = 7,
}

impl ::protobuf::Enum for ClimatePreset {
    const NAME: &'static str = "ClimatePreset";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimatePreset> {
        match value {
            0 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_NONE),
            1 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_HOME),
            2 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_AWAY),
            3 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_BOOST),
            4 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_COMFORT),
            5 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_ECO),
            6 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_SLEEP),
            7 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_ACTIVITY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ClimatePreset] = &[
        ClimatePreset::CLIMATE_PRESET_NONE,
        ClimatePreset::CLIMATE_PRESET_HOME,
        ClimatePreset::CLIMATE_PRESET_AWAY,
        ClimatePreset::CLIMATE_PRESET_BOOST,
        ClimatePreset::CLIMATE_PRESET_COMFORT,
        ClimatePreset::CLIMATE_PRESET_ECO,
        ClimatePreset::CLIMATE_PRESET_SLEEP,
        ClimatePreset::CLIMATE_PRESET_ACTIVITY,
    ];
}

impl ::protobuf::EnumFull for ClimatePreset {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ClimatePreset").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for ClimatePreset {
    fn default() -> Self {
        ClimatePreset::CLIMATE_PRESET_NONE
    }
}

impl ClimatePreset {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClimatePreset>("ClimatePreset")
    }
}

///  ==================== NUMBER ====================
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:NumberMode)
pub enum NumberMode {
    // @@protoc_insertion_point(enum_value:NumberMode.NUMBER_MODE_AUTO)
    NUMBER_MODE_AUTO = 0,
    // @@protoc_insertion_point(enum_value:NumberMode.NUMBER_MODE_BOX)
    NUMBER_MODE_BOX = 1,
    // @@protoc_insertion_point(enum_value:NumberMode.NUMBER_MODE_SLIDER)
    NUMBER_MODE_SLIDER = 2,
}

impl ::protobuf::Enum for NumberMode {
    const NAME: &'static str = "NumberMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NumberMode> {
        match value {
            0 => ::std::option::Option::Some(NumberMode::NUMBER_MODE_AUTO),
            1 => ::std::option::Option::Some(NumberMode::NUMBER_MODE_BOX),
            2 => ::std::option::Option::Some(NumberMode::NUMBER_MODE_SLIDER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [NumberMode] = &[
        NumberMode::NUMBER_MODE_AUTO,
        NumberMode::NUMBER_MODE_BOX,
        NumberMode::NUMBER_MODE_SLIDER,
    ];
}

impl ::protobuf::EnumFull for NumberMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("NumberMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for NumberMode {
    fn default() -> Self {
        NumberMode::NUMBER_MODE_AUTO
    }
}

impl NumberMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NumberMode>("NumberMode")
    }
}

///  ==================== LOCK ====================
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:LockState)
pub enum LockState {
    // @@protoc_insertion_point(enum_value:LockState.LOCK_STATE_NONE)
    LOCK_STATE_NONE = 0,
    // @@protoc_insertion_point(enum_value:LockState.LOCK_STATE_LOCKED)
    LOCK_STATE_LOCKED = 1,
    // @@protoc_insertion_point(enum_value:LockState.LOCK_STATE_UNLOCKED)
    LOCK_STATE_UNLOCKED = 2,
    // @@protoc_insertion_point(enum_value:LockState.LOCK_STATE_JAMMED)
    LOCK_STATE_JAMMED = 3,
    // @@protoc_insertion_point(enum_value:LockState.LOCK_STATE_LOCKING)
    LOCK_STATE_LOCKING = 4,
    // @@protoc_insertion_point(enum_value:LockState.LOCK_STATE_UNLOCKING)
    LOCK_STATE_UNLOCKING = 5,
}

impl ::protobuf::Enum for LockState {
    const NAME: &'static str = "LockState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LockState> {
        match value {
            0 => ::std::option::Option::Some(LockState::LOCK_STATE_NONE),
            1 => ::std::option::Option::Some(LockState::LOCK_STATE_LOCKED),
            2 => ::std::option::Option::Some(LockState::LOCK_STATE_UNLOCKED),
            3 => ::std::option::Option::Some(LockState::LOCK_STATE_JAMMED),
            4 => ::std::option::Option::Some(LockState::LOCK_STATE_LOCKING),
            5 => ::std::option::Option::Some(LockState::LOCK_STATE_UNLOCKING),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LockState] = &[
        LockState::LOCK_STATE_NONE,
        LockState::LOCK_STATE_LOCKED,
        LockState::LOCK_STATE_UNLOCKED,
        LockState::LOCK_STATE_JAMMED,
        LockState::LOCK_STATE_LOCKING,
        LockState::LOCK_STATE_UNLOCKING,
    ];
}

impl ::protobuf::EnumFull for LockState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LockState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for LockState {
    fn default() -> Self {
        LockState::LOCK_STATE_NONE
    }
}

impl LockState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LockState>("LockState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:LockCommand)
pub enum LockCommand {
    // @@protoc_insertion_point(enum_value:LockCommand.LOCK_UNLOCK)
    LOCK_UNLOCK = 0,
    // @@protoc_insertion_point(enum_value:LockCommand.LOCK_LOCK)
    LOCK_LOCK = 1,
    // @@protoc_insertion_point(enum_value:LockCommand.LOCK_OPEN)
    LOCK_OPEN = 2,
}

impl ::protobuf::Enum for LockCommand {
    const NAME: &'static str = "LockCommand";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LockCommand> {
        match value {
            0 => ::std::option::Option::Some(LockCommand::LOCK_UNLOCK),
            1 => ::std::option::Option::Some(LockCommand::LOCK_LOCK),
            2 => ::std::option::Option::Some(LockCommand::LOCK_OPEN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LockCommand] = &[
        LockCommand::LOCK_UNLOCK,
        LockCommand::LOCK_LOCK,
        LockCommand::LOCK_OPEN,
    ];
}

impl ::protobuf::EnumFull for LockCommand {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LockCommand").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for LockCommand {
    fn default() -> Self {
        LockCommand::LOCK_UNLOCK
    }
}

impl LockCommand {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LockCommand>("LockCommand")
    }
}

///  ==================== MEDIA PLAYER ====================
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MediaPlayerState)
pub enum MediaPlayerState {
    // @@protoc_insertion_point(enum_value:MediaPlayerState.MEDIA_PLAYER_STATE_NONE)
    MEDIA_PLAYER_STATE_NONE = 0,
    // @@protoc_insertion_point(enum_value:MediaPlayerState.MEDIA_PLAYER_STATE_IDLE)
    MEDIA_PLAYER_STATE_IDLE = 1,
    // @@protoc_insertion_point(enum_value:MediaPlayerState.MEDIA_PLAYER_STATE_PLAYING)
    MEDIA_PLAYER_STATE_PLAYING = 2,
    // @@protoc_insertion_point(enum_value:MediaPlayerState.MEDIA_PLAYER_STATE_PAUSED)
    MEDIA_PLAYER_STATE_PAUSED = 3,
}

impl ::protobuf::Enum for MediaPlayerState {
    const NAME: &'static str = "MediaPlayerState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MediaPlayerState> {
        match value {
            0 => ::std::option::Option::Some(MediaPlayerState::MEDIA_PLAYER_STATE_NONE),
            1 => ::std::option::Option::Some(MediaPlayerState::MEDIA_PLAYER_STATE_IDLE),
            2 => ::std::option::Option::Some(MediaPlayerState::MEDIA_PLAYER_STATE_PLAYING),
            3 => ::std::option::Option::Some(MediaPlayerState::MEDIA_PLAYER_STATE_PAUSED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MediaPlayerState] = &[
        MediaPlayerState::MEDIA_PLAYER_STATE_NONE,
        MediaPlayerState::MEDIA_PLAYER_STATE_IDLE,
        MediaPlayerState::MEDIA_PLAYER_STATE_PLAYING,
        MediaPlayerState::MEDIA_PLAYER_STATE_PAUSED,
    ];
}

impl ::protobuf::EnumFull for MediaPlayerState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MediaPlayerState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for MediaPlayerState {
    fn default() -> Self {
        MediaPlayerState::MEDIA_PLAYER_STATE_NONE
    }
}

impl MediaPlayerState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MediaPlayerState>("MediaPlayerState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MediaPlayerCommand)
pub enum MediaPlayerCommand {
    // @@protoc_insertion_point(enum_value:MediaPlayerCommand.MEDIA_PLAYER_COMMAND_PLAY)
    MEDIA_PLAYER_COMMAND_PLAY = 0,
    // @@protoc_insertion_point(enum_value:MediaPlayerCommand.MEDIA_PLAYER_COMMAND_PAUSE)
    MEDIA_PLAYER_COMMAND_PAUSE = 1,
    // @@protoc_insertion_point(enum_value:MediaPlayerCommand.MEDIA_PLAYER_COMMAND_STOP)
    MEDIA_PLAYER_COMMAND_STOP = 2,
    // @@protoc_insertion_point(enum_value:MediaPlayerCommand.MEDIA_PLAYER_COMMAND_MUTE)
    MEDIA_PLAYER_COMMAND_MUTE = 3,
    // @@protoc_insertion_point(enum_value:MediaPlayerCommand.MEDIA_PLAYER_COMMAND_UNMUTE)
    MEDIA_PLAYER_COMMAND_UNMUTE = 4,
}

impl ::protobuf::Enum for MediaPlayerCommand {
    const NAME: &'static str = "MediaPlayerCommand";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MediaPlayerCommand> {
        match value {
            0 => ::std::option::Option::Some(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_PLAY),
            1 => ::std::option::Option::Some(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_PAUSE),
            2 => ::std::option::Option::Some(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_STOP),
            3 => ::std::option::Option::Some(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_MUTE),
            4 => ::std::option::Option::Some(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_UNMUTE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MediaPlayerCommand] = &[
        MediaPlayerCommand::MEDIA_PLAYER_COMMAND_PLAY,
        MediaPlayerCommand::MEDIA_PLAYER_COMMAND_PAUSE,
        MediaPlayerCommand::MEDIA_PLAYER_COMMAND_STOP,
        MediaPlayerCommand::MEDIA_PLAYER_COMMAND_MUTE,
        MediaPlayerCommand::MEDIA_PLAYER_COMMAND_UNMUTE,
    ];
}

impl ::protobuf::EnumFull for MediaPlayerCommand {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MediaPlayerCommand").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for MediaPlayerCommand {
    fn default() -> Self {
        MediaPlayerCommand::MEDIA_PLAYER_COMMAND_PLAY
    }
}

impl MediaPlayerCommand {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MediaPlayerCommand>("MediaPlayerCommand")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:BluetoothDeviceRequestType)
pub enum BluetoothDeviceRequestType {
    // @@protoc_insertion_point(enum_value:BluetoothDeviceRequestType.BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT)
    BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT = 0,
    // @@protoc_insertion_point(enum_value:BluetoothDeviceRequestType.BLUETOOTH_DEVICE_REQUEST_TYPE_DISCONNECT)
    BLUETOOTH_DEVICE_REQUEST_TYPE_DISCONNECT = 1,
    // @@protoc_insertion_point(enum_value:BluetoothDeviceRequestType.BLUETOOTH_DEVICE_REQUEST_TYPE_PAIR)
    BLUETOOTH_DEVICE_REQUEST_TYPE_PAIR = 2,
    // @@protoc_insertion_point(enum_value:BluetoothDeviceRequestType.BLUETOOTH_DEVICE_REQUEST_TYPE_UNPAIR)
    BLUETOOTH_DEVICE_REQUEST_TYPE_UNPAIR = 3,
}

impl ::protobuf::Enum for BluetoothDeviceRequestType {
    const NAME: &'static str = "BluetoothDeviceRequestType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BluetoothDeviceRequestType> {
        match value {
            0 => ::std::option::Option::Some(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT),
            1 => ::std::option::Option::Some(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_DISCONNECT),
            2 => ::std::option::Option::Some(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_PAIR),
            3 => ::std::option::Option::Some(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_UNPAIR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [BluetoothDeviceRequestType] = &[
        BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT,
        BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_DISCONNECT,
        BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_PAIR,
        BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_UNPAIR,
    ];
}

impl ::protobuf::EnumFull for BluetoothDeviceRequestType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("BluetoothDeviceRequestType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl Default for BluetoothDeviceRequestType {
    fn default() -> Self {
        BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT
    }
}

impl BluetoothDeviceRequestType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BluetoothDeviceRequestType>("BluetoothDeviceRequestType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tapi.proto\x1a\x11api_options.proto\"\x92\x01\n\x0cHelloRequest\x12\
    \x1f\n\x0bclient_info\x18\x01\x20\x01(\tR\nclientInfo\x12*\n\x11api_vers\
    ion_major\x18\x02\x20\x01(\rR\x0fapiVersionMajor\x12*\n\x11api_version_m\
    inor\x18\x03\x20\x01(\rR\x0fapiVersionMinor:\t\x80A\x01\xe0@\x01\xe8@\
    \x02\"\xa7\x01\n\rHelloResponse\x12*\n\x11api_version_major\x18\x01\x20\
    \x01(\rR\x0fapiVersionMajor\x12*\n\x11api_version_minor\x18\x02\x20\x01(\
    \rR\x0fapiVersionMinor\x12\x1f\n\x0bserver_info\x18\x03\x20\x01(\tR\nser\
    verInfo\x12\x12\n\x04name\x18\x04\x20\x01(\tR\x04name:\t\x80A\x01\xe0@\
    \x02\xe8@\x01\"7\n\x0eConnectRequest\x12\x1a\n\x08password\x18\x01\x20\
    \x01(\tR\x08password:\t\x80A\x01\xe0@\x03\xe8@\x02\"G\n\x0fConnectRespon\
    se\x12)\n\x10invalid_password\x18\x01\x20\x01(\x08R\x0finvalidPassword:\
    \t\x80A\x01\xe0@\x04\xe8@\x01\"\x1e\n\x11DisconnectRequest:\t\x80A\x01\
    \xe0@\x05\xe8@\0\"\x1f\n\x12DisconnectResponse:\t\x80A\x01\xe0@\x06\xe8@\
    \0\"\x15\n\x0bPingRequest:\x06\xe0@\x07\xe8@\0\"\x16\n\x0cPingResponse:\
    \x06\xe0@\x08\xe8@\0\"\x1b\n\x11DeviceInfoRequest:\x06\xe0@\t\xe8@\x02\"\
    \xb1\x03\n\x12DeviceInfoResponse\x12#\n\ruses_password\x18\x01\x20\x01(\
    \x08R\x0cusesPassword\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\
    \x1f\n\x0bmac_address\x18\x03\x20\x01(\tR\nmacAddress\x12'\n\x0fesphome_\
    version\x18\x04\x20\x01(\tR\x0eesphomeVersion\x12)\n\x10compilation_time\
    \x18\x05\x20\x01(\tR\x0fcompilationTime\x12\x14\n\x05model\x18\x06\x20\
    \x01(\tR\x05model\x12$\n\x0ehas_deep_sleep\x18\x07\x20\x01(\x08R\x0chasD\
    eepSleep\x12!\n\x0cproject_name\x18\x08\x20\x01(\tR\x0bprojectName\x12'\
    \n\x0fproject_version\x18\t\x20\x01(\tR\x0eprojectVersion\x12%\n\x0ewebs\
    erver_port\x18\n\x20\x01(\rR\rwebserverPort\x126\n\x17bluetooth_proxy_ve\
    rsion\x18\x0b\x20\x01(\rR\x15bluetoothProxyVersion:\x06\xe0@\n\xe8@\x01\
    \"\x1d\n\x13ListEntitiesRequest:\x06\xe0@\x0b\xe8@\x02\"%\n\x18ListEntit\
    iesDoneResponse:\t\x80A\x01\xe0@\x13\xe8@\x01\"\x20\n\x16SubscribeStates\
    Request:\x06\xe0@\x14\xe8@\x02\"\xf6\x02\n\x20ListEntitiesBinarySensorRe\
    sponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\
    \x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\x20\x01(\
    \tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\x12!\n\
    \x0cdevice_class\x18\x05\x20\x01(\tR\x0bdeviceClass\x125\n\x17is_status_\
    binary_sensor\x18\x06\x20\x01(\x08R\x14isStatusBinarySensor\x12.\n\x13di\
    sabled_by_default\x18\x07\x20\x01(\x08R\x11disabledByDefault\x12\x12\n\
    \x04icon\x18\x08\x20\x01(\tR\x04icon\x128\n\x0fentity_category\x18\t\x20\
    \x01(\x0e2\x0f.EntityCategoryR\x0eentityCategory:\x1a\xf2@\x11USE_BINARY\
    _SENSOR\xe0@\x0c\xe8@\x01\"\x87\x01\n\x19BinarySensorStateResponse\x12\
    \x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\x02\
    \x20\x01(\x08R\x05state\x12#\n\rmissing_state\x18\x03\x20\x01(\x08R\x0cm\
    issingState:\x1d\x80A\x01\xf2@\x11USE_BINARY_SENSOR\xe0@\x15\xe8@\x01\"\
    \xa7\x03\n\x19ListEntitiesCoverResponse\x12\x1b\n\tobject_id\x18\x01\x20\
    \x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\
    \x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\
    \x20\x01(\tR\x08uniqueId\x12#\n\rassumed_state\x18\x05\x20\x01(\x08R\x0c\
    assumedState\x12+\n\x11supports_position\x18\x06\x20\x01(\x08R\x10suppor\
    tsPosition\x12#\n\rsupports_tilt\x18\x07\x20\x01(\x08R\x0csupportsTilt\
    \x12!\n\x0cdevice_class\x18\x08\x20\x01(\tR\x0bdeviceClass\x12.\n\x13dis\
    abled_by_default\x18\t\x20\x01(\x08R\x11disabledByDefault\x12\x12\n\x04i\
    con\x18\n\x20\x01(\tR\x04icon\x128\n\x0fentity_category\x18\x0b\x20\x01(\
    \x0e2\x0f.EntityCategoryR\x0eentityCategory:\x12\xf2@\tUSE_COVER\xe0@\r\
    \xe8@\x01\"\xe1\x01\n\x12CoverStateResponse\x12\x10\n\x03key\x18\x01\x20\
    \x01(\x07R\x03key\x124\n\x0clegacy_state\x18\x02\x20\x01(\x0e2\x11.Legac\
    yCoverStateR\x0blegacyState\x12\x1a\n\x08position\x18\x03\x20\x01(\x02R\
    \x08position\x12\x12\n\x04tilt\x18\x04\x20\x01(\x02R\x04tilt\x12<\n\x11c\
    urrent_operation\x18\x05\x20\x01(\x0e2\x0f.CoverOperationR\x10currentOpe\
    ration:\x15\x80A\x01\xf2@\tUSE_COVER\xe0@\x16\xe8@\x01\"\xaa\x02\n\x13Co\
    verCommandRequest\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12,\n\
    \x12has_legacy_command\x18\x02\x20\x01(\x08R\x10hasLegacyCommand\x12:\n\
    \x0elegacy_command\x18\x03\x20\x01(\x0e2\x13.LegacyCoverCommandR\rlegacy\
    Command\x12!\n\x0chas_position\x18\x04\x20\x01(\x08R\x0bhasPosition\x12\
    \x1a\n\x08position\x18\x05\x20\x01(\x02R\x08position\x12\x19\n\x08has_ti\
    lt\x18\x06\x20\x01(\x08R\x07hasTilt\x12\x12\n\x04tilt\x18\x07\x20\x01(\
    \x02R\x04tilt\x12\x12\n\x04stop\x18\x08\x20\x01(\x08R\x04stop:\x15\x80A\
    \x01\xf2@\tUSE_COVER\xe0@\x1e\xe8@\x02\"\xc6\x03\n\x17ListEntitiesFanRes\
    ponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\x03\
    key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\x20\x01(\tR\
    \x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\x121\n\x14\
    supports_oscillation\x18\x05\x20\x01(\x08R\x13supportsOscillation\x12%\n\
    \x0esupports_speed\x18\x06\x20\x01(\x08R\rsupportsSpeed\x12-\n\x12suppor\
    ts_direction\x18\x07\x20\x01(\x08R\x11supportsDirection\x122\n\x15suppor\
    ted_speed_count\x18\x08\x20\x01(\x05R\x13supportedSpeedCount\x12.\n\x13d\
    isabled_by_default\x18\t\x20\x01(\x08R\x11disabledByDefault\x12\x12\n\
    \x04icon\x18\n\x20\x01(\tR\x04icon\x128\n\x0fentity_category\x18\x0b\x20\
    \x01(\x0e2\x0f.EntityCategoryR\x0eentityCategory:\x10\xf2@\x07USE_FAN\
    \xe0@\x0e\xe8@\x01\"\xe4\x01\n\x10FanStateResponse\x12\x10\n\x03key\x18\
    \x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\x02\x20\x01(\x08R\x05st\
    ate\x12\x20\n\x0boscillating\x18\x03\x20\x01(\x08R\x0boscillating\x12#\n\
    \x05speed\x18\x04\x20\x01(\x0e2\t.FanSpeedR\x05speedB\x02\x18\x01\x12+\n\
    \tdirection\x18\x05\x20\x01(\x0e2\r.FanDirectionR\tdirection\x12\x1f\n\
    \x0bspeed_level\x18\x06\x20\x01(\x05R\nspeedLevel:\x13\x80A\x01\xf2@\x07\
    USE_FAN\xe0@\x17\xe8@\x01\"\x99\x03\n\x11FanCommandRequest\x12\x10\n\x03\
    key\x18\x01\x20\x01(\x07R\x03key\x12\x1b\n\thas_state\x18\x02\x20\x01(\
    \x08R\x08hasState\x12\x14\n\x05state\x18\x03\x20\x01(\x08R\x05state\x12\
    \x1f\n\thas_speed\x18\x04\x20\x01(\x08R\x08hasSpeedB\x02\x18\x01\x12#\n\
    \x05speed\x18\x05\x20\x01(\x0e2\t.FanSpeedR\x05speedB\x02\x18\x01\x12'\n\
    \x0fhas_oscillating\x18\x06\x20\x01(\x08R\x0ehasOscillating\x12\x20\n\
    \x0boscillating\x18\x07\x20\x01(\x08R\x0boscillating\x12#\n\rhas_directi\
    on\x18\x08\x20\x01(\x08R\x0chasDirection\x12+\n\tdirection\x18\t\x20\x01\
    (\x0e2\r.FanDirectionR\tdirection\x12&\n\x0fhas_speed_level\x18\n\x20\
    \x01(\x08R\rhasSpeedLevel\x12\x1f\n\x0bspeed_level\x18\x0b\x20\x01(\x05R\
    \nspeedLevel:\x13\x80A\x01\xf2@\x07USE_FAN\xe0@\x1f\xe8@\x02\"\xad\x05\n\
    \x19ListEntitiesLightResponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\
    \x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04\
    name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\t\
    R\x08uniqueId\x12>\n\x15supported_color_modes\x18\x0c\x20\x03(\x0e2\n.Co\
    lorModeR\x13supportedColorModes\x12@\n\x1alegacy_supports_brightness\x18\
    \x05\x20\x01(\x08R\x18legacySupportsBrightnessB\x02\x18\x01\x122\n\x13le\
    gacy_supports_rgb\x18\x06\x20\x01(\x08R\x11legacySupportsRgbB\x02\x18\
    \x01\x12A\n\x1blegacy_supports_white_value\x18\x07\x20\x01(\x08R\x18lega\
    cySupportsWhiteValueB\x02\x18\x01\x12M\n!legacy_supports_color_temperatu\
    re\x18\x08\x20\x01(\x08R\x1elegacySupportsColorTemperatureB\x02\x18\x01\
    \x12\x1d\n\nmin_mireds\x18\t\x20\x01(\x02R\tminMireds\x12\x1d\n\nmax_mir\
    eds\x18\n\x20\x01(\x02R\tmaxMireds\x12\x18\n\x07effects\x18\x0b\x20\x03(\
    \tR\x07effects\x12.\n\x13disabled_by_default\x18\r\x20\x01(\x08R\x11disa\
    bledByDefault\x12\x12\n\x04icon\x18\x0e\x20\x01(\tR\x04icon\x128\n\x0fen\
    tity_category\x18\x0f\x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCategor\
    y:\x12\xf2@\tUSE_LIGHT\xe0@\x0f\xe8@\x01\"\x9e\x03\n\x12LightStateRespon\
    se\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\
    \x02\x20\x01(\x08R\x05state\x12\x1e\n\nbrightness\x18\x03\x20\x01(\x02R\
    \nbrightness\x12)\n\ncolor_mode\x18\x0b\x20\x01(\x0e2\n.ColorModeR\tcolo\
    rMode\x12)\n\x10color_brightness\x18\n\x20\x01(\x02R\x0fcolorBrightness\
    \x12\x10\n\x03red\x18\x04\x20\x01(\x02R\x03red\x12\x14\n\x05green\x18\
    \x05\x20\x01(\x02R\x05green\x12\x12\n\x04blue\x18\x06\x20\x01(\x02R\x04b\
    lue\x12\x14\n\x05white\x18\x07\x20\x01(\x02R\x05white\x12+\n\x11color_te\
    mperature\x18\x08\x20\x01(\x02R\x10colorTemperature\x12\x1d\n\ncold_whit\
    e\x18\x0c\x20\x01(\x02R\tcoldWhite\x12\x1d\n\nwarm_white\x18\r\x20\x01(\
    \x02R\twarmWhite\x12\x16\n\x06effect\x18\t\x20\x01(\tR\x06effect:\x15\
    \x80A\x01\xf2@\tUSE_LIGHT\xe0@\x18\xe8@\x01\"\xbe\x07\n\x13LightCommandR\
    equest\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x1b\n\thas_stat\
    e\x18\x02\x20\x01(\x08R\x08hasState\x12\x14\n\x05state\x18\x03\x20\x01(\
    \x08R\x05state\x12%\n\x0ehas_brightness\x18\x04\x20\x01(\x08R\rhasBright\
    ness\x12\x1e\n\nbrightness\x18\x05\x20\x01(\x02R\nbrightness\x12$\n\x0eh\
    as_color_mode\x18\x16\x20\x01(\x08R\x0chasColorMode\x12)\n\ncolor_mode\
    \x18\x17\x20\x01(\x0e2\n.ColorModeR\tcolorMode\x120\n\x14has_color_brigh\
    tness\x18\x14\x20\x01(\x08R\x12hasColorBrightness\x12)\n\x10color_bright\
    ness\x18\x15\x20\x01(\x02R\x0fcolorBrightness\x12\x17\n\x07has_rgb\x18\
    \x06\x20\x01(\x08R\x06hasRgb\x12\x10\n\x03red\x18\x07\x20\x01(\x02R\x03r\
    ed\x12\x14\n\x05green\x18\x08\x20\x01(\x02R\x05green\x12\x12\n\x04blue\
    \x18\t\x20\x01(\x02R\x04blue\x12\x1b\n\thas_white\x18\n\x20\x01(\x08R\
    \x08hasWhite\x12\x14\n\x05white\x18\x0b\x20\x01(\x02R\x05white\x122\n\
    \x15has_color_temperature\x18\x0c\x20\x01(\x08R\x13hasColorTemperature\
    \x12+\n\x11color_temperature\x18\r\x20\x01(\x02R\x10colorTemperature\x12\
    $\n\x0ehas_cold_white\x18\x18\x20\x01(\x08R\x0chasColdWhite\x12\x1d\n\nc\
    old_white\x18\x19\x20\x01(\x02R\tcoldWhite\x12$\n\x0ehas_warm_white\x18\
    \x1a\x20\x01(\x08R\x0chasWarmWhite\x12\x1d\n\nwarm_white\x18\x1b\x20\x01\
    (\x02R\twarmWhite\x122\n\x15has_transition_length\x18\x0e\x20\x01(\x08R\
    \x13hasTransitionLength\x12+\n\x11transition_length\x18\x0f\x20\x01(\rR\
    \x10transitionLength\x12(\n\x10has_flash_length\x18\x10\x20\x01(\x08R\
    \x0ehasFlashLength\x12!\n\x0cflash_length\x18\x11\x20\x01(\rR\x0bflashLe\
    ngth\x12\x1d\n\nhas_effect\x18\x12\x20\x01(\x08R\thasEffect\x12\x16\n\
    \x06effect\x18\x13\x20\x01(\tR\x06effect:\x15\x80A\x01\xf2@\tUSE_LIGHT\
    \xe0@\x20\xe8@\x02\"\xb1\x04\n\x1aListEntitiesSensorResponse\x12\x1b\n\t\
    object_id\x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\x20\
    \x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\
    \n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\x12\x12\n\x04icon\x18\x05\
    \x20\x01(\tR\x04icon\x12.\n\x13unit_of_measurement\x18\x06\x20\x01(\tR\
    \x11unitOfMeasurement\x12+\n\x11accuracy_decimals\x18\x07\x20\x01(\x05R\
    \x10accuracyDecimals\x12!\n\x0cforce_update\x18\x08\x20\x01(\x08R\x0bfor\
    ceUpdate\x12!\n\x0cdevice_class\x18\t\x20\x01(\tR\x0bdeviceClass\x122\n\
    \x0bstate_class\x18\n\x20\x01(\x0e2\x11.SensorStateClassR\nstateClass\
    \x12I\n\x16legacy_last_reset_type\x18\x0b\x20\x01(\x0e2\x14.SensorLastRe\
    setTypeR\x13legacyLastResetType\x12.\n\x13disabled_by_default\x18\x0c\
    \x20\x01(\x08R\x11disabledByDefault\x128\n\x0fentity_category\x18\r\x20\
    \x01(\x0e2\x0f.EntityCategoryR\x0eentityCategory:\x13\xf2@\nUSE_SENSOR\
    \xe0@\x10\xe8@\x01\"z\n\x13SensorStateResponse\x12\x10\n\x03key\x18\x01\
    \x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\x02\x20\x01(\x02R\x05state\
    \x12#\n\rmissing_state\x18\x03\x20\x01(\x08R\x0cmissingState:\x16\x80A\
    \x01\xf2@\nUSE_SENSOR\xe0@\x19\xe8@\x01\"\xd7\x02\n\x1aListEntitiesSwitc\
    hResponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\
    \x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\x20\x01(\
    \tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\x12\x12\
    \n\x04icon\x18\x05\x20\x01(\tR\x04icon\x12#\n\rassumed_state\x18\x06\x20\
    \x01(\x08R\x0cassumedState\x12.\n\x13disabled_by_default\x18\x07\x20\x01\
    (\x08R\x11disabledByDefault\x128\n\x0fentity_category\x18\x08\x20\x01(\
    \x0e2\x0f.EntityCategoryR\x0eentityCategory\x12!\n\x0cdevice_class\x18\t\
    \x20\x01(\tR\x0bdeviceClass:\x13\xf2@\nUSE_SWITCH\xe0@\x11\xe8@\x01\"U\n\
    \x13SwitchStateResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\
    \x12\x14\n\x05state\x18\x02\x20\x01(\x08R\x05state:\x16\x80A\x01\xf2@\nU\
    SE_SWITCH\xe0@\x1a\xe8@\x01\"V\n\x14SwitchCommandRequest\x12\x10\n\x03ke\
    y\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\x02\x20\x01(\x08R\
    \x05state:\x16\x80A\x01\xf2@\nUSE_SWITCH\xe0@!\xe8@\x02\"\x98\x02\n\x1eL\
    istEntitiesTextSensorResponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\
    \x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04\
    name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\t\
    R\x08uniqueId\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\x04icon\x12.\n\x13di\
    sabled_by_default\x18\x06\x20\x01(\x08R\x11disabledByDefault\x128\n\x0fe\
    ntity_category\x18\x07\x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCatego\
    ry:\x18\xf2@\x0fUSE_TEXT_SENSOR\xe0@\x12\xe8@\x01\"\x83\x01\n\x17TextSen\
    sorStateResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\
    \x05state\x18\x02\x20\x01(\tR\x05state\x12#\n\rmissing_state\x18\x03\x20\
    \x01(\x08R\x0cmissingState:\x1b\x80A\x01\xf2@\x0fUSE_TEXT_SENSOR\xe0@\
    \x1b\xe8@\x01\"`\n\x14SubscribeLogsRequest\x12\x1f\n\x05level\x18\x01\
    \x20\x01(\x0e2\t.LogLevelR\x05level\x12\x1f\n\x0bdump_config\x18\x02\x20\
    \x01(\x08R\ndumpConfig:\x06\xe0@\x1c\xe8@\x02\"\x81\x01\n\x15SubscribeLo\
    gsResponse\x12\x1f\n\x05level\x18\x01\x20\x01(\x0e2\t.LogLevelR\x05level\
    \x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07message\x12\x1f\n\x0bsend_f\
    ailed\x18\x04\x20\x01(\x08R\nsendFailed:\x0c\xf8@\0\x80A\0\xe0@\x1d\xe8@\
    \x01\"/\n%SubscribeHomeassistantServicesRequest:\x06\xe0@\"\xe8@\x02\"A\
    \n\x17HomeassistantServiceMap\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03ke\
    y\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\x83\x02\n\x1cHomeass\
    istantServiceResponse\x12\x18\n\x07service\x18\x01\x20\x01(\tR\x07servic\
    e\x12,\n\x04data\x18\x02\x20\x03(\x0b2\x18.HomeassistantServiceMapR\x04d\
    ata\x12=\n\rdata_template\x18\x03\x20\x03(\x0b2\x18.HomeassistantService\
    MapR\x0cdataTemplate\x126\n\tvariables\x18\x04\x20\x03(\x0b2\x18.Homeass\
    istantServiceMapR\tvariables\x12\x19\n\x08is_event\x18\x05\x20\x01(\x08R\
    \x07isEvent:\t\x80A\x01\xe0@#\xe8@\x01\"-\n#SubscribeHomeAssistantStates\
    Request:\x06\xe0@&\xe8@\x02\"h\n#SubscribeHomeAssistantStateResponse\x12\
    \x1b\n\tentity_id\x18\x01\x20\x01(\tR\x08entityId\x12\x1c\n\tattribute\
    \x18\x02\x20\x01(\tR\tattribute:\x06\xe0@'\xe8@\x01\"x\n\x1aHomeAssistan\
    tStateResponse\x12\x1b\n\tentity_id\x18\x01\x20\x01(\tR\x08entityId\x12\
    \x14\n\x05state\x18\x02\x20\x01(\tR\x05state\x12\x1c\n\tattribute\x18\
    \x03\x20\x01(\tR\tattribute:\t\x80A\x01\xe0@(\xe8@\x02\"\x18\n\x0eGetTim\
    eRequest:\x06\xe0@$\xe8@\0\"A\n\x0fGetTimeResponse\x12#\n\repoch_seconds\
    \x18\x01\x20\x01(\x07R\x0cepochSeconds:\t\x80A\x01\xe0@%\xe8@\0\"W\n\x1c\
    ListEntitiesServicesArgument\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04na\
    me\x12#\n\x04type\x18\x02\x20\x01(\x0e2\x0f.ServiceArgTypeR\x04type\"\
    \x7f\n\x1cListEntitiesServicesResponse\x12\x12\n\x04name\x18\x01\x20\x01\
    (\tR\x04name\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x121\n\x04arg\
    s\x18\x03\x20\x03(\x0b2\x1d.ListEntitiesServicesArgumentR\x04args:\x06\
    \xe0@)\xe8@\x01\"\x9b\x02\n\x16ExecuteServiceArgument\x12\x13\n\x05bool_\
    \x18\x01\x20\x01(\x08R\x04bool\x12\x1d\n\nlegacy_int\x18\x02\x20\x01(\
    \x05R\tlegacyInt\x12\x15\n\x06float_\x18\x03\x20\x01(\x02R\x05float\x12\
    \x17\n\x07string_\x18\x04\x20\x01(\tR\x06string\x12\x11\n\x04int_\x18\
    \x05\x20\x01(\x11R\x03int\x12!\n\nbool_array\x18\x06\x20\x03(\x08R\tbool\
    ArrayB\x02\x10\0\x12\x1f\n\tint_array\x18\x07\x20\x03(\x11R\x08intArrayB\
    \x02\x10\0\x12#\n\x0bfloat_array\x18\x08\x20\x03(\x02R\nfloatArrayB\x02\
    \x10\0\x12!\n\x0cstring_array\x18\t\x20\x03(\tR\x0bstringArray\"a\n\x15E\
    xecuteServiceRequest\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12+\
    \n\x04args\x18\x02\x20\x03(\x0b2\x17.ExecuteServiceArgumentR\x04args:\t\
    \x80A\x01\xe0@*\xe8@\x02\"\x95\x02\n\x1aListEntitiesCameraResponse\x12\
    \x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\x18\
    \x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\
    \x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\x12.\n\x13disabled\
    _by_default\x18\x05\x20\x01(\x08R\x11disabledByDefault\x12\x12\n\x04icon\
    \x18\x06\x20\x01(\tR\x04icon\x128\n\x0fentity_category\x18\x07\x20\x01(\
    \x0e2\x0f.EntityCategoryR\x0eentityCategory:\x19\xf2@\x10USE_ESP32_CAMER\
    A\xe0@+\xe8@\x01\"j\n\x13CameraImageResponse\x12\x10\n\x03key\x18\x01\
    \x20\x01(\x07R\x03key\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\
    \x12\x12\n\x04done\x18\x03\x20\x01(\x08R\x04done:\x19\xf2@\x10USE_ESP32_\
    CAMERA\xe0@,\xe8@\x01\"b\n\x12CameraImageRequest\x12\x16\n\x06single\x18\
    \x01\x20\x01(\x08R\x06single\x12\x16\n\x06stream\x18\x02\x20\x01(\x08R\
    \x06stream:\x1c\x80A\x01\xf2@\x10USE_ESP32_CAMERA\xe0@-\xe8@\x02\"\x97\
    \x08\n\x1bListEntitiesClimateResponse\x12\x1b\n\tobject_id\x18\x01\x20\
    \x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\
    \x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\
    \x20\x01(\tR\x08uniqueId\x12@\n\x1csupports_current_temperature\x18\x05\
    \x20\x01(\x08R\x1asupportsCurrentTemperature\x12P\n%supports_two_point_t\
    arget_temperature\x18\x06\x20\x01(\x08R!supportsTwoPointTargetTemperatur\
    e\x125\n\x0fsupported_modes\x18\x07\x20\x03(\x0e2\x0c.ClimateModeR\x0esu\
    pportedModes\x124\n\x16visual_min_temperature\x18\x08\x20\x01(\x02R\x14v\
    isualMinTemperature\x124\n\x16visual_max_temperature\x18\t\x20\x01(\x02R\
    \x14visualMaxTemperature\x126\n\x17visual_temperature_step\x18\n\x20\x01\
    (\x02R\x15visualTemperatureStep\x120\n\x14legacy_supports_away\x18\x0b\
    \x20\x01(\x08R\x12legacySupportsAway\x12'\n\x0fsupports_action\x18\x0c\
    \x20\x01(\x08R\x0esupportsAction\x12?\n\x13supported_fan_modes\x18\r\x20\
    \x03(\x0e2\x0f.ClimateFanModeR\x11supportedFanModes\x12E\n\x15supported_\
    swing_modes\x18\x0e\x20\x03(\x0e2\x11.ClimateSwingModeR\x13supportedSwin\
    gModes\x12;\n\x1asupported_custom_fan_modes\x18\x0f\x20\x03(\tR\x17suppo\
    rtedCustomFanModes\x12;\n\x11supported_presets\x18\x10\x20\x03(\x0e2\x0e\
    .ClimatePresetR\x10supportedPresets\x128\n\x18supported_custom_presets\
    \x18\x11\x20\x03(\tR\x16supportedCustomPresets\x12.\n\x13disabled_by_def\
    ault\x18\x12\x20\x01(\x08R\x11disabledByDefault\x12\x12\n\x04icon\x18\
    \x13\x20\x01(\tR\x04icon\x128\n\x0fentity_category\x18\x14\x20\x01(\x0e2\
    \x0f.EntityCategoryR\x0eentityCategory:\x14\xf2@\x0bUSE_CLIMATE\xe0@.\
    \xe8@\x01\"\xcd\x04\n\x14ClimateStateResponse\x12\x10\n\x03key\x18\x01\
    \x20\x01(\x07R\x03key\x12\x20\n\x04mode\x18\x02\x20\x01(\x0e2\x0c.Climat\
    eModeR\x04mode\x12/\n\x13current_temperature\x18\x03\x20\x01(\x02R\x12cu\
    rrentTemperature\x12-\n\x12target_temperature\x18\x04\x20\x01(\x02R\x11t\
    argetTemperature\x124\n\x16target_temperature_low\x18\x05\x20\x01(\x02R\
    \x14targetTemperatureLow\x126\n\x17target_temperature_high\x18\x06\x20\
    \x01(\x02R\x15targetTemperatureHigh\x12\x1f\n\x0blegacy_away\x18\x07\x20\
    \x01(\x08R\nlegacyAway\x12&\n\x06action\x18\x08\x20\x01(\x0e2\x0e.Climat\
    eActionR\x06action\x12*\n\x08fan_mode\x18\t\x20\x01(\x0e2\x0f.ClimateFan\
    ModeR\x07fanMode\x120\n\nswing_mode\x18\n\x20\x01(\x0e2\x11.ClimateSwing\
    ModeR\tswingMode\x12&\n\x0fcustom_fan_mode\x18\x0b\x20\x01(\tR\rcustomFa\
    nMode\x12&\n\x06preset\x18\x0c\x20\x01(\x0e2\x0e.ClimatePresetR\x06prese\
    t\x12#\n\rcustom_preset\x18\r\x20\x01(\tR\x0ccustomPreset:\x17\x80A\x01\
    \xf2@\x0bUSE_CLIMATE\xe0@/\xe8@\x01\"\xac\x07\n\x15ClimateCommandRequest\
    \x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x19\n\x08has_mode\x18\
    \x02\x20\x01(\x08R\x07hasMode\x12\x20\n\x04mode\x18\x03\x20\x01(\x0e2\
    \x0c.ClimateModeR\x04mode\x124\n\x16has_target_temperature\x18\x04\x20\
    \x01(\x08R\x14hasTargetTemperature\x12-\n\x12target_temperature\x18\x05\
    \x20\x01(\x02R\x11targetTemperature\x12;\n\x1ahas_target_temperature_low\
    \x18\x06\x20\x01(\x08R\x17hasTargetTemperatureLow\x124\n\x16target_tempe\
    rature_low\x18\x07\x20\x01(\x02R\x14targetTemperatureLow\x12=\n\x1bhas_t\
    arget_temperature_high\x18\x08\x20\x01(\x08R\x18hasTargetTemperatureHigh\
    \x126\n\x17target_temperature_high\x18\t\x20\x01(\x02R\x15targetTemperat\
    ureHigh\x12&\n\x0fhas_legacy_away\x18\n\x20\x01(\x08R\rhasLegacyAway\x12\
    \x1f\n\x0blegacy_away\x18\x0b\x20\x01(\x08R\nlegacyAway\x12\x20\n\x0chas\
    _fan_mode\x18\x0c\x20\x01(\x08R\nhasFanMode\x12*\n\x08fan_mode\x18\r\x20\
    \x01(\x0e2\x0f.ClimateFanModeR\x07fanMode\x12$\n\x0ehas_swing_mode\x18\
    \x0e\x20\x01(\x08R\x0chasSwingMode\x120\n\nswing_mode\x18\x0f\x20\x01(\
    \x0e2\x11.ClimateSwingModeR\tswingMode\x12-\n\x13has_custom_fan_mode\x18\
    \x10\x20\x01(\x08R\x10hasCustomFanMode\x12&\n\x0fcustom_fan_mode\x18\x11\
    \x20\x01(\tR\rcustomFanMode\x12\x1d\n\nhas_preset\x18\x12\x20\x01(\x08R\
    \thasPreset\x12&\n\x06preset\x18\x13\x20\x01(\x0e2\x0e.ClimatePresetR\
    \x06preset\x12*\n\x11has_custom_preset\x18\x14\x20\x01(\x08R\x0fhasCusto\
    mPreset\x12#\n\rcustom_preset\x18\x15\x20\x01(\tR\x0ccustomPreset:\x17\
    \x80A\x01\xf2@\x0bUSE_CLIMATE\xe0@0\xe8@\x02\"\xae\x03\n\x1aListEntities\
    NumberResponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\x12\
    \x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\x20\
    \x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\
    \x12\x12\n\x04icon\x18\x05\x20\x01(\tR\x04icon\x12\x1b\n\tmin_value\x18\
    \x06\x20\x01(\x02R\x08minValue\x12\x1b\n\tmax_value\x18\x07\x20\x01(\x02\
    R\x08maxValue\x12\x12\n\x04step\x18\x08\x20\x01(\x02R\x04step\x12.\n\x13\
    disabled_by_default\x18\t\x20\x01(\x08R\x11disabledByDefault\x128\n\x0fe\
    ntity_category\x18\n\x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCategory\
    \x12.\n\x13unit_of_measurement\x18\x0b\x20\x01(\tR\x11unitOfMeasurement\
    \x12\x1f\n\x04mode\x18\x0c\x20\x01(\x0e2\x0b.NumberModeR\x04mode:\x13\
    \xf2@\nUSE_NUMBER\xe0@1\xe8@\x01\"z\n\x13NumberStateResponse\x12\x10\n\
    \x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\x02\x20\x01(\
    \x02R\x05state\x12#\n\rmissing_state\x18\x03\x20\x01(\x08R\x0cmissingSta\
    te:\x16\x80A\x01\xf2@\nUSE_NUMBER\xe0@2\xe8@\x01\"V\n\x14NumberCommandRe\
    quest\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\
    \x18\x02\x20\x01(\x02R\x05state:\x16\x80A\x01\xf2@\nUSE_NUMBER\xe0@3\xe8\
    @\x02\"\xa9\x02\n\x1aListEntitiesSelectResponse\x12\x1b\n\tobject_id\x18\
    \x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03k\
    ey\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\
    \x18\x04\x20\x01(\tR\x08uniqueId\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\
    \x04icon\x12\x18\n\x07options\x18\x06\x20\x03(\tR\x07options\x12.\n\x13d\
    isabled_by_default\x18\x07\x20\x01(\x08R\x11disabledByDefault\x128\n\x0f\
    entity_category\x18\x08\x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCateg\
    ory:\x13\xf2@\nUSE_SELECT\xe0@4\xe8@\x01\"z\n\x13SelectStateResponse\x12\
    \x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\x02\
    \x20\x01(\tR\x05state\x12#\n\rmissing_state\x18\x03\x20\x01(\x08R\x0cmis\
    singState:\x16\x80A\x01\xf2@\nUSE_SELECT\xe0@5\xe8@\x01\"V\n\x14SelectCo\
    mmandRequest\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05\
    state\x18\x02\x20\x01(\tR\x05state:\x16\x80A\x01\xf2@\nUSE_SELECT\xe0@6\
    \xe8@\x02\"\x9b\x03\n\x18ListEntitiesLockResponse\x12\x1b\n\tobject_id\
    \x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\
    \x03key\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_\
    id\x18\x04\x20\x01(\tR\x08uniqueId\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\
    \x04icon\x12.\n\x13disabled_by_default\x18\x06\x20\x01(\x08R\x11disabled\
    ByDefault\x128\n\x0fentity_category\x18\x07\x20\x01(\x0e2\x0f.EntityCate\
    goryR\x0eentityCategory\x12#\n\rassumed_state\x18\x08\x20\x01(\x08R\x0ca\
    ssumedState\x12#\n\rsupports_open\x18\t\x20\x01(\x08R\x0csupportsOpen\
    \x12#\n\rrequires_code\x18\n\x20\x01(\x08R\x0crequiresCode\x12\x1f\n\x0b\
    code_format\x18\x0b\x20\x01(\tR\ncodeFormat:\x11\xf2@\x08USE_LOCK\xe0@:\
    \xe8@\x01\"]\n\x11LockStateResponse\x12\x10\n\x03key\x18\x01\x20\x01(\
    \x07R\x03key\x12\x20\n\x05state\x18\x02\x20\x01(\x0e2\n.LockStateR\x05st\
    ate:\x14\x80A\x01\xf2@\x08USE_LOCK\xe0@;\xe8@\x01\"\x93\x01\n\x12LockCom\
    mandRequest\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12&\n\x07comm\
    and\x18\x02\x20\x01(\x0e2\x0c.LockCommandR\x07command\x12\x19\n\x08has_c\
    ode\x18\x03\x20\x01(\x08R\x07hasCode\x12\x12\n\x04code\x18\x04\x20\x01(\
    \tR\x04code:\x14\x80A\x01\xf2@\x08USE_LOCK\xe0@<\xe8@\x02\"\xb2\x02\n\
    \x1aListEntitiesButtonResponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\
    \x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04\
    name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\t\
    R\x08uniqueId\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\x04icon\x12.\n\x13di\
    sabled_by_default\x18\x06\x20\x01(\x08R\x11disabledByDefault\x128\n\x0fe\
    ntity_category\x18\x07\x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCatego\
    ry\x12!\n\x0cdevice_class\x18\x08\x20\x01(\tR\x0bdeviceClass:\x13\xf2@\n\
    USE_BUTTON\xe0@=\xe8@\x01\"@\n\x14ButtonCommandRequest\x12\x10\n\x03key\
    \x18\x01\x20\x01(\x07R\x03key:\x16\x80A\x01\xf2@\nUSE_BUTTON\xe0@>\xe8@\
    \x02\"\xc1\x02\n\x1fListEntitiesMediaPlayerResponse\x12\x1b\n\tobject_id\
    \x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\
    \x03key\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_\
    id\x18\x04\x20\x01(\tR\x08uniqueId\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\
    \x04icon\x12.\n\x13disabled_by_default\x18\x06\x20\x01(\x08R\x11disabled\
    ByDefault\x128\n\x0fentity_category\x18\x07\x20\x01(\x0e2\x0f.EntityCate\
    goryR\x0eentityCategory\x12%\n\x0esupports_pause\x18\x08\x20\x01(\x08R\r\
    supportsPause:\x19\xf2@\x10USE_MEDIA_PLAYER\xe0@?\xe8@\x01\"\xa1\x01\n\
    \x18MediaPlayerStateResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03k\
    ey\x12'\n\x05state\x18\x02\x20\x01(\x0e2\x11.MediaPlayerStateR\x05state\
    \x12\x16\n\x06volume\x18\x03\x20\x01(\x02R\x06volume\x12\x14\n\x05muted\
    \x18\x04\x20\x01(\x08R\x05muted:\x1c\x80A\x01\xf2@\x10USE_MEDIA_PLAYER\
    \xe0@@\xe8@\x01\"\x93\x02\n\x19MediaPlayerCommandRequest\x12\x10\n\x03ke\
    y\x18\x01\x20\x01(\x07R\x03key\x12\x1f\n\x0bhas_command\x18\x02\x20\x01(\
    \x08R\nhasCommand\x12-\n\x07command\x18\x03\x20\x01(\x0e2\x13.MediaPlaye\
    rCommandR\x07command\x12\x1d\n\nhas_volume\x18\x04\x20\x01(\x08R\thasVol\
    ume\x12\x16\n\x06volume\x18\x05\x20\x01(\x02R\x06volume\x12\"\n\rhas_med\
    ia_url\x18\x06\x20\x01(\x08R\x0bhasMediaUrl\x12\x1b\n\tmedia_url\x18\x07\
    \x20\x01(\tR\x08mediaUrl:\x1c\x80A\x01\xf2@\x10USE_MEDIA_PLAYER\xe0@A\
    \xe8@\x02\"3\n)SubscribeBluetoothLEAdvertisementsRequest:\x06\xe0@B\xe8@\
    \x02\"c\n\x14BluetoothServiceData\x12\x12\n\x04uuid\x18\x01\x20\x01(\tR\
    \x04uuid\x12#\n\x0blegacy_data\x18\x02\x20\x03(\rR\nlegacyDataB\x02\x18\
    \x01\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\"\xa8\x02\n\x20Blue\
    toothLEAdvertisementResponse\x12\x18\n\x07address\x18\x01\x20\x01(\x04R\
    \x07address\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04r\
    ssi\x18\x03\x20\x01(\x11R\x04rssi\x12#\n\rservice_uuids\x18\x04\x20\x03(\
    \tR\x0cserviceUuids\x128\n\x0cservice_data\x18\x05\x20\x03(\x0b2\x15.Blu\
    etoothServiceDataR\x0bserviceData\x12B\n\x11manufacturer_data\x18\x06\
    \x20\x03(\x0b2\x15.BluetoothServiceDataR\x10manufacturerData:\x1f\x80A\
    \x01\xf2@\x13USE_BLUETOOTH_PROXY\xe0@C\xe8@\x01\"\x90\x01\n\x16Bluetooth\
    DeviceRequest\x12\x18\n\x07address\x18\x01\x20\x01(\x04R\x07address\x12>\
    \n\x0crequest_type\x18\x02\x20\x01(\x0e2\x1b.BluetoothDeviceRequestTypeR\
    \x0brequestType:\x1c\xf2@\x13USE_BLUETOOTH_PROXY\xe0@D\xe8@\x02\"\xa1\
    \x01\n!BluetoothDeviceConnectionResponse\x12\x18\n\x07address\x18\x01\
    \x20\x01(\x04R\x07address\x12\x1c\n\tconnected\x18\x02\x20\x01(\x08R\tco\
    nnected\x12\x10\n\x03mtu\x18\x03\x20\x01(\rR\x03mtu\x12\x14\n\x05error\
    \x18\x04\x20\x01(\x05R\x05error:\x1c\xf2@\x13USE_BLUETOOTH_PROXY\xe0@E\
    \xe8@\x01\"Y\n\x1fBluetoothGATTGetServicesRequest\x12\x18\n\x07address\
    \x18\x01\x20\x01(\x04R\x07address:\x1c\xf2@\x13USE_BLUETOOTH_PROXY\xe0@F\
    \xe8@\x02\"E\n\x17BluetoothGATTDescriptor\x12\x12\n\x04uuid\x18\x01\x20\
    \x03(\x04R\x04uuid\x12\x16\n\x06handle\x18\x02\x20\x01(\rR\x06handle\"\
    \xa5\x01\n\x1bBluetoothGATTCharacteristic\x12\x12\n\x04uuid\x18\x01\x20\
    \x03(\x04R\x04uuid\x12\x16\n\x06handle\x18\x02\x20\x01(\rR\x06handle\x12\
    \x1e\n\nproperties\x18\x03\x20\x01(\rR\nproperties\x12:\n\x0bdescriptors\
    \x18\x04\x20\x03(\x0b2\x18.BluetoothGATTDescriptorR\x0bdescriptors\"\x8a\
    \x01\n\x14BluetoothGATTService\x12\x12\n\x04uuid\x18\x01\x20\x03(\x04R\
    \x04uuid\x12\x16\n\x06handle\x18\x02\x20\x01(\rR\x06handle\x12F\n\x0fcha\
    racteristics\x18\x03\x20\x03(\x0b2\x1c.BluetoothGATTCharacteristicR\x0fc\
    haracteristics\"\x8d\x01\n\x20BluetoothGATTGetServicesResponse\x12\x18\n\
    \x07address\x18\x01\x20\x01(\x04R\x07address\x121\n\x08services\x18\x02\
    \x20\x03(\x0b2\x15.BluetoothGATTServiceR\x08services:\x1c\xf2@\x13USE_BL\
    UETOOTH_PROXY\xe0@G\xe8@\x01\"^\n$BluetoothGATTGetServicesDoneResponse\
    \x12\x18\n\x07address\x18\x01\x20\x01(\x04R\x07address:\x1c\xf2@\x13USE_\
    BLUETOOTH_PROXY\xe0@H\xe8@\x01\"j\n\x18BluetoothGATTReadRequest\x12\x18\
    \n\x07address\x18\x01\x20\x01(\x04R\x07address\x12\x16\n\x06handle\x18\
    \x02\x20\x01(\rR\x06handle:\x1c\xf2@\x13USE_BLUETOOTH_PROXY\xe0@I\xe8@\
    \x02\"\x7f\n\x19BluetoothGATTReadResponse\x12\x18\n\x07address\x18\x01\
    \x20\x01(\x04R\x07address\x12\x16\n\x06handle\x18\x02\x20\x01(\rR\x06han\
    dle\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data:\x1c\xf2@\x13USE_BLU\
    ETOOTH_PROXY\xe0@J\xe8@\x01\"\x9b\x01\n\x19BluetoothGATTWriteRequest\x12\
    \x18\n\x07address\x18\x01\x20\x01(\x04R\x07address\x12\x16\n\x06handle\
    \x18\x02\x20\x01(\rR\x06handle\x12\x1a\n\x08response\x18\x03\x20\x01(\
    \x08R\x08response\x12\x12\n\x04data\x18\x04\x20\x01(\x0cR\x04data:\x1c\
    \xf2@\x13USE_BLUETOOTH_PROXY\xe0@K\xe8@\x02\"t\n\"BluetoothGATTReadDescr\
    iptorRequest\x12\x18\n\x07address\x18\x01\x20\x01(\x04R\x07address\x12\
    \x16\n\x06handle\x18\x02\x20\x01(\rR\x06handle:\x1c\xf2@\x13USE_BLUETOOT\
    H_PROXY\xe0@L\xe8@\x02\"\x89\x01\n#BluetoothGATTWriteDescriptorRequest\
    \x12\x18\n\x07address\x18\x01\x20\x01(\x04R\x07address\x12\x16\n\x06hand\
    le\x18\x02\x20\x01(\rR\x06handle\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\
    \x04data:\x1c\xf2@\x13USE_BLUETOOTH_PROXY\xe0@M\xe8@\x02\"\x84\x01\n\x1a\
    BluetoothGATTNotifyRequest\x12\x18\n\x07address\x18\x01\x20\x01(\x04R\
    \x07address\x12\x16\n\x06handle\x18\x02\x20\x01(\rR\x06handle\x12\x16\n\
    \x06enable\x18\x03\x20\x01(\x08R\x06enable:\x1c\xf2@\x13USE_BLUETOOTH_PR\
    OXY\xe0@N\xe8@\x02\"\x85\x01\n\x1fBluetoothGATTNotifyDataResponse\x12\
    \x18\n\x07address\x18\x01\x20\x01(\x04R\x07address\x12\x16\n\x06handle\
    \x18\x02\x20\x01(\rR\x06handle\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\
    \x04data:\x1c\xf2@\x13USE_BLUETOOTH_PROXY\xe0@O\xe8@\x01\"H\n(SubscribeB\
    luetoothConnectionsFreeRequest:\x1c\xf2@\x13USE_BLUETOOTH_PROXY\xe0@P\
    \xe8@\x02\"j\n\x20BluetoothConnectionsFreeResponse\x12\x12\n\x04free\x18\
    \x01\x20\x01(\rR\x04free\x12\x14\n\x05limit\x18\x02\x20\x01(\rR\x05limit\
    :\x1c\xf2@\x13USE_BLUETOOTH_PROXY\xe0@Q\xe8@\x01*f\n\x0eEntityCategory\
    \x12\x18\n\x14ENTITY_CATEGORY_NONE\x10\0\x12\x1a\n\x16ENTITY_CATEGORY_CO\
    NFIG\x10\x01\x12\x1e\n\x1aENTITY_CATEGORY_DIAGNOSTIC\x10\x02*N\n\x10Lega\
    cyCoverState\x12\x1b\n\x17LEGACY_COVER_STATE_OPEN\x10\0\x12\x1d\n\x19LEG\
    ACY_COVER_STATE_CLOSED\x10\x01*j\n\x0eCoverOperation\x12\x18\n\x14COVER_\
    OPERATION_IDLE\x10\0\x12\x1e\n\x1aCOVER_OPERATION_IS_OPENING\x10\x01\x12\
    \x1e\n\x1aCOVER_OPERATION_IS_CLOSING\x10\x02*r\n\x12LegacyCoverCommand\
    \x12\x1d\n\x19LEGACY_COVER_COMMAND_OPEN\x10\0\x12\x1e\n\x1aLEGACY_COVER_\
    COMMAND_CLOSE\x10\x01\x12\x1d\n\x19LEGACY_COVER_COMMAND_STOP\x10\x02*G\n\
    \x08FanSpeed\x12\x11\n\rFAN_SPEED_LOW\x10\0\x12\x14\n\x10FAN_SPEED_MEDIU\
    M\x10\x01\x12\x12\n\x0eFAN_SPEED_HIGH\x10\x02*D\n\x0cFanDirection\x12\
    \x19\n\x15FAN_DIRECTION_FORWARD\x10\0\x12\x19\n\x15FAN_DIRECTION_REVERSE\
    \x10\x01*\xa5\x02\n\tColorMode\x12\x16\n\x12COLOR_MODE_UNKNOWN\x10\0\x12\
    \x15\n\x11COLOR_MODE_ON_OFF\x10\x01\x12\x19\n\x15COLOR_MODE_BRIGHTNESS\
    \x10\x02\x12\x14\n\x10COLOR_MODE_WHITE\x10\x07\x12\x20\n\x1cCOLOR_MODE_C\
    OLOR_TEMPERATURE\x10\x0b\x12\x1e\n\x1aCOLOR_MODE_COLD_WARM_WHITE\x10\x13\
    \x12\x12\n\x0eCOLOR_MODE_RGB\x10#\x12\x18\n\x14COLOR_MODE_RGB_WHITE\x10'\
    \x12$\n\x20COLOR_MODE_RGB_COLOR_TEMPERATURE\x10/\x12\"\n\x1eCOLOR_MODE_R\
    GB_COLD_WARM_WHITE\x103*~\n\x10SensorStateClass\x12\x14\n\x10STATE_CLASS\
    _NONE\x10\0\x12\x1b\n\x17STATE_CLASS_MEASUREMENT\x10\x01\x12\x20\n\x1cST\
    ATE_CLASS_TOTAL_INCREASING\x10\x02\x12\x15\n\x11STATE_CLASS_TOTAL\x10\
    \x03*U\n\x13SensorLastResetType\x12\x13\n\x0fLAST_RESET_NONE\x10\0\x12\
    \x14\n\x10LAST_RESET_NEVER\x10\x01\x12\x13\n\x0fLAST_RESET_AUTO\x10\x02*\
    \xb9\x01\n\x08LogLevel\x12\x12\n\x0eLOG_LEVEL_NONE\x10\0\x12\x13\n\x0fLO\
    G_LEVEL_ERROR\x10\x01\x12\x12\n\x0eLOG_LEVEL_WARN\x10\x02\x12\x12\n\x0eL\
    OG_LEVEL_INFO\x10\x03\x12\x14\n\x10LOG_LEVEL_CONFIG\x10\x04\x12\x13\n\
    \x0fLOG_LEVEL_DEBUG\x10\x05\x12\x15\n\x11LOG_LEVEL_VERBOSE\x10\x06\x12\
    \x1a\n\x16LOG_LEVEL_VERY_VERBOSE\x10\x07*\x84\x02\n\x0eServiceArgType\
    \x12\x19\n\x15SERVICE_ARG_TYPE_BOOL\x10\0\x12\x18\n\x14SERVICE_ARG_TYPE_\
    INT\x10\x01\x12\x1a\n\x16SERVICE_ARG_TYPE_FLOAT\x10\x02\x12\x1b\n\x17SER\
    VICE_ARG_TYPE_STRING\x10\x03\x12\x1f\n\x1bSERVICE_ARG_TYPE_BOOL_ARRAY\
    \x10\x04\x12\x1e\n\x1aSERVICE_ARG_TYPE_INT_ARRAY\x10\x05\x12\x20\n\x1cSE\
    RVICE_ARG_TYPE_FLOAT_ARRAY\x10\x06\x12!\n\x1dSERVICE_ARG_TYPE_STRING_ARR\
    AY\x10\x07*\xb5\x01\n\x0bClimateMode\x12\x14\n\x10CLIMATE_MODE_OFF\x10\0\
    \x12\x1a\n\x16CLIMATE_MODE_HEAT_COOL\x10\x01\x12\x15\n\x11CLIMATE_MODE_C\
    OOL\x10\x02\x12\x15\n\x11CLIMATE_MODE_HEAT\x10\x03\x12\x19\n\x15CLIMATE_\
    MODE_FAN_ONLY\x10\x04\x12\x14\n\x10CLIMATE_MODE_DRY\x10\x05\x12\x15\n\
    \x11CLIMATE_MODE_AUTO\x10\x06*\xda\x01\n\x0eClimateFanMode\x12\x12\n\x0e\
    CLIMATE_FAN_ON\x10\0\x12\x13\n\x0fCLIMATE_FAN_OFF\x10\x01\x12\x14\n\x10C\
    LIMATE_FAN_AUTO\x10\x02\x12\x13\n\x0fCLIMATE_FAN_LOW\x10\x03\x12\x16\n\
    \x12CLIMATE_FAN_MEDIUM\x10\x04\x12\x14\n\x10CLIMATE_FAN_HIGH\x10\x05\x12\
    \x16\n\x12CLIMATE_FAN_MIDDLE\x10\x06\x12\x15\n\x11CLIMATE_FAN_FOCUS\x10\
    \x07\x12\x17\n\x13CLIMATE_FAN_DIFFUSE\x10\x08*{\n\x10ClimateSwingMode\
    \x12\x15\n\x11CLIMATE_SWING_OFF\x10\0\x12\x16\n\x12CLIMATE_SWING_BOTH\
    \x10\x01\x12\x1a\n\x16CLIMATE_SWING_VERTICAL\x10\x02\x12\x1c\n\x18CLIMAT\
    E_SWING_HORIZONTAL\x10\x03*\xab\x01\n\rClimateAction\x12\x16\n\x12CLIMAT\
    E_ACTION_OFF\x10\0\x12\x1a\n\x16CLIMATE_ACTION_COOLING\x10\x02\x12\x1a\n\
    \x16CLIMATE_ACTION_HEATING\x10\x03\x12\x17\n\x13CLIMATE_ACTION_IDLE\x10\
    \x04\x12\x19\n\x15CLIMATE_ACTION_DRYING\x10\x05\x12\x16\n\x12CLIMATE_ACT\
    ION_FAN\x10\x06*\xdf\x01\n\rClimatePreset\x12\x17\n\x13CLIMATE_PRESET_NO\
    NE\x10\0\x12\x17\n\x13CLIMATE_PRESET_HOME\x10\x01\x12\x17\n\x13CLIMATE_P\
    RESET_AWAY\x10\x02\x12\x18\n\x14CLIMATE_PRESET_BOOST\x10\x03\x12\x1a\n\
    \x16CLIMATE_PRESET_COMFORT\x10\x04\x12\x16\n\x12CLIMATE_PRESET_ECO\x10\
    \x05\x12\x18\n\x14CLIMATE_PRESET_SLEEP\x10\x06\x12\x1b\n\x17CLIMATE_PRES\
    ET_ACTIVITY\x10\x07*O\n\nNumberMode\x12\x14\n\x10NUMBER_MODE_AUTO\x10\0\
    \x12\x13\n\x0fNUMBER_MODE_BOX\x10\x01\x12\x16\n\x12NUMBER_MODE_SLIDER\
    \x10\x02*\x99\x01\n\tLockState\x12\x13\n\x0fLOCK_STATE_NONE\x10\0\x12\
    \x15\n\x11LOCK_STATE_LOCKED\x10\x01\x12\x17\n\x13LOCK_STATE_UNLOCKED\x10\
    \x02\x12\x15\n\x11LOCK_STATE_JAMMED\x10\x03\x12\x16\n\x12LOCK_STATE_LOCK\
    ING\x10\x04\x12\x18\n\x14LOCK_STATE_UNLOCKING\x10\x05*<\n\x0bLockCommand\
    \x12\x0f\n\x0bLOCK_UNLOCK\x10\0\x12\r\n\tLOCK_LOCK\x10\x01\x12\r\n\tLOCK\
    _OPEN\x10\x02*\x8b\x01\n\x10MediaPlayerState\x12\x1b\n\x17MEDIA_PLAYER_S\
    TATE_NONE\x10\0\x12\x1b\n\x17MEDIA_PLAYER_STATE_IDLE\x10\x01\x12\x1e\n\
    \x1aMEDIA_PLAYER_STATE_PLAYING\x10\x02\x12\x1d\n\x19MEDIA_PLAYER_STATE_P\
    AUSED\x10\x03*\xb2\x01\n\x12MediaPlayerCommand\x12\x1d\n\x19MEDIA_PLAYER\
    _COMMAND_PLAY\x10\0\x12\x1e\n\x1aMEDIA_PLAYER_COMMAND_PAUSE\x10\x01\x12\
    \x1d\n\x19MEDIA_PLAYER_COMMAND_STOP\x10\x02\x12\x1d\n\x19MEDIA_PLAYER_CO\
    MMAND_MUTE\x10\x03\x12\x1f\n\x1bMEDIA_PLAYER_COMMAND_UNMUTE\x10\x04*\xc7\
    \x01\n\x1aBluetoothDeviceRequestType\x12)\n%BLUETOOTH_DEVICE_REQUEST_TYP\
    E_CONNECT\x10\0\x12,\n(BLUETOOTH_DEVICE_REQUEST_TYPE_DISCONNECT\x10\x01\
    \x12&\n\"BLUETOOTH_DEVICE_REQUEST_TYPE_PAIR\x10\x02\x12(\n$BLUETOOTH_DEV\
    ICE_REQUEST_TYPE_UNPAIR\x10\x032\x9d\x0f\n\rAPIConnection\x12.\n\x05hell\
    o\x12\r.HelloRequest\x1a\x0e.HelloResponse\"\x06\xf0@\0\xf8@\0\x124\n\
    \x07connect\x12\x0f.ConnectRequest\x1a\x10.ConnectResponse\"\x06\xf0@\0\
    \xf8@\0\x12=\n\ndisconnect\x12\x12.DisconnectRequest\x1a\x13.DisconnectR\
    esponse\"\x06\xf0@\0\xf8@\0\x12+\n\x04ping\x12\x0c.PingRequest\x1a\r.Pin\
    gResponse\"\x06\xf0@\0\xf8@\0\x12;\n\x0bdevice_info\x12\x12.DeviceInfoRe\
    quest\x1a\x13.DeviceInfoResponse\"\x03\xf8@\0\x12.\n\rlist_entities\x12\
    \x14.ListEntitiesRequest\x1a\x05.void\"\0\x124\n\x10subscribe_states\x12\
    \x17.SubscribeStatesRequest\x1a\x05.void\"\0\x120\n\x0esubscribe_logs\
    \x12\x15.SubscribeLogsRequest\x1a\x05.void\"\0\x12S\n\x20subscribe_homea\
    ssistant_services\x12&.SubscribeHomeassistantServicesRequest\x1a\x05.voi\
    d\"\0\x12P\n\x1fsubscribe_home_assistant_states\x12$.SubscribeHomeAssist\
    antStatesRequest\x1a\x05.void\"\0\x122\n\x08get_time\x12\x0f.GetTimeRequ\
    est\x1a\x10.GetTimeResponse\"\x03\xf8@\0\x122\n\x0fexecute_service\x12\
    \x16.ExecuteServiceRequest\x1a\x05.void\"\0\x12.\n\rcover_command\x12\
    \x14.CoverCommandRequest\x1a\x05.void\"\0\x12*\n\x0bfan_command\x12\x12.\
    FanCommandRequest\x1a\x05.void\"\0\x12.\n\rlight_command\x12\x14.LightCo\
    mmandRequest\x1a\x05.void\"\0\x120\n\x0eswitch_command\x12\x15.SwitchCom\
    mandRequest\x1a\x05.void\"\0\x12,\n\x0ccamera_image\x12\x13.CameraImageR\
    equest\x1a\x05.void\"\0\x122\n\x0fclimate_command\x12\x16.ClimateCommand\
    Request\x1a\x05.void\"\0\x120\n\x0enumber_command\x12\x15.NumberCommandR\
    equest\x1a\x05.void\"\0\x120\n\x0eselect_command\x12\x15.SelectCommandRe\
    quest\x1a\x05.void\"\0\x120\n\x0ebutton_command\x12\x15.ButtonCommandReq\
    uest\x1a\x05.void\"\0\x12,\n\x0clock_command\x12\x13.LockCommandRequest\
    \x1a\x05.void\"\0\x12;\n\x14media_player_command\x12\x1a.MediaPlayerComm\
    andRequest\x1a\x05.void\"\0\x12\\\n%subscribe_bluetooth_le_advertisement\
    s\x12*.SubscribeBluetoothLEAdvertisementsRequest\x1a\x05.void\"\0\x12<\n\
    \x18bluetooth_device_request\x12\x17.BluetoothDeviceRequest\x1a\x05.void\
    \"\0\x12H\n\x1bbluetooth_gatt_get_services\x12\x20.BluetoothGATTGetServi\
    cesRequest\x1a\x05.void\"\0\x129\n\x13bluetooth_gatt_read\x12\x19.Blueto\
    othGATTReadRequest\x1a\x05.void\"\0\x12;\n\x14bluetooth_gatt_write\x12\
    \x1a.BluetoothGATTWriteRequest\x1a\x05.void\"\0\x12N\n\x1ebluetooth_gatt\
    _read_descriptor\x12#.BluetoothGATTReadDescriptorRequest\x1a\x05.void\"\
    \0\x12P\n\x1fbluetooth_gatt_write_descriptor\x12$.BluetoothGATTWriteDesc\
    riptorRequest\x1a\x05.void\"\0\x12=\n\x15bluetooth_gatt_notify\x12\x1b.B\
    luetoothGATTNotifyRequest\x1a\x05.void\"\0\x12v\n$subscribe_bluetooth_co\
    nnections_free\x12).SubscribeBluetoothConnectionsFreeRequest\x1a!.Blueto\
    othConnectionsFreeResponse\"\0J\xb3\xee\x02\n\x07\x12\x05\0\0\x93\n\x01\
    \n\x08\n\x01\x0c\x12\x03\0\0\x12\n\t\n\x02\x03\0\x12\x03\x02\0\x1b\n\n\n\
    \x02\x06\0\x12\x04\x04\07\x01\n\n\n\x03\x06\0\x01\x12\x03\x04\x08\x15\n\
    \x0c\n\x04\x06\0\x02\0\x12\x04\x05\x02\x08\x03\n\x0c\n\x05\x06\0\x02\0\
    \x01\x12\x03\x05\x06\x0b\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\x05\r\x19\n\
    \x0c\n\x05\x06\0\x02\0\x03\x12\x03\x05$1\n\x0c\n\x05\x06\0\x02\0\x04\x12\
    \x03\x06\x04,\n\x0e\n\x07\x06\0\x02\0\x04\x8e\x08\x12\x03\x06\x04,\n\x0c\
    \n\x05\x06\0\x02\0\x04\x12\x03\x07\x04*\n\x0e\n\x07\x06\0\x02\0\x04\x8f\
    \x08\x12\x03\x07\x04*\n\x0c\n\x04\x06\0\x02\x01\x12\x04\t\x02\x0c\x03\n\
    \x0c\n\x05\x06\0\x02\x01\x01\x12\x03\t\x06\r\n\x0c\n\x05\x06\0\x02\x01\
    \x02\x12\x03\t\x0f\x1d\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03\t(7\n\x0c\n\
    \x05\x06\0\x02\x01\x04\x12\x03\n\x04,\n\x0e\n\x07\x06\0\x02\x01\x04\x8e\
    \x08\x12\x03\n\x04,\n\x0c\n\x05\x06\0\x02\x01\x04\x12\x03\x0b\x04*\n\x0e\
    \n\x07\x06\0\x02\x01\x04\x8f\x08\x12\x03\x0b\x04*\n\x0c\n\x04\x06\0\x02\
    \x02\x12\x04\r\x02\x10\x03\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03\r\x06\
    \x10\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\r\x12#\n\x0c\n\x05\x06\0\x02\
    \x02\x03\x12\x03\r.@\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03\x0e\x04,\n\
    \x0e\n\x07\x06\0\x02\x02\x04\x8e\x08\x12\x03\x0e\x04,\n\x0c\n\x05\x06\0\
    \x02\x02\x04\x12\x03\x0f\x04*\n\x0e\n\x07\x06\0\x02\x02\x04\x8f\x08\x12\
    \x03\x0f\x04*\n\x0c\n\x04\x06\0\x02\x03\x12\x04\x11\x02\x14\x03\n\x0c\n\
    \x05\x06\0\x02\x03\x01\x12\x03\x11\x06\n\n\x0c\n\x05\x06\0\x02\x03\x02\
    \x12\x03\x11\x0c\x17\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03\x11\".\n\x0c\
    \n\x05\x06\0\x02\x03\x04\x12\x03\x12\x04,\n\x0e\n\x07\x06\0\x02\x03\x04\
    \x8e\x08\x12\x03\x12\x04,\n\x0c\n\x05\x06\0\x02\x03\x04\x12\x03\x13\x04*\
    \n\x0e\n\x07\x06\0\x02\x03\x04\x8f\x08\x12\x03\x13\x04*\n\x0c\n\x04\x06\
    \0\x02\x04\x12\x04\x15\x02\x17\x03\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03\
    \x15\x06\x11\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03\x15\x13$\n\x0c\n\x05\
    \x06\0\x02\x04\x03\x12\x03\x15/A\n\x0c\n\x05\x06\0\x02\x04\x04\x12\x03\
    \x16\x04*\n\x0e\n\x07\x06\0\x02\x04\x04\x8f\x08\x12\x03\x16\x04*\n\x0b\n\
    \x04\x06\0\x02\x05\x12\x03\x18\x02;\n\x0c\n\x05\x06\0\x02\x05\x01\x12\
    \x03\x18\x06\x13\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03\x18\x15(\n\x0c\n\
    \x05\x06\0\x02\x05\x03\x12\x03\x1837\n\x0b\n\x04\x06\0\x02\x06\x12\x03\
    \x19\x02A\n\x0c\n\x05\x06\0\x02\x06\x01\x12\x03\x19\x06\x16\n\x0c\n\x05\
    \x06\0\x02\x06\x02\x12\x03\x19\x18.\n\x0c\n\x05\x06\0\x02\x06\x03\x12\
    \x03\x199=\n\x0b\n\x04\x06\0\x02\x07\x12\x03\x1a\x02=\n\x0c\n\x05\x06\0\
    \x02\x07\x01\x12\x03\x1a\x06\x14\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x03\
    \x1a\x16*\n\x0c\n\x05\x06\0\x02\x07\x03\x12\x03\x1a59\n\x0b\n\x04\x06\0\
    \x02\x08\x12\x03\x1b\x02`\n\x0c\n\x05\x06\0\x02\x08\x01\x12\x03\x1b\x06&\
    \n\x0c\n\x05\x06\0\x02\x08\x02\x12\x03\x1b(M\n\x0c\n\x05\x06\0\x02\x08\
    \x03\x12\x03\x1bX\\\n\x0b\n\x04\x06\0\x02\t\x12\x03\x1c\x02]\n\x0c\n\x05\
    \x06\0\x02\t\x01\x12\x03\x1c\x06%\n\x0c\n\x05\x06\0\x02\t\x02\x12\x03\
    \x1c'J\n\x0c\n\x05\x06\0\x02\t\x03\x12\x03\x1cUY\n\x0c\n\x04\x06\0\x02\n\
    \x12\x04\x1d\x02\x1f\x03\n\x0c\n\x05\x06\0\x02\n\x01\x12\x03\x1d\x06\x0e\
    \n\x0c\n\x05\x06\0\x02\n\x02\x12\x03\x1d\x10\x1e\n\x0c\n\x05\x06\0\x02\n\
    \x03\x12\x03\x1d)8\n\x0c\n\x05\x06\0\x02\n\x04\x12\x03\x1e\x04*\n\x0e\n\
    \x07\x06\0\x02\n\x04\x8f\x08\x12\x03\x1e\x04*\n\x0b\n\x04\x06\0\x02\x0b\
    \x12\x03\x20\x02?\n\x0c\n\x05\x06\0\x02\x0b\x01\x12\x03\x20\x06\x15\n\
    \x0c\n\x05\x06\0\x02\x0b\x02\x12\x03\x20\x17,\n\x0c\n\x05\x06\0\x02\x0b\
    \x03\x12\x03\x207;\n\x0b\n\x04\x06\0\x02\x0c\x12\x03\"\x02;\n\x0c\n\x05\
    \x06\0\x02\x0c\x01\x12\x03\"\x06\x13\n\x0c\n\x05\x06\0\x02\x0c\x02\x12\
    \x03\"\x15(\n\x0c\n\x05\x06\0\x02\x0c\x03\x12\x03\"37\n\x0b\n\x04\x06\0\
    \x02\r\x12\x03#\x027\n\x0c\n\x05\x06\0\x02\r\x01\x12\x03#\x06\x11\n\x0c\
    \n\x05\x06\0\x02\r\x02\x12\x03#\x13$\n\x0c\n\x05\x06\0\x02\r\x03\x12\x03\
    #/3\n\x0b\n\x04\x06\0\x02\x0e\x12\x03$\x02;\n\x0c\n\x05\x06\0\x02\x0e\
    \x01\x12\x03$\x06\x13\n\x0c\n\x05\x06\0\x02\x0e\x02\x12\x03$\x15(\n\x0c\
    \n\x05\x06\0\x02\x0e\x03\x12\x03$37\n\x0b\n\x04\x06\0\x02\x0f\x12\x03%\
    \x02=\n\x0c\n\x05\x06\0\x02\x0f\x01\x12\x03%\x06\x14\n\x0c\n\x05\x06\0\
    \x02\x0f\x02\x12\x03%\x16*\n\x0c\n\x05\x06\0\x02\x0f\x03\x12\x03%59\n\
    \x0b\n\x04\x06\0\x02\x10\x12\x03&\x029\n\x0c\n\x05\x06\0\x02\x10\x01\x12\
    \x03&\x06\x12\n\x0c\n\x05\x06\0\x02\x10\x02\x12\x03&\x14&\n\x0c\n\x05\
    \x06\0\x02\x10\x03\x12\x03&15\n\x0b\n\x04\x06\0\x02\x11\x12\x03'\x02?\n\
    \x0c\n\x05\x06\0\x02\x11\x01\x12\x03'\x06\x15\n\x0c\n\x05\x06\0\x02\x11\
    \x02\x12\x03'\x17,\n\x0c\n\x05\x06\0\x02\x11\x03\x12\x03'7;\n\x0b\n\x04\
    \x06\0\x02\x12\x12\x03(\x02=\n\x0c\n\x05\x06\0\x02\x12\x01\x12\x03(\x06\
    \x14\n\x0c\n\x05\x06\0\x02\x12\x02\x12\x03(\x16*\n\x0c\n\x05\x06\0\x02\
    \x12\x03\x12\x03(59\n\x0b\n\x04\x06\0\x02\x13\x12\x03)\x02=\n\x0c\n\x05\
    \x06\0\x02\x13\x01\x12\x03)\x06\x14\n\x0c\n\x05\x06\0\x02\x13\x02\x12\
    \x03)\x16*\n\x0c\n\x05\x06\0\x02\x13\x03\x12\x03)59\n\x0b\n\x04\x06\0\
    \x02\x14\x12\x03*\x02=\n\x0c\n\x05\x06\0\x02\x14\x01\x12\x03*\x06\x14\n\
    \x0c\n\x05\x06\0\x02\x14\x02\x12\x03*\x16*\n\x0c\n\x05\x06\0\x02\x14\x03\
    \x12\x03*59\n\x0b\n\x04\x06\0\x02\x15\x12\x03+\x029\n\x0c\n\x05\x06\0\
    \x02\x15\x01\x12\x03+\x06\x12\n\x0c\n\x05\x06\0\x02\x15\x02\x12\x03+\x14\
    &\n\x0c\n\x05\x06\0\x02\x15\x03\x12\x03+15\n\x0b\n\x04\x06\0\x02\x16\x12\
    \x03,\x02H\n\x0c\n\x05\x06\0\x02\x16\x01\x12\x03,\x06\x1a\n\x0c\n\x05\
    \x06\0\x02\x16\x02\x12\x03,\x1c5\n\x0c\n\x05\x06\0\x02\x16\x03\x12\x03,@\
    D\n\x0b\n\x04\x06\0\x02\x17\x12\x03.\x02h\n\x0c\n\x05\x06\0\x02\x17\x01\
    \x12\x03.\x06+\n\x0c\n\x05\x06\0\x02\x17\x02\x12\x03.,U\n\x0c\n\x05\x06\
    \0\x02\x17\x03\x12\x03.`d\n\x0b\n\x04\x06\0\x02\x18\x12\x03/\x02H\n\x0c\
    \n\x05\x06\0\x02\x18\x01\x12\x03/\x06\x1e\n\x0c\n\x05\x06\0\x02\x18\x02\
    \x12\x03/\x1f5\n\x0c\n\x05\x06\0\x02\x18\x03\x12\x03/@D\n\x0b\n\x04\x06\
    \0\x02\x19\x12\x030\x02T\n\x0c\n\x05\x06\0\x02\x19\x01\x12\x030\x06!\n\
    \x0c\n\x05\x06\0\x02\x19\x02\x12\x030\"A\n\x0c\n\x05\x06\0\x02\x19\x03\
    \x12\x030LP\n\x0b\n\x04\x06\0\x02\x1a\x12\x031\x02E\n\x0c\n\x05\x06\0\
    \x02\x1a\x01\x12\x031\x06\x19\n\x0c\n\x05\x06\0\x02\x1a\x02\x12\x031\x1a\
    2\n\x0c\n\x05\x06\0\x02\x1a\x03\x12\x031=A\n\x0b\n\x04\x06\0\x02\x1b\x12\
    \x032\x02G\n\x0c\n\x05\x06\0\x02\x1b\x01\x12\x032\x06\x1a\n\x0c\n\x05\
    \x06\0\x02\x1b\x02\x12\x032\x1b4\n\x0c\n\x05\x06\0\x02\x1b\x03\x12\x032?\
    C\n\x0b\n\x04\x06\0\x02\x1c\x12\x033\x02Z\n\x0c\n\x05\x06\0\x02\x1c\x01\
    \x12\x033\x06$\n\x0c\n\x05\x06\0\x02\x1c\x02\x12\x033%G\n\x0c\n\x05\x06\
    \0\x02\x1c\x03\x12\x033RV\n\x0b\n\x04\x06\0\x02\x1d\x12\x034\x02\\\n\x0c\
    \n\x05\x06\0\x02\x1d\x01\x12\x034\x06%\n\x0c\n\x05\x06\0\x02\x1d\x02\x12\
    \x034&I\n\x0c\n\x05\x06\0\x02\x1d\x03\x12\x034TX\n\x0b\n\x04\x06\0\x02\
    \x1e\x12\x035\x02I\n\x0c\n\x05\x06\0\x02\x1e\x01\x12\x035\x06\x1b\n\x0c\
    \n\x05\x06\0\x02\x1e\x02\x12\x035\x1c6\n\x0c\n\x05\x06\0\x02\x1e\x03\x12\
    \x035AE\n\x0c\n\x04\x06\0\x02\x1f\x12\x046\x02\x82\x01\n\x0c\n\x05\x06\0\
    \x02\x1f\x01\x12\x036\x06*\n\x0c\n\x05\x06\0\x02\x1f\x02\x12\x036+S\n\
    \x0c\n\x05\x06\0\x02\x1f\x03\x12\x036^~\n\xff\x08\n\x02\x04\0\x12\x04O\0\
    [\x01\x1a~\x20Message\x20sent\x20at\x20the\x20beginning\x20of\x20each\
    \x20connection\n\x20Can\x20only\x20be\x20sent\x20by\x20the\x20client\x20\
    and\x20only\x20at\x20the\x20beginning\x20of\x20the\x20connection\n28\x20\
    ====================\x20BASE\x20PACKETS\x20====================\n2\xfd\
    \x02\x20The\x20Home\x20Assistant\x20protocol\x20is\x20structured\x20as\
    \x20a\x20simple\n\x20TCP\x20socket\x20with\x20short\x20binary\x20message\
    s\x20encoded\x20in\x20the\x20protocol\x20buffers\x20format\n\x20First,\
    \x20a\x20message\x20in\x20this\x20protocol\x20has\x20a\x20specific\x20fo\
    rmat:\n\x20\x20*\x20A\x20zero\x20byte.\n\x20\x20*\x20VarInt\x20denoting\
    \x20the\x20size\x20of\x20the\x20message\x20object.\x20(type\x20is\x20not\
    \x20part\x20of\x20this)\n\x20\x20*\x20VarInt\x20denoting\x20the\x20type\
    \x20of\x20message.\n\x20\x20*\x20The\x20message\x20object\x20encoded\x20\
    as\x20a\x20ProtoBuf\x20message\n2\xb8\x04\x20The\x20connection\x20is\x20\
    established\x20in\x204\x20steps:\n\x20\x20*\x20First,\x20the\x20client\
    \x20connects\x20to\x20the\x20server\x20and\x20sends\x20a\x20\"Hello\x20R\
    equest\"\x20identifying\x20itself\n\x20\x20*\x20The\x20server\x20respond\
    s\x20with\x20a\x20\"Hello\x20Response\"\x20and\x20selects\x20the\x20prot\
    ocol\x20version\n\x20\x20*\x20After\x20receiving\x20this\x20message,\x20\
    the\x20client\x20attempts\x20to\x20authenticate\x20itself\x20using\n\x20\
    \x20\x20\x20the\x20password\x20and\x20a\x20\"Connect\x20Request\"\n\x20\
    \x20*\x20The\x20server\x20responds\x20with\x20a\x20\"Connect\x20Response\
    \"\x20and\x20notifies\x20of\x20invalid\x20password.\n\x20If\x20anything\
    \x20in\x20this\x20initial\x20process\x20fails,\x20the\x20connection\x20m\
    ust\x20immediately\x20closed\n\x20by\x20both\x20sides\x20and\x20_no_\x20\
    disconnection\x20message\x20is\x20to\x20be\x20sent.\n\n\n\n\x03\x04\0\
    \x01\x12\x03O\x08\x14\n\n\n\x03\x04\0\x07\x12\x03P\x02\x12\n\x0c\n\x05\
    \x04\0\x07\x8c\x08\x12\x03P\x02\x12\n\n\n\x03\x04\0\x07\x12\x03Q\x02\"\n\
    \x0c\n\x05\x04\0\x07\x8d\x08\x12\x03Q\x02\"\n\n\n\x03\x04\0\x07\x12\x03R\
    \x02\x1b\n\x0c\n\x05\x04\0\x07\x90\x08\x12\x03R\x02\x1b\n\x97\x01\n\x04\
    \x04\0\x02\0\x12\x03X\x02\x19\x1a\x89\x01\x20Description\x20of\x20client\
    \x20(like\x20User\x20Agent)\n\x20For\x20example\x20\"Home\x20Assistant\"\
    \n\x20Not\x20strictly\x20necessary\x20to\x20send\x20but\x20nice\x20for\
    \x20debugging\n\x20purposes.\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03X\x02\
    \x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03X\t\x14\n\x0c\n\x05\x04\0\x02\0\
    \x03\x12\x03X\x17\x18\n\x0b\n\x04\x04\0\x02\x01\x12\x03Y\x02\x1f\n\x0c\n\
    \x05\x04\0\x02\x01\x05\x12\x03Y\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\
    \x12\x03Y\t\x1a\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03Y\x1d\x1e\n\x0b\n\
    \x04\x04\0\x02\x02\x12\x03Z\x02\x1f\n\x0c\n\x05\x04\0\x02\x02\x05\x12\
    \x03Z\x02\x08\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03Z\t\x1a\n\x0c\n\x05\
    \x04\0\x02\x02\x03\x12\x03Z\x1d\x1e\n\x88\x01\n\x02\x04\x01\x12\x04_\0r\
    \x01\x1a|\x20Confirmation\x20of\x20successful\x20connection\x20request.\
    \n\x20Can\x20only\x20be\x20sent\x20by\x20the\x20server\x20and\x20only\
    \x20at\x20the\x20beginning\x20of\x20the\x20connection\n\n\n\n\x03\x04\
    \x01\x01\x12\x03_\x08\x15\n\n\n\x03\x04\x01\x07\x12\x03`\x02\x12\n\x0c\n\
    \x05\x04\x01\x07\x8c\x08\x12\x03`\x02\x12\n\n\n\x03\x04\x01\x07\x12\x03a\
    \x02\"\n\x0c\n\x05\x04\x01\x07\x8d\x08\x12\x03a\x02\"\n\n\n\x03\x04\x01\
    \x07\x12\x03b\x02\x1b\n\x0c\n\x05\x04\x01\x07\x90\x08\x12\x03b\x02\x1b\n\
    \xef\x02\n\x04\x04\x01\x02\0\x12\x03h\x02\x1f\x1a\xe1\x02\x20The\x20vers\
    ion\x20of\x20the\x20API\x20to\x20use.\x20The\x20_client_\x20(for\x20exam\
    ple\x20Home\x20Assistant)\x20needs\x20to\x20check\n\x20for\x20compatibil\
    ity\x20and\x20if\x20necessary\x20adopt\x20to\x20an\x20older\x20API.\n\
    \x20Major\x20is\x20for\x20breaking\x20changes\x20in\x20the\x20base\x20pr\
    otocol\x20-\x20a\x20mismatch\x20will\x20lead\x20to\x20immediate\x20disco\
    nnect_client_\n\x20Minor\x20is\x20for\x20breaking\x20changes\x20in\x20in\
    dividual\x20messages\x20-\x20a\x20mismatch\x20will\x20lead\x20to\x20a\
    \x20warning\x20message\n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03h\x02\x08\
    \n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03h\t\x1a\n\x0c\n\x05\x04\x01\x02\0\
    \x03\x12\x03h\x1d\x1e\n\x0b\n\x04\x04\x01\x02\x01\x12\x03i\x02\x1f\n\x0c\
    \n\x05\x04\x01\x02\x01\x05\x12\x03i\x02\x08\n\x0c\n\x05\x04\x01\x02\x01\
    \x01\x12\x03i\t\x1a\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03i\x1d\x1e\n\
    \xb4\x01\n\x04\x04\x01\x02\x02\x12\x03n\x02\x19\x1a\xa6\x01\x20A\x20stri\
    ng\x20identifying\x20the\x20server\x20(ESP);\x20like\x20client\x20info\
    \x20this\x20may\x20be\x20empty\n\x20and\x20only\x20exists\x20for\x20debu\
    gging/logging\x20purposes.\n\x20For\x20example\x20\"ESPHome\x20v1.10.0\
    \x20on\x20ESP8266\"\n\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03n\x02\x08\n\
    \x0c\n\x05\x04\x01\x02\x02\x01\x12\x03n\t\x14\n\x0c\n\x05\x04\x01\x02\
    \x02\x03\x12\x03n\x17\x18\n6\n\x04\x04\x01\x02\x03\x12\x03q\x02\x12\x1a)\
    \x20The\x20name\x20of\x20the\x20server\x20(App.get_name())\n\n\x0c\n\x05\
    \x04\x01\x02\x03\x05\x12\x03q\x02\x08\n\x0c\n\x05\x04\x01\x02\x03\x01\
    \x12\x03q\t\r\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03q\x10\x11\n\xa6\x01\
    \n\x02\x04\x02\x12\x04v\0}\x01\x1a\x99\x01\x20Message\x20sent\x20at\x20t\
    he\x20beginning\x20of\x20each\x20connection\x20to\x20authenticate\x20the\
    \x20client\n\x20Can\x20only\x20be\x20sent\x20by\x20the\x20client\x20and\
    \x20only\x20at\x20the\x20beginning\x20of\x20the\x20connection\n\n\n\n\
    \x03\x04\x02\x01\x12\x03v\x08\x16\n\n\n\x03\x04\x02\x07\x12\x03w\x02\x12\
    \n\x0c\n\x05\x04\x02\x07\x8c\x08\x12\x03w\x02\x12\n\n\n\x03\x04\x02\x07\
    \x12\x03x\x02\"\n\x0c\n\x05\x04\x02\x07\x8d\x08\x12\x03x\x02\"\n\n\n\x03\
    \x04\x02\x07\x12\x03y\x02\x1b\n\x0c\n\x05\x04\x02\x07\x90\x08\x12\x03y\
    \x02\x1b\n*\n\x04\x04\x02\x02\0\x12\x03|\x02\x16\x1a\x1d\x20The\x20passw\
    ord\x20to\x20log\x20in\x20with\n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03|\
    \x02\x08\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03|\t\x11\n\x0c\n\x05\x04\
    \x02\x02\0\x03\x12\x03|\x14\x15\n\xbb\x01\n\x02\x04\x03\x12\x06\x81\x01\
    \0\x87\x01\x01\x1a\xac\x01\x20Confirmation\x20of\x20successful\x20connec\
    tion.\x20After\x20this\x20the\x20connection\x20is\x20available\x20for\
    \x20all\x20traffic.\n\x20Can\x20only\x20be\x20sent\x20by\x20the\x20serve\
    r\x20and\x20only\x20at\x20the\x20beginning\x20of\x20the\x20connection\n\
    \n\x0b\n\x03\x04\x03\x01\x12\x04\x81\x01\x08\x17\n\x0b\n\x03\x04\x03\x07\
    \x12\x04\x82\x01\x02\x12\n\r\n\x05\x04\x03\x07\x8c\x08\x12\x04\x82\x01\
    \x02\x12\n\x0b\n\x03\x04\x03\x07\x12\x04\x83\x01\x02\"\n\r\n\x05\x04\x03\
    \x07\x8d\x08\x12\x04\x83\x01\x02\"\n\x0b\n\x03\x04\x03\x07\x12\x04\x84\
    \x01\x02\x1b\n\r\n\x05\x04\x03\x07\x90\x08\x12\x04\x84\x01\x02\x1b\n\x0c\
    \n\x04\x04\x03\x02\0\x12\x04\x86\x01\x02\x1c\n\r\n\x05\x04\x03\x02\0\x05\
    \x12\x04\x86\x01\x02\x06\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\x86\x01\x07\
    \x17\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\x86\x01\x1a\x1b\n[\n\x02\x04\
    \x04\x12\x06\x8b\x01\0\x91\x01\x01\x1aM\x20Request\x20to\x20close\x20the\
    \x20connection.\n\x20Can\x20be\x20sent\x20by\x20both\x20the\x20client\
    \x20and\x20server\n\n\x0b\n\x03\x04\x04\x01\x12\x04\x8b\x01\x08\x19\n\
    \x0b\n\x03\x04\x04\x07\x12\x04\x8c\x01\x02\x12\n\r\n\x05\x04\x04\x07\x8c\
    \x08\x12\x04\x8c\x01\x02\x12\n\x0b\n\x03\x04\x04\x07\x12\x04\x8d\x01\x02\
    \x20\n\r\n\x05\x04\x04\x07\x8d\x08\x12\x04\x8d\x01\x02\x20\n\x0b\n\x03\
    \x04\x04\x07\x12\x04\x8e\x01\x02\x1b\n\r\n\x05\x04\x04\x07\x90\x08\x12\
    \x04\x8e\x01\x02\x1b\n\x0c\n\x02\x04\x05\x12\x06\x93\x01\0\x9a\x01\x01\n\
    \x0b\n\x03\x04\x05\x01\x12\x04\x93\x01\x08\x1a\n\x0b\n\x03\x04\x05\x07\
    \x12\x04\x94\x01\x02\x12\n\r\n\x05\x04\x05\x07\x8c\x08\x12\x04\x94\x01\
    \x02\x12\n\x0b\n\x03\x04\x05\x07\x12\x04\x95\x01\x02\x20\n\r\n\x05\x04\
    \x05\x07\x8d\x08\x12\x04\x95\x01\x02\x20\n\x0b\n\x03\x04\x05\x07\x12\x04\
    \x96\x01\x02\x1b\n\r\n\x05\x04\x05\x07\x90\x08\x12\x04\x96\x01\x02\x1b\n\
    \x0c\n\x02\x04\x06\x12\x06\x9c\x01\0\xa0\x01\x01\n\x0b\n\x03\x04\x06\x01\
    \x12\x04\x9c\x01\x08\x13\n\x0b\n\x03\x04\x06\x07\x12\x04\x9d\x01\x02\x12\
    \n\r\n\x05\x04\x06\x07\x8c\x08\x12\x04\x9d\x01\x02\x12\n\x0b\n\x03\x04\
    \x06\x07\x12\x04\x9e\x01\x02\x20\n\x16\n\x05\x04\x06\x07\x8d\x08\x12\x04\
    \x9e\x01\x02\x20\"\x07\x20Empty\n\n\x0c\n\x02\x04\x07\x12\x06\xa2\x01\0\
    \xa6\x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\xa2\x01\x08\x14\n\x0b\n\x03\
    \x04\x07\x07\x12\x04\xa3\x01\x02\x12\n\r\n\x05\x04\x07\x07\x8c\x08\x12\
    \x04\xa3\x01\x02\x12\n\x0b\n\x03\x04\x07\x07\x12\x04\xa4\x01\x02\x20\n\
    \x16\n\x05\x04\x07\x07\x8d\x08\x12\x04\xa4\x01\x02\x20\"\x07\x20Empty\n\
    \n\x0c\n\x02\x04\x08\x12\x06\xa8\x01\0\xac\x01\x01\n\x0b\n\x03\x04\x08\
    \x01\x12\x04\xa8\x01\x08\x19\n\x0b\n\x03\x04\x08\x07\x12\x04\xa9\x01\x02\
    \x12\n\r\n\x05\x04\x08\x07\x8c\x08\x12\x04\xa9\x01\x02\x12\n\x0b\n\x03\
    \x04\x08\x07\x12\x04\xaa\x01\x02\"\n\x16\n\x05\x04\x08\x07\x8d\x08\x12\
    \x04\xaa\x01\x02\"\"\x07\x20Empty\n\n\x0c\n\x02\x04\t\x12\x06\xae\x01\0\
    \xce\x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\xae\x01\x08\x1a\n\x0b\n\x03\
    \x04\t\x07\x12\x04\xaf\x01\x02\x13\n\r\n\x05\x04\t\x07\x8c\x08\x12\x04\
    \xaf\x01\x02\x13\n\x0b\n\x03\x04\t\x07\x12\x04\xb0\x01\x02\"\n\r\n\x05\
    \x04\t\x07\x8d\x08\x12\x04\xb0\x01\x02\"\n\x0c\n\x04\x04\t\x02\0\x12\x04\
    \xb2\x01\x02\x19\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xb2\x01\x02\x06\n\r\n\
    \x05\x04\t\x02\0\x01\x12\x04\xb2\x01\x07\x14\n\r\n\x05\x04\t\x02\0\x03\
    \x12\x04\xb2\x01\x17\x18\n?\n\x04\x04\t\x02\x01\x12\x04\xb5\x01\x02\x12\
    \x1a1\x20The\x20name\x20of\x20the\x20node,\x20given\x20by\x20\"App.set_n\
    ame()\"\n\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\xb5\x01\x02\x08\n\r\n\x05\
    \x04\t\x02\x01\x01\x12\x04\xb5\x01\t\r\n\r\n\x05\x04\t\x02\x01\x03\x12\
    \x04\xb5\x01\x10\x11\nN\n\x04\x04\t\x02\x02\x12\x04\xb8\x01\x02\x19\x1a@\
    \x20The\x20mac\x20address\x20of\x20the\x20device.\x20For\x20example\x20\
    \"AC:BC:32:89:0E:A9\"\n\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\xb8\x01\x02\
    \x08\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xb8\x01\t\x14\n\r\n\x05\x04\t\
    \x02\x02\x03\x12\x04\xb8\x01\x17\x18\nM\n\x04\x04\t\x02\x03\x12\x04\xbb\
    \x01\x02\x1d\x1a?\x20A\x20string\x20describing\x20the\x20ESPHome\x20vers\
    ion.\x20For\x20example\x20\"1.10.0\"\n\n\r\n\x05\x04\t\x02\x03\x05\x12\
    \x04\xbb\x01\x02\x08\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xbb\x01\t\x18\n\
    \r\n\x05\x04\t\x02\x03\x03\x12\x04\xbb\x01\x1b\x1c\n\xd7\x01\n\x04\x04\t\
    \x02\x04\x12\x04\xc0\x01\x02\x1e\x1a\xc8\x01\x20A\x20string\x20describin\
    g\x20the\x20date\x20of\x20compilation,\x20this\x20is\x20generated\x20by\
    \x20the\x20compiler\n\x20and\x20therefore\x20may\x20not\x20be\x20in\x20t\
    he\x20same\x20format\x20all\x20the\x20time.\n\x20If\x20the\x20user\x20is\
    n't\x20using\x20ESPHome,\x20this\x20will\x20also\x20not\x20be\x20set.\n\
    \n\r\n\x05\x04\t\x02\x04\x05\x12\x04\xc0\x01\x02\x08\n\r\n\x05\x04\t\x02\
    \x04\x01\x12\x04\xc0\x01\t\x19\n\r\n\x05\x04\t\x02\x04\x03\x12\x04\xc0\
    \x01\x1c\x1d\n;\n\x04\x04\t\x02\x05\x12\x04\xc3\x01\x02\x13\x1a-\x20The\
    \x20model\x20of\x20the\x20board.\x20For\x20example\x20NodeMCU\n\n\r\n\
    \x05\x04\t\x02\x05\x05\x12\x04\xc3\x01\x02\x08\n\r\n\x05\x04\t\x02\x05\
    \x01\x12\x04\xc3\x01\t\x0e\n\r\n\x05\x04\t\x02\x05\x03\x12\x04\xc3\x01\
    \x11\x12\n\x0c\n\x04\x04\t\x02\x06\x12\x04\xc5\x01\x02\x1a\n\r\n\x05\x04\
    \t\x02\x06\x05\x12\x04\xc5\x01\x02\x06\n\r\n\x05\x04\t\x02\x06\x01\x12\
    \x04\xc5\x01\x07\x15\n\r\n\x05\x04\t\x02\x06\x03\x12\x04\xc5\x01\x18\x19\
    \n2\n\x04\x04\t\x02\x07\x12\x04\xc8\x01\x02\x1a\x1a$\x20The\x20esphome\
    \x20project\x20details\x20if\x20set\n\n\r\n\x05\x04\t\x02\x07\x05\x12\
    \x04\xc8\x01\x02\x08\n\r\n\x05\x04\t\x02\x07\x01\x12\x04\xc8\x01\t\x15\n\
    \r\n\x05\x04\t\x02\x07\x03\x12\x04\xc8\x01\x18\x19\n\x0c\n\x04\x04\t\x02\
    \x08\x12\x04\xc9\x01\x02\x1d\n\r\n\x05\x04\t\x02\x08\x05\x12\x04\xc9\x01\
    \x02\x08\n\r\n\x05\x04\t\x02\x08\x01\x12\x04\xc9\x01\t\x18\n\r\n\x05\x04\
    \t\x02\x08\x03\x12\x04\xc9\x01\x1b\x1c\n\x0c\n\x04\x04\t\x02\t\x12\x04\
    \xcb\x01\x02\x1d\n\r\n\x05\x04\t\x02\t\x05\x12\x04\xcb\x01\x02\x08\n\r\n\
    \x05\x04\t\x02\t\x01\x12\x04\xcb\x01\t\x17\n\r\n\x05\x04\t\x02\t\x03\x12\
    \x04\xcb\x01\x1a\x1c\n\x0c\n\x04\x04\t\x02\n\x12\x04\xcd\x01\x02&\n\r\n\
    \x05\x04\t\x02\n\x05\x12\x04\xcd\x01\x02\x08\n\r\n\x05\x04\t\x02\n\x01\
    \x12\x04\xcd\x01\t\x20\n\r\n\x05\x04\t\x02\n\x03\x12\x04\xcd\x01#%\n\x0c\
    \n\x02\x04\n\x12\x06\xd0\x01\0\xd4\x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\
    \xd0\x01\x08\x1b\n\x0b\n\x03\x04\n\x07\x12\x04\xd1\x01\x02\x13\n\r\n\x05\
    \x04\n\x07\x8c\x08\x12\x04\xd1\x01\x02\x13\n\x0b\n\x03\x04\n\x07\x12\x04\
    \xd2\x01\x02\"\n\x16\n\x05\x04\n\x07\x8d\x08\x12\x04\xd2\x01\x02\"\"\x07\
    \x20Empty\n\n\x0c\n\x02\x04\x0b\x12\x06\xd5\x01\0\xda\x01\x01\n\x0b\n\
    \x03\x04\x0b\x01\x12\x04\xd5\x01\x08\x20\n\x0b\n\x03\x04\x0b\x07\x12\x04\
    \xd6\x01\x02\x13\n\r\n\x05\x04\x0b\x07\x8c\x08\x12\x04\xd6\x01\x02\x13\n\
    \x0b\n\x03\x04\x0b\x07\x12\x04\xd7\x01\x02\"\n\r\n\x05\x04\x0b\x07\x8d\
    \x08\x12\x04\xd7\x01\x02\"\n\x0b\n\x03\x04\x0b\x07\x12\x04\xd8\x01\x02\
    \x1b\n\x16\n\x05\x04\x0b\x07\x90\x08\x12\x04\xd8\x01\x02\x1b\"\x07\x20Em\
    pty\n\n\x0c\n\x02\x04\x0c\x12\x06\xdb\x01\0\xdf\x01\x01\n\x0b\n\x03\x04\
    \x0c\x01\x12\x04\xdb\x01\x08\x1e\n\x0b\n\x03\x04\x0c\x07\x12\x04\xdc\x01\
    \x02\x13\n\r\n\x05\x04\x0c\x07\x8c\x08\x12\x04\xdc\x01\x02\x13\n\x0b\n\
    \x03\x04\x0c\x07\x12\x04\xdd\x01\x02\"\n\x16\n\x05\x04\x0c\x07\x8d\x08\
    \x12\x04\xdd\x01\x02\"\"\x07\x20Empty\n\nA\n\x02\x05\0\x12\x06\xe3\x01\0\
    \xe7\x01\x0123\x20====================\x20COMMON\x20====================\
    =\n\n\x0b\n\x03\x05\0\x01\x12\x04\xe3\x01\x05\x13\n\x0c\n\x04\x05\0\x02\
    \0\x12\x04\xe4\x01\x02\x1b\n\r\n\x05\x05\0\x02\0\x01\x12\x04\xe4\x01\x02\
    \x16\n\r\n\x05\x05\0\x02\0\x02\x12\x04\xe4\x01\x19\x1a\n\x0c\n\x04\x05\0\
    \x02\x01\x12\x04\xe5\x01\x02\x1d\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\xe5\
    \x01\x02\x18\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\xe5\x01\x1b\x1c\n\x0c\n\
    \x04\x05\0\x02\x02\x12\x04\xe6\x01\x02!\n\r\n\x05\x05\0\x02\x02\x01\x12\
    \x04\xe6\x01\x02\x1c\n\r\n\x05\x05\0\x02\x02\x02\x12\x04\xe6\x01\x1f\x20\
    \nG\n\x02\x04\r\x12\x06\xea\x01\0\xf9\x01\x01\x1a9\x20==================\
    ==\x20BINARY\x20SENSOR\x20====================\n\n\x0b\n\x03\x04\r\x01\
    \x12\x04\xea\x01\x08(\n\x0b\n\x03\x04\r\x07\x12\x04\xeb\x01\x02\x13\n\r\
    \n\x05\x04\r\x07\x8c\x08\x12\x04\xeb\x01\x02\x13\n\x0b\n\x03\x04\r\x07\
    \x12\x04\xec\x01\x02\"\n\r\n\x05\x04\r\x07\x8d\x08\x12\x04\xec\x01\x02\"\
    \n\x0b\n\x03\x04\r\x07\x12\x04\xed\x01\x02'\n\r\n\x05\x04\r\x07\x8e\x08\
    \x12\x04\xed\x01\x02'\n\x0c\n\x04\x04\r\x02\0\x12\x04\xef\x01\x02\x17\n\
    \r\n\x05\x04\r\x02\0\x05\x12\x04\xef\x01\x02\x08\n\r\n\x05\x04\r\x02\0\
    \x01\x12\x04\xef\x01\t\x12\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xef\x01\x15\
    \x16\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xf0\x01\x02\x12\n\r\n\x05\x04\r\
    \x02\x01\x05\x12\x04\xf0\x01\x02\t\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\
    \xf0\x01\n\r\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xf0\x01\x10\x11\n\x0c\n\
    \x04\x04\r\x02\x02\x12\x04\xf1\x01\x02\x12\n\r\n\x05\x04\r\x02\x02\x05\
    \x12\x04\xf1\x01\x02\x08\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\xf1\x01\t\r\
    \n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xf1\x01\x10\x11\n\x0c\n\x04\x04\r\
    \x02\x03\x12\x04\xf2\x01\x02\x17\n\r\n\x05\x04\r\x02\x03\x05\x12\x04\xf2\
    \x01\x02\x08\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\xf2\x01\t\x12\n\r\n\x05\
    \x04\r\x02\x03\x03\x12\x04\xf2\x01\x15\x16\n\x0c\n\x04\x04\r\x02\x04\x12\
    \x04\xf4\x01\x02\x1a\n\r\n\x05\x04\r\x02\x04\x05\x12\x04\xf4\x01\x02\x08\
    \n\r\n\x05\x04\r\x02\x04\x01\x12\x04\xf4\x01\t\x15\n\r\n\x05\x04\r\x02\
    \x04\x03\x12\x04\xf4\x01\x18\x19\n\x0c\n\x04\x04\r\x02\x05\x12\x04\xf5\
    \x01\x02#\n\r\n\x05\x04\r\x02\x05\x05\x12\x04\xf5\x01\x02\x06\n\r\n\x05\
    \x04\r\x02\x05\x01\x12\x04\xf5\x01\x07\x1e\n\r\n\x05\x04\r\x02\x05\x03\
    \x12\x04\xf5\x01!\"\n\x0c\n\x04\x04\r\x02\x06\x12\x04\xf6\x01\x02\x1f\n\
    \r\n\x05\x04\r\x02\x06\x05\x12\x04\xf6\x01\x02\x06\n\r\n\x05\x04\r\x02\
    \x06\x01\x12\x04\xf6\x01\x07\x1a\n\r\n\x05\x04\r\x02\x06\x03\x12\x04\xf6\
    \x01\x1d\x1e\n\x0c\n\x04\x04\r\x02\x07\x12\x04\xf7\x01\x02\x12\n\r\n\x05\
    \x04\r\x02\x07\x05\x12\x04\xf7\x01\x02\x08\n\r\n\x05\x04\r\x02\x07\x01\
    \x12\x04\xf7\x01\t\r\n\r\n\x05\x04\r\x02\x07\x03\x12\x04\xf7\x01\x10\x11\
    \n\x0c\n\x04\x04\r\x02\x08\x12\x04\xf8\x01\x02%\n\r\n\x05\x04\r\x02\x08\
    \x06\x12\x04\xf8\x01\x02\x10\n\r\n\x05\x04\r\x02\x08\x01\x12\x04\xf8\x01\
    \x11\x20\n\r\n\x05\x04\r\x02\x08\x03\x12\x04\xf8\x01#$\n\x0c\n\x02\x04\
    \x0e\x12\x06\xfa\x01\0\x85\x02\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xfa\
    \x01\x08!\n\x0b\n\x03\x04\x0e\x07\x12\x04\xfb\x01\x02\x13\n\r\n\x05\x04\
    \x0e\x07\x8c\x08\x12\x04\xfb\x01\x02\x13\n\x0b\n\x03\x04\x0e\x07\x12\x04\
    \xfc\x01\x02\"\n\r\n\x05\x04\x0e\x07\x8d\x08\x12\x04\xfc\x01\x02\"\n\x0b\
    \n\x03\x04\x0e\x07\x12\x04\xfd\x01\x02'\n\r\n\x05\x04\x0e\x07\x8e\x08\
    \x12\x04\xfd\x01\x02'\n\x0b\n\x03\x04\x0e\x07\x12\x04\xfe\x01\x02\x1b\n\
    \r\n\x05\x04\x0e\x07\x90\x08\x12\x04\xfe\x01\x02\x1b\n\x0c\n\x04\x04\x0e\
    \x02\0\x12\x04\x80\x02\x02\x12\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\x80\
    \x02\x02\t\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\x80\x02\n\r\n\r\n\x05\x04\
    \x0e\x02\0\x03\x12\x04\x80\x02\x10\x11\n\x0c\n\x04\x04\x0e\x02\x01\x12\
    \x04\x81\x02\x02\x11\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\x81\x02\x02\
    \x06\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\x81\x02\x07\x0c\n\r\n\x05\x04\
    \x0e\x02\x01\x03\x12\x04\x81\x02\x0f\x10\n\x97\x01\n\x04\x04\x0e\x02\x02\
    \x12\x04\x84\x02\x02\x19\x1a\x88\x01\x20If\x20the\x20binary\x20sensor\
    \x20does\x20not\x20have\x20a\x20valid\x20state\x20yet.\n\x20Equivalent\
    \x20to\x20`!obj->has_state()`\x20-\x20inverse\x20logic\x20to\x20make\x20\
    state\x20packets\x20smaller\n\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\x84\
    \x02\x02\x06\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\x84\x02\x07\x14\n\r\n\
    \x05\x04\x0e\x02\x02\x03\x12\x04\x84\x02\x17\x18\n?\n\x02\x04\x0f\x12\
    \x06\x88\x02\0\x99\x02\x01\x1a1\x20====================\x20COVER\x20====\
    ================\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\x88\x02\x08!\n\x0b\n\
    \x03\x04\x0f\x07\x12\x04\x89\x02\x02\x13\n\r\n\x05\x04\x0f\x07\x8c\x08\
    \x12\x04\x89\x02\x02\x13\n\x0b\n\x03\x04\x0f\x07\x12\x04\x8a\x02\x02\"\n\
    \r\n\x05\x04\x0f\x07\x8d\x08\x12\x04\x8a\x02\x02\"\n\x0b\n\x03\x04\x0f\
    \x07\x12\x04\x8b\x02\x02\x1f\n\r\n\x05\x04\x0f\x07\x8e\x08\x12\x04\x8b\
    \x02\x02\x1f\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\x8d\x02\x02\x17\n\r\n\x05\
    \x04\x0f\x02\0\x05\x12\x04\x8d\x02\x02\x08\n\r\n\x05\x04\x0f\x02\0\x01\
    \x12\x04\x8d\x02\t\x12\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\x8d\x02\x15\
    \x16\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\x8e\x02\x02\x12\n\r\n\x05\x04\
    \x0f\x02\x01\x05\x12\x04\x8e\x02\x02\t\n\r\n\x05\x04\x0f\x02\x01\x01\x12\
    \x04\x8e\x02\n\r\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\x8e\x02\x10\x11\n\
    \x0c\n\x04\x04\x0f\x02\x02\x12\x04\x8f\x02\x02\x12\n\r\n\x05\x04\x0f\x02\
    \x02\x05\x12\x04\x8f\x02\x02\x08\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\
    \x8f\x02\t\r\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\x8f\x02\x10\x11\n\x0c\
    \n\x04\x04\x0f\x02\x03\x12\x04\x90\x02\x02\x17\n\r\n\x05\x04\x0f\x02\x03\
    \x05\x12\x04\x90\x02\x02\x08\n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\x90\
    \x02\t\x12\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\x90\x02\x15\x16\n\x0c\n\
    \x04\x04\x0f\x02\x04\x12\x04\x92\x02\x02\x19\n\r\n\x05\x04\x0f\x02\x04\
    \x05\x12\x04\x92\x02\x02\x06\n\r\n\x05\x04\x0f\x02\x04\x01\x12\x04\x92\
    \x02\x07\x14\n\r\n\x05\x04\x0f\x02\x04\x03\x12\x04\x92\x02\x17\x18\n\x0c\
    \n\x04\x04\x0f\x02\x05\x12\x04\x93\x02\x02\x1d\n\r\n\x05\x04\x0f\x02\x05\
    \x05\x12\x04\x93\x02\x02\x06\n\r\n\x05\x04\x0f\x02\x05\x01\x12\x04\x93\
    \x02\x07\x18\n\r\n\x05\x04\x0f\x02\x05\x03\x12\x04\x93\x02\x1b\x1c\n\x0c\
    \n\x04\x04\x0f\x02\x06\x12\x04\x94\x02\x02\x19\n\r\n\x05\x04\x0f\x02\x06\
    \x05\x12\x04\x94\x02\x02\x06\n\r\n\x05\x04\x0f\x02\x06\x01\x12\x04\x94\
    \x02\x07\x14\n\r\n\x05\x04\x0f\x02\x06\x03\x12\x04\x94\x02\x17\x18\n\x0c\
    \n\x04\x04\x0f\x02\x07\x12\x04\x95\x02\x02\x1a\n\r\n\x05\x04\x0f\x02\x07\
    \x05\x12\x04\x95\x02\x02\x08\n\r\n\x05\x04\x0f\x02\x07\x01\x12\x04\x95\
    \x02\t\x15\n\r\n\x05\x04\x0f\x02\x07\x03\x12\x04\x95\x02\x18\x19\n\x0c\n\
    \x04\x04\x0f\x02\x08\x12\x04\x96\x02\x02\x1f\n\r\n\x05\x04\x0f\x02\x08\
    \x05\x12\x04\x96\x02\x02\x06\n\r\n\x05\x04\x0f\x02\x08\x01\x12\x04\x96\
    \x02\x07\x1a\n\r\n\x05\x04\x0f\x02\x08\x03\x12\x04\x96\x02\x1d\x1e\n\x0c\
    \n\x04\x04\x0f\x02\t\x12\x04\x97\x02\x02\x13\n\r\n\x05\x04\x0f\x02\t\x05\
    \x12\x04\x97\x02\x02\x08\n\r\n\x05\x04\x0f\x02\t\x01\x12\x04\x97\x02\t\r\
    \n\r\n\x05\x04\x0f\x02\t\x03\x12\x04\x97\x02\x10\x12\n\x0c\n\x04\x04\x0f\
    \x02\n\x12\x04\x98\x02\x02&\n\r\n\x05\x04\x0f\x02\n\x06\x12\x04\x98\x02\
    \x02\x10\n\r\n\x05\x04\x0f\x02\n\x01\x12\x04\x98\x02\x11\x20\n\r\n\x05\
    \x04\x0f\x02\n\x03\x12\x04\x98\x02#%\n\x0c\n\x02\x05\x01\x12\x06\x9b\x02\
    \0\x9e\x02\x01\n\x0b\n\x03\x05\x01\x01\x12\x04\x9b\x02\x05\x15\n\x0c\n\
    \x04\x05\x01\x02\0\x12\x04\x9c\x02\x02\x1e\n\r\n\x05\x05\x01\x02\0\x01\
    \x12\x04\x9c\x02\x02\x19\n\r\n\x05\x05\x01\x02\0\x02\x12\x04\x9c\x02\x1c\
    \x1d\n\x0c\n\x04\x05\x01\x02\x01\x12\x04\x9d\x02\x02\x20\n\r\n\x05\x05\
    \x01\x02\x01\x01\x12\x04\x9d\x02\x02\x1b\n\r\n\x05\x05\x01\x02\x01\x02\
    \x12\x04\x9d\x02\x1e\x1f\n\x0c\n\x02\x05\x02\x12\x06\x9f\x02\0\xa3\x02\
    \x01\n\x0b\n\x03\x05\x02\x01\x12\x04\x9f\x02\x05\x13\n\x0c\n\x04\x05\x02\
    \x02\0\x12\x04\xa0\x02\x02\x1b\n\r\n\x05\x05\x02\x02\0\x01\x12\x04\xa0\
    \x02\x02\x16\n\r\n\x05\x05\x02\x02\0\x02\x12\x04\xa0\x02\x19\x1a\n\x0c\n\
    \x04\x05\x02\x02\x01\x12\x04\xa1\x02\x02!\n\r\n\x05\x05\x02\x02\x01\x01\
    \x12\x04\xa1\x02\x02\x1c\n\r\n\x05\x05\x02\x02\x01\x02\x12\x04\xa1\x02\
    \x1f\x20\n\x0c\n\x04\x05\x02\x02\x02\x12\x04\xa2\x02\x02!\n\r\n\x05\x05\
    \x02\x02\x02\x01\x12\x04\xa2\x02\x02\x1c\n\r\n\x05\x05\x02\x02\x02\x02\
    \x12\x04\xa2\x02\x1f\x20\n\x0c\n\x02\x04\x10\x12\x06\xa4\x02\0\xb2\x02\
    \x01\n\x0b\n\x03\x04\x10\x01\x12\x04\xa4\x02\x08\x1a\n\x0b\n\x03\x04\x10\
    \x07\x12\x04\xa5\x02\x02\x13\n\r\n\x05\x04\x10\x07\x8c\x08\x12\x04\xa5\
    \x02\x02\x13\n\x0b\n\x03\x04\x10\x07\x12\x04\xa6\x02\x02\"\n\r\n\x05\x04\
    \x10\x07\x8d\x08\x12\x04\xa6\x02\x02\"\n\x0b\n\x03\x04\x10\x07\x12\x04\
    \xa7\x02\x02\x1f\n\r\n\x05\x04\x10\x07\x8e\x08\x12\x04\xa7\x02\x02\x1f\n\
    \x0b\n\x03\x04\x10\x07\x12\x04\xa8\x02\x02\x1b\n\r\n\x05\x04\x10\x07\x90\
    \x08\x12\x04\xa8\x02\x02\x1b\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xaa\x02\
    \x02\x12\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xaa\x02\x02\t\n\r\n\x05\x04\
    \x10\x02\0\x01\x12\x04\xaa\x02\n\r\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\
    \xaa\x02\x10\x11\n\x80\x01\n\x04\x04\x10\x02\x01\x12\x04\xad\x02\x02$\
    \x1ar\x20legacy:\x20state\x20has\x20been\x20removed\x20in\x201.13\n\x20c\
    lients/servers\x20must\x20still\x20send/accept\x20it\x20until\x20the\x20\
    next\x20protocol\x20change\n\n\r\n\x05\x04\x10\x02\x01\x06\x12\x04\xad\
    \x02\x02\x12\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xad\x02\x13\x1f\n\r\n\
    \x05\x04\x10\x02\x01\x03\x12\x04\xad\x02\"#\n\x0c\n\x04\x04\x10\x02\x02\
    \x12\x04\xaf\x02\x02\x15\n\r\n\x05\x04\x10\x02\x02\x05\x12\x04\xaf\x02\
    \x02\x07\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xaf\x02\x08\x10\n\r\n\x05\
    \x04\x10\x02\x02\x03\x12\x04\xaf\x02\x13\x14\n\x0c\n\x04\x04\x10\x02\x03\
    \x12\x04\xb0\x02\x02\x11\n\r\n\x05\x04\x10\x02\x03\x05\x12\x04\xb0\x02\
    \x02\x07\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xb0\x02\x08\x0c\n\r\n\x05\
    \x04\x10\x02\x03\x03\x12\x04\xb0\x02\x0f\x10\n\x0c\n\x04\x04\x10\x02\x04\
    \x12\x04\xb1\x02\x02'\n\r\n\x05\x04\x10\x02\x04\x06\x12\x04\xb1\x02\x02\
    \x10\n\r\n\x05\x04\x10\x02\x04\x01\x12\x04\xb1\x02\x11\"\n\r\n\x05\x04\
    \x10\x02\x04\x03\x12\x04\xb1\x02%&\n\x0c\n\x02\x05\x03\x12\x06\xb4\x02\0\
    \xb8\x02\x01\n\x0b\n\x03\x05\x03\x01\x12\x04\xb4\x02\x05\x17\n\x0c\n\x04\
    \x05\x03\x02\0\x12\x04\xb5\x02\x02\x20\n\r\n\x05\x05\x03\x02\0\x01\x12\
    \x04\xb5\x02\x02\x1b\n\r\n\x05\x05\x03\x02\0\x02\x12\x04\xb5\x02\x1e\x1f\
    \n\x0c\n\x04\x05\x03\x02\x01\x12\x04\xb6\x02\x02!\n\r\n\x05\x05\x03\x02\
    \x01\x01\x12\x04\xb6\x02\x02\x1c\n\r\n\x05\x05\x03\x02\x01\x02\x12\x04\
    \xb6\x02\x1f\x20\n\x0c\n\x04\x05\x03\x02\x02\x12\x04\xb7\x02\x02\x20\n\r\
    \n\x05\x05\x03\x02\x02\x01\x12\x04\xb7\x02\x02\x1b\n\r\n\x05\x05\x03\x02\
    \x02\x02\x12\x04\xb7\x02\x1e\x1f\n\x0c\n\x02\x04\x11\x12\x06\xb9\x02\0\
    \xcb\x02\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xb9\x02\x08\x1b\n\x0b\n\x03\
    \x04\x11\x07\x12\x04\xba\x02\x02\x13\n\r\n\x05\x04\x11\x07\x8c\x08\x12\
    \x04\xba\x02\x02\x13\n\x0b\n\x03\x04\x11\x07\x12\x04\xbb\x02\x02\"\n\r\n\
    \x05\x04\x11\x07\x8d\x08\x12\x04\xbb\x02\x02\"\n\x0b\n\x03\x04\x11\x07\
    \x12\x04\xbc\x02\x02\x1f\n\r\n\x05\x04\x11\x07\x8e\x08\x12\x04\xbc\x02\
    \x02\x1f\n\x0b\n\x03\x04\x11\x07\x12\x04\xbd\x02\x02\x1b\n\r\n\x05\x04\
    \x11\x07\x90\x08\x12\x04\xbd\x02\x02\x1b\n\x0c\n\x04\x04\x11\x02\0\x12\
    \x04\xbf\x02\x02\x12\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xbf\x02\x02\t\n\
    \r\n\x05\x04\x11\x02\0\x01\x12\x04\xbf\x02\n\r\n\r\n\x05\x04\x11\x02\0\
    \x03\x12\x04\xbf\x02\x10\x11\n\x82\x01\n\x04\x04\x11\x02\x01\x12\x04\xc3\
    \x02\x02\x1e\x1at\x20legacy:\x20command\x20has\x20been\x20removed\x20in\
    \x201.13\n\x20clients/servers\x20must\x20still\x20send/accept\x20it\x20u\
    ntil\x20the\x20next\x20protocol\x20change\n\n\r\n\x05\x04\x11\x02\x01\
    \x05\x12\x04\xc3\x02\x02\x06\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xc3\
    \x02\x07\x19\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xc3\x02\x1c\x1d\n\x0c\
    \n\x04\x04\x11\x02\x02\x12\x04\xc4\x02\x02(\n\r\n\x05\x04\x11\x02\x02\
    \x06\x12\x04\xc4\x02\x02\x14\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xc4\
    \x02\x15#\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xc4\x02&'\n\x0c\n\x04\
    \x04\x11\x02\x03\x12\x04\xc6\x02\x02\x18\n\r\n\x05\x04\x11\x02\x03\x05\
    \x12\x04\xc6\x02\x02\x06\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\xc6\x02\
    \x07\x13\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\xc6\x02\x16\x17\n\x0c\n\
    \x04\x04\x11\x02\x04\x12\x04\xc7\x02\x02\x15\n\r\n\x05\x04\x11\x02\x04\
    \x05\x12\x04\xc7\x02\x02\x07\n\r\n\x05\x04\x11\x02\x04\x01\x12\x04\xc7\
    \x02\x08\x10\n\r\n\x05\x04\x11\x02\x04\x03\x12\x04\xc7\x02\x13\x14\n\x0c\
    \n\x04\x04\x11\x02\x05\x12\x04\xc8\x02\x02\x14\n\r\n\x05\x04\x11\x02\x05\
    \x05\x12\x04\xc8\x02\x02\x06\n\r\n\x05\x04\x11\x02\x05\x01\x12\x04\xc8\
    \x02\x07\x0f\n\r\n\x05\x04\x11\x02\x05\x03\x12\x04\xc8\x02\x12\x13\n\x0c\
    \n\x04\x04\x11\x02\x06\x12\x04\xc9\x02\x02\x11\n\r\n\x05\x04\x11\x02\x06\
    \x05\x12\x04\xc9\x02\x02\x07\n\r\n\x05\x04\x11\x02\x06\x01\x12\x04\xc9\
    \x02\x08\x0c\n\r\n\x05\x04\x11\x02\x06\x03\x12\x04\xc9\x02\x0f\x10\n\x0c\
    \n\x04\x04\x11\x02\x07\x12\x04\xca\x02\x02\x10\n\r\n\x05\x04\x11\x02\x07\
    \x05\x12\x04\xca\x02\x02\x06\n\r\n\x05\x04\x11\x02\x07\x01\x12\x04\xca\
    \x02\x07\x0b\n\r\n\x05\x04\x11\x02\x07\x03\x12\x04\xca\x02\x0e\x0f\n=\n\
    \x02\x04\x12\x12\x06\xce\x02\0\xdf\x02\x01\x1a/\x20====================\
    \x20FAN\x20====================\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xce\
    \x02\x08\x1f\n\x0b\n\x03\x04\x12\x07\x12\x04\xcf\x02\x02\x13\n\r\n\x05\
    \x04\x12\x07\x8c\x08\x12\x04\xcf\x02\x02\x13\n\x0b\n\x03\x04\x12\x07\x12\
    \x04\xd0\x02\x02\"\n\r\n\x05\x04\x12\x07\x8d\x08\x12\x04\xd0\x02\x02\"\n\
    \x0b\n\x03\x04\x12\x07\x12\x04\xd1\x02\x02\x1d\n\r\n\x05\x04\x12\x07\x8e\
    \x08\x12\x04\xd1\x02\x02\x1d\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xd3\x02\
    \x02\x17\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xd3\x02\x02\x08\n\r\n\x05\
    \x04\x12\x02\0\x01\x12\x04\xd3\x02\t\x12\n\r\n\x05\x04\x12\x02\0\x03\x12\
    \x04\xd3\x02\x15\x16\n\x0c\n\x04\x04\x12\x02\x01\x12\x04\xd4\x02\x02\x12\
    \n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xd4\x02\x02\t\n\r\n\x05\x04\x12\
    \x02\x01\x01\x12\x04\xd4\x02\n\r\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\
    \xd4\x02\x10\x11\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\xd5\x02\x02\x12\n\r\
    \n\x05\x04\x12\x02\x02\x05\x12\x04\xd5\x02\x02\x08\n\r\n\x05\x04\x12\x02\
    \x02\x01\x12\x04\xd5\x02\t\r\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xd5\
    \x02\x10\x11\n\x0c\n\x04\x04\x12\x02\x03\x12\x04\xd6\x02\x02\x17\n\r\n\
    \x05\x04\x12\x02\x03\x05\x12\x04\xd6\x02\x02\x08\n\r\n\x05\x04\x12\x02\
    \x03\x01\x12\x04\xd6\x02\t\x12\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\xd6\
    \x02\x15\x16\n\x0c\n\x04\x04\x12\x02\x04\x12\x04\xd8\x02\x02\x20\n\r\n\
    \x05\x04\x12\x02\x04\x05\x12\x04\xd8\x02\x02\x06\n\r\n\x05\x04\x12\x02\
    \x04\x01\x12\x04\xd8\x02\x07\x1b\n\r\n\x05\x04\x12\x02\x04\x03\x12\x04\
    \xd8\x02\x1e\x1f\n\x0c\n\x04\x04\x12\x02\x05\x12\x04\xd9\x02\x02\x1a\n\r\
    \n\x05\x04\x12\x02\x05\x05\x12\x04\xd9\x02\x02\x06\n\r\n\x05\x04\x12\x02\
    \x05\x01\x12\x04\xd9\x02\x07\x15\n\r\n\x05\x04\x12\x02\x05\x03\x12\x04\
    \xd9\x02\x18\x19\n\x0c\n\x04\x04\x12\x02\x06\x12\x04\xda\x02\x02\x1e\n\r\
    \n\x05\x04\x12\x02\x06\x05\x12\x04\xda\x02\x02\x06\n\r\n\x05\x04\x12\x02\
    \x06\x01\x12\x04\xda\x02\x07\x19\n\r\n\x05\x04\x12\x02\x06\x03\x12\x04\
    \xda\x02\x1c\x1d\n\x0c\n\x04\x04\x12\x02\x07\x12\x04\xdb\x02\x02\"\n\r\n\
    \x05\x04\x12\x02\x07\x05\x12\x04\xdb\x02\x02\x07\n\r\n\x05\x04\x12\x02\
    \x07\x01\x12\x04\xdb\x02\x08\x1d\n\r\n\x05\x04\x12\x02\x07\x03\x12\x04\
    \xdb\x02\x20!\n\x0c\n\x04\x04\x12\x02\x08\x12\x04\xdc\x02\x02\x1f\n\r\n\
    \x05\x04\x12\x02\x08\x05\x12\x04\xdc\x02\x02\x06\n\r\n\x05\x04\x12\x02\
    \x08\x01\x12\x04\xdc\x02\x07\x1a\n\r\n\x05\x04\x12\x02\x08\x03\x12\x04\
    \xdc\x02\x1d\x1e\n\x0c\n\x04\x04\x12\x02\t\x12\x04\xdd\x02\x02\x13\n\r\n\
    \x05\x04\x12\x02\t\x05\x12\x04\xdd\x02\x02\x08\n\r\n\x05\x04\x12\x02\t\
    \x01\x12\x04\xdd\x02\t\r\n\r\n\x05\x04\x12\x02\t\x03\x12\x04\xdd\x02\x10\
    \x12\n\x0c\n\x04\x04\x12\x02\n\x12\x04\xde\x02\x02&\n\r\n\x05\x04\x12\
    \x02\n\x06\x12\x04\xde\x02\x02\x10\n\r\n\x05\x04\x12\x02\n\x01\x12\x04\
    \xde\x02\x11\x20\n\r\n\x05\x04\x12\x02\n\x03\x12\x04\xde\x02#%\n\x0c\n\
    \x02\x05\x04\x12\x06\xe0\x02\0\xe4\x02\x01\n\x0b\n\x03\x05\x04\x01\x12\
    \x04\xe0\x02\x05\r\n\x0c\n\x04\x05\x04\x02\0\x12\x04\xe1\x02\x02\x14\n\r\
    \n\x05\x05\x04\x02\0\x01\x12\x04\xe1\x02\x02\x0f\n\r\n\x05\x05\x04\x02\0\
    \x02\x12\x04\xe1\x02\x12\x13\n\x0c\n\x04\x05\x04\x02\x01\x12\x04\xe2\x02\
    \x02\x17\n\r\n\x05\x05\x04\x02\x01\x01\x12\x04\xe2\x02\x02\x12\n\r\n\x05\
    \x05\x04\x02\x01\x02\x12\x04\xe2\x02\x15\x16\n\x0c\n\x04\x05\x04\x02\x02\
    \x12\x04\xe3\x02\x02\x15\n\r\n\x05\x05\x04\x02\x02\x01\x12\x04\xe3\x02\
    \x02\x10\n\r\n\x05\x05\x04\x02\x02\x02\x12\x04\xe3\x02\x13\x14\n\x0c\n\
    \x02\x05\x05\x12\x06\xe5\x02\0\xe8\x02\x01\n\x0b\n\x03\x05\x05\x01\x12\
    \x04\xe5\x02\x05\x11\n\x0c\n\x04\x05\x05\x02\0\x12\x04\xe6\x02\x02\x1c\n\
    \r\n\x05\x05\x05\x02\0\x01\x12\x04\xe6\x02\x02\x17\n\r\n\x05\x05\x05\x02\
    \0\x02\x12\x04\xe6\x02\x1a\x1b\n\x0c\n\x04\x05\x05\x02\x01\x12\x04\xe7\
    \x02\x02\x1c\n\r\n\x05\x05\x05\x02\x01\x01\x12\x04\xe7\x02\x02\x17\n\r\n\
    \x05\x05\x05\x02\x01\x02\x12\x04\xe7\x02\x1a\x1b\n\x0c\n\x02\x04\x13\x12\
    \x06\xe9\x02\0\xf5\x02\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\xe9\x02\x08\
    \x18\n\x0b\n\x03\x04\x13\x07\x12\x04\xea\x02\x02\x13\n\r\n\x05\x04\x13\
    \x07\x8c\x08\x12\x04\xea\x02\x02\x13\n\x0b\n\x03\x04\x13\x07\x12\x04\xeb\
    \x02\x02\"\n\r\n\x05\x04\x13\x07\x8d\x08\x12\x04\xeb\x02\x02\"\n\x0b\n\
    \x03\x04\x13\x07\x12\x04\xec\x02\x02\x1d\n\r\n\x05\x04\x13\x07\x8e\x08\
    \x12\x04\xec\x02\x02\x1d\n\x0b\n\x03\x04\x13\x07\x12\x04\xed\x02\x02\x1b\
    \n\r\n\x05\x04\x13\x07\x90\x08\x12\x04\xed\x02\x02\x1b\n\x0c\n\x04\x04\
    \x13\x02\0\x12\x04\xef\x02\x02\x12\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\
    \xef\x02\x02\t\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xef\x02\n\r\n\r\n\x05\
    \x04\x13\x02\0\x03\x12\x04\xef\x02\x10\x11\n\x0c\n\x04\x04\x13\x02\x01\
    \x12\x04\xf0\x02\x02\x11\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\xf0\x02\
    \x02\x06\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xf0\x02\x07\x0c\n\r\n\x05\
    \x04\x13\x02\x01\x03\x12\x04\xf0\x02\x0f\x10\n\x0c\n\x04\x04\x13\x02\x02\
    \x12\x04\xf1\x02\x02\x17\n\r\n\x05\x04\x13\x02\x02\x05\x12\x04\xf1\x02\
    \x02\x06\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xf1\x02\x07\x12\n\r\n\x05\
    \x04\x13\x02\x02\x03\x12\x04\xf1\x02\x15\x16\n\x0c\n\x04\x04\x13\x02\x03\
    \x12\x04\xf2\x02\x02)\n\r\n\x05\x04\x13\x02\x03\x06\x12\x04\xf2\x02\x02\
    \n\n\r\n\x05\x04\x13\x02\x03\x01\x12\x04\xf2\x02\x0b\x10\n\r\n\x05\x04\
    \x13\x02\x03\x03\x12\x04\xf2\x02\x13\x14\n\r\n\x05\x04\x13\x02\x03\x08\
    \x12\x04\xf2\x02\x15(\n\x0e\n\x06\x04\x13\x02\x03\x08\x03\x12\x04\xf2\
    \x02\x16'\n\x0c\n\x04\x04\x13\x02\x04\x12\x04\xf3\x02\x02\x1d\n\r\n\x05\
    \x04\x13\x02\x04\x06\x12\x04\xf3\x02\x02\x0e\n\r\n\x05\x04\x13\x02\x04\
    \x01\x12\x04\xf3\x02\x0f\x18\n\r\n\x05\x04\x13\x02\x04\x03\x12\x04\xf3\
    \x02\x1b\x1c\n\x0c\n\x04\x04\x13\x02\x05\x12\x04\xf4\x02\x02\x18\n\r\n\
    \x05\x04\x13\x02\x05\x05\x12\x04\xf4\x02\x02\x07\n\r\n\x05\x04\x13\x02\
    \x05\x01\x12\x04\xf4\x02\x08\x13\n\r\n\x05\x04\x13\x02\x05\x03\x12\x04\
    \xf4\x02\x16\x17\n\x0c\n\x02\x04\x14\x12\x06\xf6\x02\0\x87\x03\x01\n\x0b\
    \n\x03\x04\x14\x01\x12\x04\xf6\x02\x08\x19\n\x0b\n\x03\x04\x14\x07\x12\
    \x04\xf7\x02\x02\x13\n\r\n\x05\x04\x14\x07\x8c\x08\x12\x04\xf7\x02\x02\
    \x13\n\x0b\n\x03\x04\x14\x07\x12\x04\xf8\x02\x02\"\n\r\n\x05\x04\x14\x07\
    \x8d\x08\x12\x04\xf8\x02\x02\"\n\x0b\n\x03\x04\x14\x07\x12\x04\xf9\x02\
    \x02\x1d\n\r\n\x05\x04\x14\x07\x8e\x08\x12\x04\xf9\x02\x02\x1d\n\x0b\n\
    \x03\x04\x14\x07\x12\x04\xfa\x02\x02\x1b\n\r\n\x05\x04\x14\x07\x90\x08\
    \x12\x04\xfa\x02\x02\x1b\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xfc\x02\x02\
    \x12\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xfc\x02\x02\t\n\r\n\x05\x04\x14\
    \x02\0\x01\x12\x04\xfc\x02\n\r\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xfc\
    \x02\x10\x11\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\xfd\x02\x02\x15\n\r\n\
    \x05\x04\x14\x02\x01\x05\x12\x04\xfd\x02\x02\x06\n\r\n\x05\x04\x14\x02\
    \x01\x01\x12\x04\xfd\x02\x07\x10\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\
    \xfd\x02\x13\x14\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\xfe\x02\x02\x11\n\r\
    \n\x05\x04\x14\x02\x02\x05\x12\x04\xfe\x02\x02\x06\n\r\n\x05\x04\x14\x02\
    \x02\x01\x12\x04\xfe\x02\x07\x0c\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\
    \xfe\x02\x0f\x10\n\x0c\n\x04\x04\x14\x02\x03\x12\x04\xff\x02\x02)\n\r\n\
    \x05\x04\x14\x02\x03\x05\x12\x04\xff\x02\x02\x06\n\r\n\x05\x04\x14\x02\
    \x03\x01\x12\x04\xff\x02\x07\x10\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\
    \xff\x02\x13\x14\n\r\n\x05\x04\x14\x02\x03\x08\x12\x04\xff\x02\x15(\n\
    \x0e\n\x06\x04\x14\x02\x03\x08\x03\x12\x04\xff\x02\x16'\n\x0c\n\x04\x04\
    \x14\x02\x04\x12\x04\x80\x03\x02)\n\r\n\x05\x04\x14\x02\x04\x06\x12\x04\
    \x80\x03\x02\n\n\r\n\x05\x04\x14\x02\x04\x01\x12\x04\x80\x03\x0b\x10\n\r\
    \n\x05\x04\x14\x02\x04\x03\x12\x04\x80\x03\x13\x14\n\r\n\x05\x04\x14\x02\
    \x04\x08\x12\x04\x80\x03\x15(\n\x0e\n\x06\x04\x14\x02\x04\x08\x03\x12\
    \x04\x80\x03\x16'\n\x0c\n\x04\x04\x14\x02\x05\x12\x04\x81\x03\x02\x1b\n\
    \r\n\x05\x04\x14\x02\x05\x05\x12\x04\x81\x03\x02\x06\n\r\n\x05\x04\x14\
    \x02\x05\x01\x12\x04\x81\x03\x07\x16\n\r\n\x05\x04\x14\x02\x05\x03\x12\
    \x04\x81\x03\x19\x1a\n\x0c\n\x04\x04\x14\x02\x06\x12\x04\x82\x03\x02\x17\
    \n\r\n\x05\x04\x14\x02\x06\x05\x12\x04\x82\x03\x02\x06\n\r\n\x05\x04\x14\
    \x02\x06\x01\x12\x04\x82\x03\x07\x12\n\r\n\x05\x04\x14\x02\x06\x03\x12\
    \x04\x82\x03\x15\x16\n\x0c\n\x04\x04\x14\x02\x07\x12\x04\x83\x03\x02\x19\
    \n\r\n\x05\x04\x14\x02\x07\x05\x12\x04\x83\x03\x02\x06\n\r\n\x05\x04\x14\
    \x02\x07\x01\x12\x04\x83\x03\x07\x14\n\r\n\x05\x04\x14\x02\x07\x03\x12\
    \x04\x83\x03\x17\x18\n\x0c\n\x04\x04\x14\x02\x08\x12\x04\x84\x03\x02\x1d\
    \n\r\n\x05\x04\x14\x02\x08\x06\x12\x04\x84\x03\x02\x0e\n\r\n\x05\x04\x14\
    \x02\x08\x01\x12\x04\x84\x03\x0f\x18\n\r\n\x05\x04\x14\x02\x08\x03\x12\
    \x04\x84\x03\x1b\x1c\n\x0c\n\x04\x04\x14\x02\t\x12\x04\x85\x03\x02\x1c\n\
    \r\n\x05\x04\x14\x02\t\x05\x12\x04\x85\x03\x02\x06\n\r\n\x05\x04\x14\x02\
    \t\x01\x12\x04\x85\x03\x07\x16\n\r\n\x05\x04\x14\x02\t\x03\x12\x04\x85\
    \x03\x19\x1b\n\x0c\n\x04\x04\x14\x02\n\x12\x04\x86\x03\x02\x19\n\r\n\x05\
    \x04\x14\x02\n\x05\x12\x04\x86\x03\x02\x07\n\r\n\x05\x04\x14\x02\n\x01\
    \x12\x04\x86\x03\x08\x13\n\r\n\x05\x04\x14\x02\n\x03\x12\x04\x86\x03\x16\
    \x18\n?\n\x02\x05\x06\x12\x06\x8a\x03\0\x95\x03\x01\x1a1\x20============\
    ========\x20LIGHT\x20====================\n\n\x0b\n\x03\x05\x06\x01\x12\
    \x04\x8a\x03\x05\x0e\n\x0c\n\x04\x05\x06\x02\0\x12\x04\x8b\x03\x02\x19\n\
    \r\n\x05\x05\x06\x02\0\x01\x12\x04\x8b\x03\x02\x14\n\r\n\x05\x05\x06\x02\
    \0\x02\x12\x04\x8b\x03\x17\x18\n\x0c\n\x04\x05\x06\x02\x01\x12\x04\x8c\
    \x03\x02\x18\n\r\n\x05\x05\x06\x02\x01\x01\x12\x04\x8c\x03\x02\x13\n\r\n\
    \x05\x05\x06\x02\x01\x02\x12\x04\x8c\x03\x16\x17\n\x0c\n\x04\x05\x06\x02\
    \x02\x12\x04\x8d\x03\x02\x1c\n\r\n\x05\x05\x06\x02\x02\x01\x12\x04\x8d\
    \x03\x02\x17\n\r\n\x05\x05\x06\x02\x02\x02\x12\x04\x8d\x03\x1a\x1b\n\x0c\
    \n\x04\x05\x06\x02\x03\x12\x04\x8e\x03\x02\x17\n\r\n\x05\x05\x06\x02\x03\
    \x01\x12\x04\x8e\x03\x02\x12\n\r\n\x05\x05\x06\x02\x03\x02\x12\x04\x8e\
    \x03\x15\x16\n\x0c\n\x04\x05\x06\x02\x04\x12\x04\x8f\x03\x02$\n\r\n\x05\
    \x05\x06\x02\x04\x01\x12\x04\x8f\x03\x02\x1e\n\r\n\x05\x05\x06\x02\x04\
    \x02\x12\x04\x8f\x03!#\n\x0c\n\x04\x05\x06\x02\x05\x12\x04\x90\x03\x02\"\
    \n\r\n\x05\x05\x06\x02\x05\x01\x12\x04\x90\x03\x02\x1c\n\r\n\x05\x05\x06\
    \x02\x05\x02\x12\x04\x90\x03\x1f!\n\x0c\n\x04\x05\x06\x02\x06\x12\x04\
    \x91\x03\x02\x16\n\r\n\x05\x05\x06\x02\x06\x01\x12\x04\x91\x03\x02\x10\n\
    \r\n\x05\x05\x06\x02\x06\x02\x12\x04\x91\x03\x13\x15\n\x0c\n\x04\x05\x06\
    \x02\x07\x12\x04\x92\x03\x02\x1c\n\r\n\x05\x05\x06\x02\x07\x01\x12\x04\
    \x92\x03\x02\x16\n\r\n\x05\x05\x06\x02\x07\x02\x12\x04\x92\x03\x19\x1b\n\
    \x0c\n\x04\x05\x06\x02\x08\x12\x04\x93\x03\x02(\n\r\n\x05\x05\x06\x02\
    \x08\x01\x12\x04\x93\x03\x02\"\n\r\n\x05\x05\x06\x02\x08\x02\x12\x04\x93\
    \x03%'\n\x0c\n\x04\x05\x06\x02\t\x12\x04\x94\x03\x02&\n\r\n\x05\x05\x06\
    \x02\t\x01\x12\x04\x94\x03\x02\x20\n\r\n\x05\x05\x06\x02\t\x02\x12\x04\
    \x94\x03#%\n\x0c\n\x02\x04\x15\x12\x06\x96\x03\0\xac\x03\x01\n\x0b\n\x03\
    \x04\x15\x01\x12\x04\x96\x03\x08!\n\x0b\n\x03\x04\x15\x07\x12\x04\x97\
    \x03\x02\x13\n\r\n\x05\x04\x15\x07\x8c\x08\x12\x04\x97\x03\x02\x13\n\x0b\
    \n\x03\x04\x15\x07\x12\x04\x98\x03\x02\"\n\r\n\x05\x04\x15\x07\x8d\x08\
    \x12\x04\x98\x03\x02\"\n\x0b\n\x03\x04\x15\x07\x12\x04\x99\x03\x02\x1f\n\
    \r\n\x05\x04\x15\x07\x8e\x08\x12\x04\x99\x03\x02\x1f\n\x0c\n\x04\x04\x15\
    \x02\0\x12\x04\x9b\x03\x02\x17\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\x9b\
    \x03\x02\x08\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\x9b\x03\t\x12\n\r\n\x05\
    \x04\x15\x02\0\x03\x12\x04\x9b\x03\x15\x16\n\x0c\n\x04\x04\x15\x02\x01\
    \x12\x04\x9c\x03\x02\x12\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\x9c\x03\
    \x02\t\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\x9c\x03\n\r\n\r\n\x05\x04\
    \x15\x02\x01\x03\x12\x04\x9c\x03\x10\x11\n\x0c\n\x04\x04\x15\x02\x02\x12\
    \x04\x9d\x03\x02\x12\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\x9d\x03\x02\
    \x08\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\x9d\x03\t\r\n\r\n\x05\x04\x15\
    \x02\x02\x03\x12\x04\x9d\x03\x10\x11\n\x0c\n\x04\x04\x15\x02\x03\x12\x04\
    \x9e\x03\x02\x17\n\r\n\x05\x04\x15\x02\x03\x05\x12\x04\x9e\x03\x02\x08\n\
    \r\n\x05\x04\x15\x02\x03\x01\x12\x04\x9e\x03\t\x12\n\r\n\x05\x04\x15\x02\
    \x03\x03\x12\x04\x9e\x03\x15\x16\n\x0c\n\x04\x04\x15\x02\x04\x12\x04\xa0\
    \x03\x020\n\r\n\x05\x04\x15\x02\x04\x04\x12\x04\xa0\x03\x02\n\n\r\n\x05\
    \x04\x15\x02\x04\x06\x12\x04\xa0\x03\x0b\x14\n\r\n\x05\x04\x15\x02\x04\
    \x01\x12\x04\xa0\x03\x15*\n\r\n\x05\x04\x15\x02\x04\x03\x12\x04\xa0\x03-\
    /\na\n\x04\x04\x15\x02\x05\x12\x04\xa2\x03\x028\x1aS\x20next\x20four\x20\
    supports_*\x20are\x20for\x20legacy\x20clients,\x20newer\x20clients\x20sh\
    ould\x20use\x20color\x20modes\n\n\r\n\x05\x04\x15\x02\x05\x05\x12\x04\
    \xa2\x03\x02\x06\n\r\n\x05\x04\x15\x02\x05\x01\x12\x04\xa2\x03\x07!\n\r\
    \n\x05\x04\x15\x02\x05\x03\x12\x04\xa2\x03$%\n\r\n\x05\x04\x15\x02\x05\
    \x08\x12\x04\xa2\x03&7\n\x0e\n\x06\x04\x15\x02\x05\x08\x03\x12\x04\xa2\
    \x03'6\n\x0c\n\x04\x04\x15\x02\x06\x12\x04\xa3\x03\x021\n\r\n\x05\x04\
    \x15\x02\x06\x05\x12\x04\xa3\x03\x02\x06\n\r\n\x05\x04\x15\x02\x06\x01\
    \x12\x04\xa3\x03\x07\x1a\n\r\n\x05\x04\x15\x02\x06\x03\x12\x04\xa3\x03\
    \x1d\x1e\n\r\n\x05\x04\x15\x02\x06\x08\x12\x04\xa3\x03\x1f0\n\x0e\n\x06\
    \x04\x15\x02\x06\x08\x03\x12\x04\xa3\x03\x20/\n\x0c\n\x04\x04\x15\x02\
    \x07\x12\x04\xa4\x03\x029\n\r\n\x05\x04\x15\x02\x07\x05\x12\x04\xa4\x03\
    \x02\x06\n\r\n\x05\x04\x15\x02\x07\x01\x12\x04\xa4\x03\x07\"\n\r\n\x05\
    \x04\x15\x02\x07\x03\x12\x04\xa4\x03%&\n\r\n\x05\x04\x15\x02\x07\x08\x12\
    \x04\xa4\x03'8\n\x0e\n\x06\x04\x15\x02\x07\x08\x03\x12\x04\xa4\x03(7\n\
    \x0c\n\x04\x04\x15\x02\x08\x12\x04\xa5\x03\x02?\n\r\n\x05\x04\x15\x02\
    \x08\x05\x12\x04\xa5\x03\x02\x06\n\r\n\x05\x04\x15\x02\x08\x01\x12\x04\
    \xa5\x03\x07(\n\r\n\x05\x04\x15\x02\x08\x03\x12\x04\xa5\x03+,\n\r\n\x05\
    \x04\x15\x02\x08\x08\x12\x04\xa5\x03->\n\x0e\n\x06\x04\x15\x02\x08\x08\
    \x03\x12\x04\xa5\x03.=\n\x0c\n\x04\x04\x15\x02\t\x12\x04\xa6\x03\x02\x17\
    \n\r\n\x05\x04\x15\x02\t\x05\x12\x04\xa6\x03\x02\x07\n\r\n\x05\x04\x15\
    \x02\t\x01\x12\x04\xa6\x03\x08\x12\n\r\n\x05\x04\x15\x02\t\x03\x12\x04\
    \xa6\x03\x15\x16\n\x0c\n\x04\x04\x15\x02\n\x12\x04\xa7\x03\x02\x18\n\r\n\
    \x05\x04\x15\x02\n\x05\x12\x04\xa7\x03\x02\x07\n\r\n\x05\x04\x15\x02\n\
    \x01\x12\x04\xa7\x03\x08\x12\n\r\n\x05\x04\x15\x02\n\x03\x12\x04\xa7\x03\
    \x15\x17\n\x0c\n\x04\x04\x15\x02\x0b\x12\x04\xa8\x03\x02\x1f\n\r\n\x05\
    \x04\x15\x02\x0b\x04\x12\x04\xa8\x03\x02\n\n\r\n\x05\x04\x15\x02\x0b\x05\
    \x12\x04\xa8\x03\x0b\x11\n\r\n\x05\x04\x15\x02\x0b\x01\x12\x04\xa8\x03\
    \x12\x19\n\r\n\x05\x04\x15\x02\x0b\x03\x12\x04\xa8\x03\x1c\x1e\n\x0c\n\
    \x04\x04\x15\x02\x0c\x12\x04\xa9\x03\x02\x20\n\r\n\x05\x04\x15\x02\x0c\
    \x05\x12\x04\xa9\x03\x02\x06\n\r\n\x05\x04\x15\x02\x0c\x01\x12\x04\xa9\
    \x03\x07\x1a\n\r\n\x05\x04\x15\x02\x0c\x03\x12\x04\xa9\x03\x1d\x1f\n\x0c\
    \n\x04\x04\x15\x02\r\x12\x04\xaa\x03\x02\x13\n\r\n\x05\x04\x15\x02\r\x05\
    \x12\x04\xaa\x03\x02\x08\n\r\n\x05\x04\x15\x02\r\x01\x12\x04\xaa\x03\t\r\
    \n\r\n\x05\x04\x15\x02\r\x03\x12\x04\xaa\x03\x10\x12\n\x0c\n\x04\x04\x15\
    \x02\x0e\x12\x04\xab\x03\x02&\n\r\n\x05\x04\x15\x02\x0e\x06\x12\x04\xab\
    \x03\x02\x10\n\r\n\x05\x04\x15\x02\x0e\x01\x12\x04\xab\x03\x11\x20\n\r\n\
    \x05\x04\x15\x02\x0e\x03\x12\x04\xab\x03#%\n\x0c\n\x02\x04\x16\x12\x06\
    \xad\x03\0\xc0\x03\x01\n\x0b\n\x03\x04\x16\x01\x12\x04\xad\x03\x08\x1a\n\
    \x0b\n\x03\x04\x16\x07\x12\x04\xae\x03\x02\x13\n\r\n\x05\x04\x16\x07\x8c\
    \x08\x12\x04\xae\x03\x02\x13\n\x0b\n\x03\x04\x16\x07\x12\x04\xaf\x03\x02\
    \"\n\r\n\x05\x04\x16\x07\x8d\x08\x12\x04\xaf\x03\x02\"\n\x0b\n\x03\x04\
    \x16\x07\x12\x04\xb0\x03\x02\x1f\n\r\n\x05\x04\x16\x07\x8e\x08\x12\x04\
    \xb0\x03\x02\x1f\n\x0b\n\x03\x04\x16\x07\x12\x04\xb1\x03\x02\x1b\n\r\n\
    \x05\x04\x16\x07\x90\x08\x12\x04\xb1\x03\x02\x1b\n\x0c\n\x04\x04\x16\x02\
    \0\x12\x04\xb3\x03\x02\x12\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xb3\x03\
    \x02\t\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xb3\x03\n\r\n\r\n\x05\x04\x16\
    \x02\0\x03\x12\x04\xb3\x03\x10\x11\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\
    \xb4\x03\x02\x11\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xb4\x03\x02\x06\n\
    \r\n\x05\x04\x16\x02\x01\x01\x12\x04\xb4\x03\x07\x0c\n\r\n\x05\x04\x16\
    \x02\x01\x03\x12\x04\xb4\x03\x0f\x10\n\x0c\n\x04\x04\x16\x02\x02\x12\x04\
    \xb5\x03\x02\x17\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\xb5\x03\x02\x07\n\
    \r\n\x05\x04\x16\x02\x02\x01\x12\x04\xb5\x03\x08\x12\n\r\n\x05\x04\x16\
    \x02\x02\x03\x12\x04\xb5\x03\x15\x16\n\x0c\n\x04\x04\x16\x02\x03\x12\x04\
    \xb6\x03\x02\x1c\n\r\n\x05\x04\x16\x02\x03\x06\x12\x04\xb6\x03\x02\x0b\n\
    \r\n\x05\x04\x16\x02\x03\x01\x12\x04\xb6\x03\x0c\x16\n\r\n\x05\x04\x16\
    \x02\x03\x03\x12\x04\xb6\x03\x19\x1b\n\x0c\n\x04\x04\x16\x02\x04\x12\x04\
    \xb7\x03\x02\x1e\n\r\n\x05\x04\x16\x02\x04\x05\x12\x04\xb7\x03\x02\x07\n\
    \r\n\x05\x04\x16\x02\x04\x01\x12\x04\xb7\x03\x08\x18\n\r\n\x05\x04\x16\
    \x02\x04\x03\x12\x04\xb7\x03\x1b\x1d\n\x0c\n\x04\x04\x16\x02\x05\x12\x04\
    \xb8\x03\x02\x10\n\r\n\x05\x04\x16\x02\x05\x05\x12\x04\xb8\x03\x02\x07\n\
    \r\n\x05\x04\x16\x02\x05\x01\x12\x04\xb8\x03\x08\x0b\n\r\n\x05\x04\x16\
    \x02\x05\x03\x12\x04\xb8\x03\x0e\x0f\n\x0c\n\x04\x04\x16\x02\x06\x12\x04\
    \xb9\x03\x02\x12\n\r\n\x05\x04\x16\x02\x06\x05\x12\x04\xb9\x03\x02\x07\n\
    \r\n\x05\x04\x16\x02\x06\x01\x12\x04\xb9\x03\x08\r\n\r\n\x05\x04\x16\x02\
    \x06\x03\x12\x04\xb9\x03\x10\x11\n\x0c\n\x04\x04\x16\x02\x07\x12\x04\xba\
    \x03\x02\x11\n\r\n\x05\x04\x16\x02\x07\x05\x12\x04\xba\x03\x02\x07\n\r\n\
    \x05\x04\x16\x02\x07\x01\x12\x04\xba\x03\x08\x0c\n\r\n\x05\x04\x16\x02\
    \x07\x03\x12\x04\xba\x03\x0f\x10\n\x0c\n\x04\x04\x16\x02\x08\x12\x04\xbb\
    \x03\x02\x12\n\r\n\x05\x04\x16\x02\x08\x05\x12\x04\xbb\x03\x02\x07\n\r\n\
    \x05\x04\x16\x02\x08\x01\x12\x04\xbb\x03\x08\r\n\r\n\x05\x04\x16\x02\x08\
    \x03\x12\x04\xbb\x03\x10\x11\n\x0c\n\x04\x04\x16\x02\t\x12\x04\xbc\x03\
    \x02\x1e\n\r\n\x05\x04\x16\x02\t\x05\x12\x04\xbc\x03\x02\x07\n\r\n\x05\
    \x04\x16\x02\t\x01\x12\x04\xbc\x03\x08\x19\n\r\n\x05\x04\x16\x02\t\x03\
    \x12\x04\xbc\x03\x1c\x1d\n\x0c\n\x04\x04\x16\x02\n\x12\x04\xbd\x03\x02\
    \x18\n\r\n\x05\x04\x16\x02\n\x05\x12\x04\xbd\x03\x02\x07\n\r\n\x05\x04\
    \x16\x02\n\x01\x12\x04\xbd\x03\x08\x12\n\r\n\x05\x04\x16\x02\n\x03\x12\
    \x04\xbd\x03\x15\x17\n\x0c\n\x04\x04\x16\x02\x0b\x12\x04\xbe\x03\x02\x18\
    \n\r\n\x05\x04\x16\x02\x0b\x05\x12\x04\xbe\x03\x02\x07\n\r\n\x05\x04\x16\
    \x02\x0b\x01\x12\x04\xbe\x03\x08\x12\n\r\n\x05\x04\x16\x02\x0b\x03\x12\
    \x04\xbe\x03\x15\x17\n\x0c\n\x04\x04\x16\x02\x0c\x12\x04\xbf\x03\x02\x14\
    \n\r\n\x05\x04\x16\x02\x0c\x05\x12\x04\xbf\x03\x02\x08\n\r\n\x05\x04\x16\
    \x02\x0c\x01\x12\x04\xbf\x03\t\x0f\n\r\n\x05\x04\x16\x02\x0c\x03\x12\x04\
    \xbf\x03\x12\x13\n\x0c\n\x02\x04\x17\x12\x06\xc1\x03\0\xe2\x03\x01\n\x0b\
    \n\x03\x04\x17\x01\x12\x04\xc1\x03\x08\x1b\n\x0b\n\x03\x04\x17\x07\x12\
    \x04\xc2\x03\x02\x13\n\r\n\x05\x04\x17\x07\x8c\x08\x12\x04\xc2\x03\x02\
    \x13\n\x0b\n\x03\x04\x17\x07\x12\x04\xc3\x03\x02\"\n\r\n\x05\x04\x17\x07\
    \x8d\x08\x12\x04\xc3\x03\x02\"\n\x0b\n\x03\x04\x17\x07\x12\x04\xc4\x03\
    \x02\x1f\n\r\n\x05\x04\x17\x07\x8e\x08\x12\x04\xc4\x03\x02\x1f\n\x0b\n\
    \x03\x04\x17\x07\x12\x04\xc5\x03\x02\x1b\n\r\n\x05\x04\x17\x07\x90\x08\
    \x12\x04\xc5\x03\x02\x1b\n\x0c\n\x04\x04\x17\x02\0\x12\x04\xc7\x03\x02\
    \x12\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xc7\x03\x02\t\n\r\n\x05\x04\x17\
    \x02\0\x01\x12\x04\xc7\x03\n\r\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xc7\
    \x03\x10\x11\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\xc8\x03\x02\x15\n\r\n\
    \x05\x04\x17\x02\x01\x05\x12\x04\xc8\x03\x02\x06\n\r\n\x05\x04\x17\x02\
    \x01\x01\x12\x04\xc8\x03\x07\x10\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\
    \xc8\x03\x13\x14\n\x0c\n\x04\x04\x17\x02\x02\x12\x04\xc9\x03\x02\x11\n\r\
    \n\x05\x04\x17\x02\x02\x05\x12\x04\xc9\x03\x02\x06\n\r\n\x05\x04\x17\x02\
    \x02\x01\x12\x04\xc9\x03\x07\x0c\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\
    \xc9\x03\x0f\x10\n\x0c\n\x04\x04\x17\x02\x03\x12\x04\xca\x03\x02\x1a\n\r\
    \n\x05\x04\x17\x02\x03\x05\x12\x04\xca\x03\x02\x06\n\r\n\x05\x04\x17\x02\
    \x03\x01\x12\x04\xca\x03\x07\x15\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\
    \xca\x03\x18\x19\n\x0c\n\x04\x04\x17\x02\x04\x12\x04\xcb\x03\x02\x17\n\r\
    \n\x05\x04\x17\x02\x04\x05\x12\x04\xcb\x03\x02\x07\n\r\n\x05\x04\x17\x02\
    \x04\x01\x12\x04\xcb\x03\x08\x12\n\r\n\x05\x04\x17\x02\x04\x03\x12\x04\
    \xcb\x03\x15\x16\n\x0c\n\x04\x04\x17\x02\x05\x12\x04\xcc\x03\x02\x1b\n\r\
    \n\x05\x04\x17\x02\x05\x05\x12\x04\xcc\x03\x02\x06\n\r\n\x05\x04\x17\x02\
    \x05\x01\x12\x04\xcc\x03\x07\x15\n\r\n\x05\x04\x17\x02\x05\x03\x12\x04\
    \xcc\x03\x18\x1a\n\x0c\n\x04\x04\x17\x02\x06\x12\x04\xcd\x03\x02\x1c\n\r\
    \n\x05\x04\x17\x02\x06\x06\x12\x04\xcd\x03\x02\x0b\n\r\n\x05\x04\x17\x02\
    \x06\x01\x12\x04\xcd\x03\x0c\x16\n\r\n\x05\x04\x17\x02\x06\x03\x12\x04\
    \xcd\x03\x19\x1b\n\x0c\n\x04\x04\x17\x02\x07\x12\x04\xce\x03\x02!\n\r\n\
    \x05\x04\x17\x02\x07\x05\x12\x04\xce\x03\x02\x06\n\r\n\x05\x04\x17\x02\
    \x07\x01\x12\x04\xce\x03\x07\x1b\n\r\n\x05\x04\x17\x02\x07\x03\x12\x04\
    \xce\x03\x1e\x20\n\x0c\n\x04\x04\x17\x02\x08\x12\x04\xcf\x03\x02\x1e\n\r\
    \n\x05\x04\x17\x02\x08\x05\x12\x04\xcf\x03\x02\x07\n\r\n\x05\x04\x17\x02\
    \x08\x01\x12\x04\xcf\x03\x08\x18\n\r\n\x05\x04\x17\x02\x08\x03\x12\x04\
    \xcf\x03\x1b\x1d\n\x0c\n\x04\x04\x17\x02\t\x12\x04\xd0\x03\x02\x13\n\r\n\
    \x05\x04\x17\x02\t\x05\x12\x04\xd0\x03\x02\x06\n\r\n\x05\x04\x17\x02\t\
    \x01\x12\x04\xd0\x03\x07\x0e\n\r\n\x05\x04\x17\x02\t\x03\x12\x04\xd0\x03\
    \x11\x12\n\x0c\n\x04\x04\x17\x02\n\x12\x04\xd1\x03\x02\x10\n\r\n\x05\x04\
    \x17\x02\n\x05\x12\x04\xd1\x03\x02\x07\n\r\n\x05\x04\x17\x02\n\x01\x12\
    \x04\xd1\x03\x08\x0b\n\r\n\x05\x04\x17\x02\n\x03\x12\x04\xd1\x03\x0e\x0f\
    \n\x0c\n\x04\x04\x17\x02\x0b\x12\x04\xd2\x03\x02\x12\n\r\n\x05\x04\x17\
    \x02\x0b\x05\x12\x04\xd2\x03\x02\x07\n\r\n\x05\x04\x17\x02\x0b\x01\x12\
    \x04\xd2\x03\x08\r\n\r\n\x05\x04\x17\x02\x0b\x03\x12\x04\xd2\x03\x10\x11\
    \n\x0c\n\x04\x04\x17\x02\x0c\x12\x04\xd3\x03\x02\x11\n\r\n\x05\x04\x17\
    \x02\x0c\x05\x12\x04\xd3\x03\x02\x07\n\r\n\x05\x04\x17\x02\x0c\x01\x12\
    \x04\xd3\x03\x08\x0c\n\r\n\x05\x04\x17\x02\x0c\x03\x12\x04\xd3\x03\x0f\
    \x10\n\x0c\n\x04\x04\x17\x02\r\x12\x04\xd4\x03\x02\x16\n\r\n\x05\x04\x17\
    \x02\r\x05\x12\x04\xd4\x03\x02\x06\n\r\n\x05\x04\x17\x02\r\x01\x12\x04\
    \xd4\x03\x07\x10\n\r\n\x05\x04\x17\x02\r\x03\x12\x04\xd4\x03\x13\x15\n\
    \x0c\n\x04\x04\x17\x02\x0e\x12\x04\xd5\x03\x02\x13\n\r\n\x05\x04\x17\x02\
    \x0e\x05\x12\x04\xd5\x03\x02\x07\n\r\n\x05\x04\x17\x02\x0e\x01\x12\x04\
    \xd5\x03\x08\r\n\r\n\x05\x04\x17\x02\x0e\x03\x12\x04\xd5\x03\x10\x12\n\
    \x0c\n\x04\x04\x17\x02\x0f\x12\x04\xd6\x03\x02\"\n\r\n\x05\x04\x17\x02\
    \x0f\x05\x12\x04\xd6\x03\x02\x06\n\r\n\x05\x04\x17\x02\x0f\x01\x12\x04\
    \xd6\x03\x07\x1c\n\r\n\x05\x04\x17\x02\x0f\x03\x12\x04\xd6\x03\x1f!\n\
    \x0c\n\x04\x04\x17\x02\x10\x12\x04\xd7\x03\x02\x1f\n\r\n\x05\x04\x17\x02\
    \x10\x05\x12\x04\xd7\x03\x02\x07\n\r\n\x05\x04\x17\x02\x10\x01\x12\x04\
    \xd7\x03\x08\x19\n\r\n\x05\x04\x17\x02\x10\x03\x12\x04\xd7\x03\x1c\x1e\n\
    \x0c\n\x04\x04\x17\x02\x11\x12\x04\xd8\x03\x02\x1b\n\r\n\x05\x04\x17\x02\
    \x11\x05\x12\x04\xd8\x03\x02\x06\n\r\n\x05\x04\x17\x02\x11\x01\x12\x04\
    \xd8\x03\x07\x15\n\r\n\x05\x04\x17\x02\x11\x03\x12\x04\xd8\x03\x18\x1a\n\
    \x0c\n\x04\x04\x17\x02\x12\x12\x04\xd9\x03\x02\x18\n\r\n\x05\x04\x17\x02\
    \x12\x05\x12\x04\xd9\x03\x02\x07\n\r\n\x05\x04\x17\x02\x12\x01\x12\x04\
    \xd9\x03\x08\x12\n\r\n\x05\x04\x17\x02\x12\x03\x12\x04\xd9\x03\x15\x17\n\
    \x0c\n\x04\x04\x17\x02\x13\x12\x04\xda\x03\x02\x1b\n\r\n\x05\x04\x17\x02\
    \x13\x05\x12\x04\xda\x03\x02\x06\n\r\n\x05\x04\x17\x02\x13\x01\x12\x04\
    \xda\x03\x07\x15\n\r\n\x05\x04\x17\x02\x13\x03\x12\x04\xda\x03\x18\x1a\n\
    \x0c\n\x04\x04\x17\x02\x14\x12\x04\xdb\x03\x02\x18\n\r\n\x05\x04\x17\x02\
    \x14\x05\x12\x04\xdb\x03\x02\x07\n\r\n\x05\x04\x17\x02\x14\x01\x12\x04\
    \xdb\x03\x08\x12\n\r\n\x05\x04\x17\x02\x14\x03\x12\x04\xdb\x03\x15\x17\n\
    \x0c\n\x04\x04\x17\x02\x15\x12\x04\xdc\x03\x02\"\n\r\n\x05\x04\x17\x02\
    \x15\x05\x12\x04\xdc\x03\x02\x06\n\r\n\x05\x04\x17\x02\x15\x01\x12\x04\
    \xdc\x03\x07\x1c\n\r\n\x05\x04\x17\x02\x15\x03\x12\x04\xdc\x03\x1f!\n\
    \x0c\n\x04\x04\x17\x02\x16\x12\x04\xdd\x03\x02\x20\n\r\n\x05\x04\x17\x02\
    \x16\x05\x12\x04\xdd\x03\x02\x08\n\r\n\x05\x04\x17\x02\x16\x01\x12\x04\
    \xdd\x03\t\x1a\n\r\n\x05\x04\x17\x02\x16\x03\x12\x04\xdd\x03\x1d\x1f\n\
    \x0c\n\x04\x04\x17\x02\x17\x12\x04\xde\x03\x02\x1d\n\r\n\x05\x04\x17\x02\
    \x17\x05\x12\x04\xde\x03\x02\x06\n\r\n\x05\x04\x17\x02\x17\x01\x12\x04\
    \xde\x03\x07\x17\n\r\n\x05\x04\x17\x02\x17\x03\x12\x04\xde\x03\x1a\x1c\n\
    \x0c\n\x04\x04\x17\x02\x18\x12\x04\xdf\x03\x02\x1b\n\r\n\x05\x04\x17\x02\
    \x18\x05\x12\x04\xdf\x03\x02\x08\n\r\n\x05\x04\x17\x02\x18\x01\x12\x04\
    \xdf\x03\t\x15\n\r\n\x05\x04\x17\x02\x18\x03\x12\x04\xdf\x03\x18\x1a\n\
    \x0c\n\x04\x04\x17\x02\x19\x12\x04\xe0\x03\x02\x17\n\r\n\x05\x04\x17\x02\
    \x19\x05\x12\x04\xe0\x03\x02\x06\n\r\n\x05\x04\x17\x02\x19\x01\x12\x04\
    \xe0\x03\x07\x11\n\r\n\x05\x04\x17\x02\x19\x03\x12\x04\xe0\x03\x14\x16\n\
    \x0c\n\x04\x04\x17\x02\x1a\x12\x04\xe1\x03\x02\x15\n\r\n\x05\x04\x17\x02\
    \x1a\x05\x12\x04\xe1\x03\x02\x08\n\r\n\x05\x04\x17\x02\x1a\x01\x12\x04\
    \xe1\x03\t\x0f\n\r\n\x05\x04\x17\x02\x1a\x03\x12\x04\xe1\x03\x12\x14\n@\
    \n\x02\x05\x07\x12\x06\xe5\x03\0\xea\x03\x01\x1a2\x20===================\
    =\x20SENSOR\x20====================\n\n\x0b\n\x03\x05\x07\x01\x12\x04\
    \xe5\x03\x05\x15\n\x0c\n\x04\x05\x07\x02\0\x12\x04\xe6\x03\x02\x17\n\r\n\
    \x05\x05\x07\x02\0\x01\x12\x04\xe6\x03\x02\x12\n\r\n\x05\x05\x07\x02\0\
    \x02\x12\x04\xe6\x03\x15\x16\n\x0c\n\x04\x05\x07\x02\x01\x12\x04\xe7\x03\
    \x02\x1e\n\r\n\x05\x05\x07\x02\x01\x01\x12\x04\xe7\x03\x02\x19\n\r\n\x05\
    \x05\x07\x02\x01\x02\x12\x04\xe7\x03\x1c\x1d\n\x0c\n\x04\x05\x07\x02\x02\
    \x12\x04\xe8\x03\x02#\n\r\n\x05\x05\x07\x02\x02\x01\x12\x04\xe8\x03\x02\
    \x1e\n\r\n\x05\x05\x07\x02\x02\x02\x12\x04\xe8\x03!\"\n\x0c\n\x04\x05\
    \x07\x02\x03\x12\x04\xe9\x03\x02\x18\n\r\n\x05\x05\x07\x02\x03\x01\x12\
    \x04\xe9\x03\x02\x13\n\r\n\x05\x05\x07\x02\x03\x02\x12\x04\xe9\x03\x16\
    \x17\n\x0c\n\x02\x05\x08\x12\x06\xec\x03\0\xf0\x03\x01\n\x0b\n\x03\x05\
    \x08\x01\x12\x04\xec\x03\x05\x18\n\x0c\n\x04\x05\x08\x02\0\x12\x04\xed\
    \x03\x02\x16\n\r\n\x05\x05\x08\x02\0\x01\x12\x04\xed\x03\x02\x11\n\r\n\
    \x05\x05\x08\x02\0\x02\x12\x04\xed\x03\x14\x15\n\x0c\n\x04\x05\x08\x02\
    \x01\x12\x04\xee\x03\x02\x17\n\r\n\x05\x05\x08\x02\x01\x01\x12\x04\xee\
    \x03\x02\x12\n\r\n\x05\x05\x08\x02\x01\x02\x12\x04\xee\x03\x15\x16\n\x0c\
    \n\x04\x05\x08\x02\x02\x12\x04\xef\x03\x02\x16\n\r\n\x05\x05\x08\x02\x02\
    \x01\x12\x04\xef\x03\x02\x11\n\r\n\x05\x05\x08\x02\x02\x02\x12\x04\xef\
    \x03\x14\x15\n\x0c\n\x02\x04\x18\x12\x06\xf2\x03\0\x86\x04\x01\n\x0b\n\
    \x03\x04\x18\x01\x12\x04\xf2\x03\x08\"\n\x0b\n\x03\x04\x18\x07\x12\x04\
    \xf3\x03\x02\x13\n\r\n\x05\x04\x18\x07\x8c\x08\x12\x04\xf3\x03\x02\x13\n\
    \x0b\n\x03\x04\x18\x07\x12\x04\xf4\x03\x02\"\n\r\n\x05\x04\x18\x07\x8d\
    \x08\x12\x04\xf4\x03\x02\"\n\x0b\n\x03\x04\x18\x07\x12\x04\xf5\x03\x02\
    \x20\n\r\n\x05\x04\x18\x07\x8e\x08\x12\x04\xf5\x03\x02\x20\n\x0c\n\x04\
    \x04\x18\x02\0\x12\x04\xf7\x03\x02\x17\n\r\n\x05\x04\x18\x02\0\x05\x12\
    \x04\xf7\x03\x02\x08\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xf7\x03\t\x12\n\
    \r\n\x05\x04\x18\x02\0\x03\x12\x04\xf7\x03\x15\x16\n\x0c\n\x04\x04\x18\
    \x02\x01\x12\x04\xf8\x03\x02\x12\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\
    \xf8\x03\x02\t\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xf8\x03\n\r\n\r\n\
    \x05\x04\x18\x02\x01\x03\x12\x04\xf8\x03\x10\x11\n\x0c\n\x04\x04\x18\x02\
    \x02\x12\x04\xf9\x03\x02\x12\n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\xf9\
    \x03\x02\x08\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\xf9\x03\t\r\n\r\n\x05\
    \x04\x18\x02\x02\x03\x12\x04\xf9\x03\x10\x11\n\x0c\n\x04\x04\x18\x02\x03\
    \x12\x04\xfa\x03\x02\x17\n\r\n\x05\x04\x18\x02\x03\x05\x12\x04\xfa\x03\
    \x02\x08\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\xfa\x03\t\x12\n\r\n\x05\
    \x04\x18\x02\x03\x03\x12\x04\xfa\x03\x15\x16\n\x0c\n\x04\x04\x18\x02\x04\
    \x12\x04\xfc\x03\x02\x12\n\r\n\x05\x04\x18\x02\x04\x05\x12\x04\xfc\x03\
    \x02\x08\n\r\n\x05\x04\x18\x02\x04\x01\x12\x04\xfc\x03\t\r\n\r\n\x05\x04\
    \x18\x02\x04\x03\x12\x04\xfc\x03\x10\x11\n\x0c\n\x04\x04\x18\x02\x05\x12\
    \x04\xfd\x03\x02!\n\r\n\x05\x04\x18\x02\x05\x05\x12\x04\xfd\x03\x02\x08\
    \n\r\n\x05\x04\x18\x02\x05\x01\x12\x04\xfd\x03\t\x1c\n\r\n\x05\x04\x18\
    \x02\x05\x03\x12\x04\xfd\x03\x1f\x20\n\x0c\n\x04\x04\x18\x02\x06\x12\x04\
    \xfe\x03\x02\x1e\n\r\n\x05\x04\x18\x02\x06\x05\x12\x04\xfe\x03\x02\x07\n\
    \r\n\x05\x04\x18\x02\x06\x01\x12\x04\xfe\x03\x08\x19\n\r\n\x05\x04\x18\
    \x02\x06\x03\x12\x04\xfe\x03\x1c\x1d\n\x0c\n\x04\x04\x18\x02\x07\x12\x04\
    \xff\x03\x02\x18\n\r\n\x05\x04\x18\x02\x07\x05\x12\x04\xff\x03\x02\x06\n\
    \r\n\x05\x04\x18\x02\x07\x01\x12\x04\xff\x03\x07\x13\n\r\n\x05\x04\x18\
    \x02\x07\x03\x12\x04\xff\x03\x16\x17\n\x0c\n\x04\x04\x18\x02\x08\x12\x04\
    \x80\x04\x02\x1a\n\r\n\x05\x04\x18\x02\x08\x05\x12\x04\x80\x04\x02\x08\n\
    \r\n\x05\x04\x18\x02\x08\x01\x12\x04\x80\x04\t\x15\n\r\n\x05\x04\x18\x02\
    \x08\x03\x12\x04\x80\x04\x18\x19\n\x0c\n\x04\x04\x18\x02\t\x12\x04\x81\
    \x04\x02$\n\r\n\x05\x04\x18\x02\t\x06\x12\x04\x81\x04\x02\x12\n\r\n\x05\
    \x04\x18\x02\t\x01\x12\x04\x81\x04\x13\x1e\n\r\n\x05\x04\x18\x02\t\x03\
    \x12\x04\x81\x04!#\n3\n\x04\x04\x18\x02\n\x12\x04\x83\x04\x022\x1a%\x20L\
    ast\x20reset\x20type\x20removed\x20in\x202021.9.0\n\n\r\n\x05\x04\x18\
    \x02\n\x06\x12\x04\x83\x04\x02\x15\n\r\n\x05\x04\x18\x02\n\x01\x12\x04\
    \x83\x04\x16,\n\r\n\x05\x04\x18\x02\n\x03\x12\x04\x83\x04/1\n\x0c\n\x04\
    \x04\x18\x02\x0b\x12\x04\x84\x04\x02\x20\n\r\n\x05\x04\x18\x02\x0b\x05\
    \x12\x04\x84\x04\x02\x06\n\r\n\x05\x04\x18\x02\x0b\x01\x12\x04\x84\x04\
    \x07\x1a\n\r\n\x05\x04\x18\x02\x0b\x03\x12\x04\x84\x04\x1d\x1f\n\x0c\n\
    \x04\x04\x18\x02\x0c\x12\x04\x85\x04\x02&\n\r\n\x05\x04\x18\x02\x0c\x06\
    \x12\x04\x85\x04\x02\x10\n\r\n\x05\x04\x18\x02\x0c\x01\x12\x04\x85\x04\
    \x11\x20\n\r\n\x05\x04\x18\x02\x0c\x03\x12\x04\x85\x04#%\n\x0c\n\x02\x04\
    \x19\x12\x06\x87\x04\0\x92\x04\x01\n\x0b\n\x03\x04\x19\x01\x12\x04\x87\
    \x04\x08\x1b\n\x0b\n\x03\x04\x19\x07\x12\x04\x88\x04\x02\x13\n\r\n\x05\
    \x04\x19\x07\x8c\x08\x12\x04\x88\x04\x02\x13\n\x0b\n\x03\x04\x19\x07\x12\
    \x04\x89\x04\x02\"\n\r\n\x05\x04\x19\x07\x8d\x08\x12\x04\x89\x04\x02\"\n\
    \x0b\n\x03\x04\x19\x07\x12\x04\x8a\x04\x02\x20\n\r\n\x05\x04\x19\x07\x8e\
    \x08\x12\x04\x8a\x04\x02\x20\n\x0b\n\x03\x04\x19\x07\x12\x04\x8b\x04\x02\
    \x1b\n\r\n\x05\x04\x19\x07\x90\x08\x12\x04\x8b\x04\x02\x1b\n\x0c\n\x04\
    \x04\x19\x02\0\x12\x04\x8d\x04\x02\x12\n\r\n\x05\x04\x19\x02\0\x05\x12\
    \x04\x8d\x04\x02\t\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\x8d\x04\n\r\n\r\n\
    \x05\x04\x19\x02\0\x03\x12\x04\x8d\x04\x10\x11\n\x0c\n\x04\x04\x19\x02\
    \x01\x12\x04\x8e\x04\x02\x12\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\x8e\
    \x04\x02\x07\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\x8e\x04\x08\r\n\r\n\
    \x05\x04\x19\x02\x01\x03\x12\x04\x8e\x04\x10\x11\n\x90\x01\n\x04\x04\x19\
    \x02\x02\x12\x04\x91\x04\x02\x19\x1a\x81\x01\x20If\x20the\x20sensor\x20d\
    oes\x20not\x20have\x20a\x20valid\x20state\x20yet.\n\x20Equivalent\x20to\
    \x20`!obj->has_state()`\x20-\x20inverse\x20logic\x20to\x20make\x20state\
    \x20packets\x20smaller\n\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\x91\x04\
    \x02\x06\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\x91\x04\x07\x14\n\r\n\x05\
    \x04\x19\x02\x02\x03\x12\x04\x91\x04\x17\x18\n@\n\x02\x04\x1a\x12\x06\
    \x95\x04\0\xa4\x04\x01\x1a2\x20====================\x20SWITCH\x20=======\
    =============\n\n\x0b\n\x03\x04\x1a\x01\x12\x04\x95\x04\x08\"\n\x0b\n\
    \x03\x04\x1a\x07\x12\x04\x96\x04\x02\x13\n\r\n\x05\x04\x1a\x07\x8c\x08\
    \x12\x04\x96\x04\x02\x13\n\x0b\n\x03\x04\x1a\x07\x12\x04\x97\x04\x02\"\n\
    \r\n\x05\x04\x1a\x07\x8d\x08\x12\x04\x97\x04\x02\"\n\x0b\n\x03\x04\x1a\
    \x07\x12\x04\x98\x04\x02\x20\n\r\n\x05\x04\x1a\x07\x8e\x08\x12\x04\x98\
    \x04\x02\x20\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\x9a\x04\x02\x17\n\r\n\x05\
    \x04\x1a\x02\0\x05\x12\x04\x9a\x04\x02\x08\n\r\n\x05\x04\x1a\x02\0\x01\
    \x12\x04\x9a\x04\t\x12\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\x9a\x04\x15\
    \x16\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\x9b\x04\x02\x12\n\r\n\x05\x04\
    \x1a\x02\x01\x05\x12\x04\x9b\x04\x02\t\n\r\n\x05\x04\x1a\x02\x01\x01\x12\
    \x04\x9b\x04\n\r\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\x9b\x04\x10\x11\n\
    \x0c\n\x04\x04\x1a\x02\x02\x12\x04\x9c\x04\x02\x12\n\r\n\x05\x04\x1a\x02\
    \x02\x05\x12\x04\x9c\x04\x02\x08\n\r\n\x05\x04\x1a\x02\x02\x01\x12\x04\
    \x9c\x04\t\r\n\r\n\x05\x04\x1a\x02\x02\x03\x12\x04\x9c\x04\x10\x11\n\x0c\
    \n\x04\x04\x1a\x02\x03\x12\x04\x9d\x04\x02\x17\n\r\n\x05\x04\x1a\x02\x03\
    \x05\x12\x04\x9d\x04\x02\x08\n\r\n\x05\x04\x1a\x02\x03\x01\x12\x04\x9d\
    \x04\t\x12\n\r\n\x05\x04\x1a\x02\x03\x03\x12\x04\x9d\x04\x15\x16\n\x0c\n\
    \x04\x04\x1a\x02\x04\x12\x04\x9f\x04\x02\x12\n\r\n\x05\x04\x1a\x02\x04\
    \x05\x12\x04\x9f\x04\x02\x08\n\r\n\x05\x04\x1a\x02\x04\x01\x12\x04\x9f\
    \x04\t\r\n\r\n\x05\x04\x1a\x02\x04\x03\x12\x04\x9f\x04\x10\x11\n\x0c\n\
    \x04\x04\x1a\x02\x05\x12\x04\xa0\x04\x02\x19\n\r\n\x05\x04\x1a\x02\x05\
    \x05\x12\x04\xa0\x04\x02\x06\n\r\n\x05\x04\x1a\x02\x05\x01\x12\x04\xa0\
    \x04\x07\x14\n\r\n\x05\x04\x1a\x02\x05\x03\x12\x04\xa0\x04\x17\x18\n\x0c\
    \n\x04\x04\x1a\x02\x06\x12\x04\xa1\x04\x02\x1f\n\r\n\x05\x04\x1a\x02\x06\
    \x05\x12\x04\xa1\x04\x02\x06\n\r\n\x05\x04\x1a\x02\x06\x01\x12\x04\xa1\
    \x04\x07\x1a\n\r\n\x05\x04\x1a\x02\x06\x03\x12\x04\xa1\x04\x1d\x1e\n\x0c\
    \n\x04\x04\x1a\x02\x07\x12\x04\xa2\x04\x02%\n\r\n\x05\x04\x1a\x02\x07\
    \x06\x12\x04\xa2\x04\x02\x10\n\r\n\x05\x04\x1a\x02\x07\x01\x12\x04\xa2\
    \x04\x11\x20\n\r\n\x05\x04\x1a\x02\x07\x03\x12\x04\xa2\x04#$\n\x0c\n\x04\
    \x04\x1a\x02\x08\x12\x04\xa3\x04\x02\x1a\n\r\n\x05\x04\x1a\x02\x08\x05\
    \x12\x04\xa3\x04\x02\x08\n\r\n\x05\x04\x1a\x02\x08\x01\x12\x04\xa3\x04\t\
    \x15\n\r\n\x05\x04\x1a\x02\x08\x03\x12\x04\xa3\x04\x18\x19\n\x0c\n\x02\
    \x04\x1b\x12\x06\xa5\x04\0\xad\x04\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\
    \xa5\x04\x08\x1b\n\x0b\n\x03\x04\x1b\x07\x12\x04\xa6\x04\x02\x13\n\r\n\
    \x05\x04\x1b\x07\x8c\x08\x12\x04\xa6\x04\x02\x13\n\x0b\n\x03\x04\x1b\x07\
    \x12\x04\xa7\x04\x02\"\n\r\n\x05\x04\x1b\x07\x8d\x08\x12\x04\xa7\x04\x02\
    \"\n\x0b\n\x03\x04\x1b\x07\x12\x04\xa8\x04\x02\x20\n\r\n\x05\x04\x1b\x07\
    \x8e\x08\x12\x04\xa8\x04\x02\x20\n\x0b\n\x03\x04\x1b\x07\x12\x04\xa9\x04\
    \x02\x1b\n\r\n\x05\x04\x1b\x07\x90\x08\x12\x04\xa9\x04\x02\x1b\n\x0c\n\
    \x04\x04\x1b\x02\0\x12\x04\xab\x04\x02\x12\n\r\n\x05\x04\x1b\x02\0\x05\
    \x12\x04\xab\x04\x02\t\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xab\x04\n\r\n\
    \r\n\x05\x04\x1b\x02\0\x03\x12\x04\xab\x04\x10\x11\n\x0c\n\x04\x04\x1b\
    \x02\x01\x12\x04\xac\x04\x02\x11\n\r\n\x05\x04\x1b\x02\x01\x05\x12\x04\
    \xac\x04\x02\x06\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xac\x04\x07\x0c\n\
    \r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xac\x04\x0f\x10\n\x0c\n\x02\x04\x1c\
    \x12\x06\xae\x04\0\xb6\x04\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\xae\x04\
    \x08\x1c\n\x0b\n\x03\x04\x1c\x07\x12\x04\xaf\x04\x02\x13\n\r\n\x05\x04\
    \x1c\x07\x8c\x08\x12\x04\xaf\x04\x02\x13\n\x0b\n\x03\x04\x1c\x07\x12\x04\
    \xb0\x04\x02\"\n\r\n\x05\x04\x1c\x07\x8d\x08\x12\x04\xb0\x04\x02\"\n\x0b\
    \n\x03\x04\x1c\x07\x12\x04\xb1\x04\x02\x20\n\r\n\x05\x04\x1c\x07\x8e\x08\
    \x12\x04\xb1\x04\x02\x20\n\x0b\n\x03\x04\x1c\x07\x12\x04\xb2\x04\x02\x1b\
    \n\r\n\x05\x04\x1c\x07\x90\x08\x12\x04\xb2\x04\x02\x1b\n\x0c\n\x04\x04\
    \x1c\x02\0\x12\x04\xb4\x04\x02\x12\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\
    \xb4\x04\x02\t\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xb4\x04\n\r\n\r\n\x05\
    \x04\x1c\x02\0\x03\x12\x04\xb4\x04\x10\x11\n\x0c\n\x04\x04\x1c\x02\x01\
    \x12\x04\xb5\x04\x02\x11\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\xb5\x04\
    \x02\x06\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xb5\x04\x07\x0c\n\r\n\x05\
    \x04\x1c\x02\x01\x03\x12\x04\xb5\x04\x0f\x10\nE\n\x02\x04\x1d\x12\x06\
    \xb9\x04\0\xc6\x04\x01\x1a7\x20====================\x20TEXT\x20SENSOR\
    \x20====================\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\xb9\x04\x08&\
    \n\x0b\n\x03\x04\x1d\x07\x12\x04\xba\x04\x02\x13\n\r\n\x05\x04\x1d\x07\
    \x8c\x08\x12\x04\xba\x04\x02\x13\n\x0b\n\x03\x04\x1d\x07\x12\x04\xbb\x04\
    \x02\"\n\r\n\x05\x04\x1d\x07\x8d\x08\x12\x04\xbb\x04\x02\"\n\x0b\n\x03\
    \x04\x1d\x07\x12\x04\xbc\x04\x02%\n\r\n\x05\x04\x1d\x07\x8e\x08\x12\x04\
    \xbc\x04\x02%\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\xbe\x04\x02\x17\n\r\n\
    \x05\x04\x1d\x02\0\x05\x12\x04\xbe\x04\x02\x08\n\r\n\x05\x04\x1d\x02\0\
    \x01\x12\x04\xbe\x04\t\x12\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xbe\x04\
    \x15\x16\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xbf\x04\x02\x12\n\r\n\x05\
    \x04\x1d\x02\x01\x05\x12\x04\xbf\x04\x02\t\n\r\n\x05\x04\x1d\x02\x01\x01\
    \x12\x04\xbf\x04\n\r\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xbf\x04\x10\
    \x11\n\x0c\n\x04\x04\x1d\x02\x02\x12\x04\xc0\x04\x02\x12\n\r\n\x05\x04\
    \x1d\x02\x02\x05\x12\x04\xc0\x04\x02\x08\n\r\n\x05\x04\x1d\x02\x02\x01\
    \x12\x04\xc0\x04\t\r\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\xc0\x04\x10\
    \x11\n\x0c\n\x04\x04\x1d\x02\x03\x12\x04\xc1\x04\x02\x17\n\r\n\x05\x04\
    \x1d\x02\x03\x05\x12\x04\xc1\x04\x02\x08\n\r\n\x05\x04\x1d\x02\x03\x01\
    \x12\x04\xc1\x04\t\x12\n\r\n\x05\x04\x1d\x02\x03\x03\x12\x04\xc1\x04\x15\
    \x16\n\x0c\n\x04\x04\x1d\x02\x04\x12\x04\xc3\x04\x02\x12\n\r\n\x05\x04\
    \x1d\x02\x04\x05\x12\x04\xc3\x04\x02\x08\n\r\n\x05\x04\x1d\x02\x04\x01\
    \x12\x04\xc3\x04\t\r\n\r\n\x05\x04\x1d\x02\x04\x03\x12\x04\xc3\x04\x10\
    \x11\n\x0c\n\x04\x04\x1d\x02\x05\x12\x04\xc4\x04\x02\x1f\n\r\n\x05\x04\
    \x1d\x02\x05\x05\x12\x04\xc4\x04\x02\x06\n\r\n\x05\x04\x1d\x02\x05\x01\
    \x12\x04\xc4\x04\x07\x1a\n\r\n\x05\x04\x1d\x02\x05\x03\x12\x04\xc4\x04\
    \x1d\x1e\n\x0c\n\x04\x04\x1d\x02\x06\x12\x04\xc5\x04\x02%\n\r\n\x05\x04\
    \x1d\x02\x06\x06\x12\x04\xc5\x04\x02\x10\n\r\n\x05\x04\x1d\x02\x06\x01\
    \x12\x04\xc5\x04\x11\x20\n\r\n\x05\x04\x1d\x02\x06\x03\x12\x04\xc5\x04#$\
    \n\x0c\n\x02\x04\x1e\x12\x06\xc7\x04\0\xd2\x04\x01\n\x0b\n\x03\x04\x1e\
    \x01\x12\x04\xc7\x04\x08\x1f\n\x0b\n\x03\x04\x1e\x07\x12\x04\xc8\x04\x02\
    \x13\n\r\n\x05\x04\x1e\x07\x8c\x08\x12\x04\xc8\x04\x02\x13\n\x0b\n\x03\
    \x04\x1e\x07\x12\x04\xc9\x04\x02\"\n\r\n\x05\x04\x1e\x07\x8d\x08\x12\x04\
    \xc9\x04\x02\"\n\x0b\n\x03\x04\x1e\x07\x12\x04\xca\x04\x02%\n\r\n\x05\
    \x04\x1e\x07\x8e\x08\x12\x04\xca\x04\x02%\n\x0b\n\x03\x04\x1e\x07\x12\
    \x04\xcb\x04\x02\x1b\n\r\n\x05\x04\x1e\x07\x90\x08\x12\x04\xcb\x04\x02\
    \x1b\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xcd\x04\x02\x12\n\r\n\x05\x04\x1e\
    \x02\0\x05\x12\x04\xcd\x04\x02\t\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xcd\
    \x04\n\r\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xcd\x04\x10\x11\n\x0c\n\x04\
    \x04\x1e\x02\x01\x12\x04\xce\x04\x02\x13\n\r\n\x05\x04\x1e\x02\x01\x05\
    \x12\x04\xce\x04\x02\x08\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xce\x04\t\
    \x0e\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xce\x04\x11\x12\n\x95\x01\n\
    \x04\x04\x1e\x02\x02\x12\x04\xd1\x04\x02\x19\x1a\x86\x01\x20If\x20the\
    \x20text\x20sensor\x20does\x20not\x20have\x20a\x20valid\x20state\x20yet.\
    \n\x20Equivalent\x20to\x20`!obj->has_state()`\x20-\x20inverse\x20logic\
    \x20to\x20make\x20state\x20packets\x20smaller\n\n\r\n\x05\x04\x1e\x02\
    \x02\x05\x12\x04\xd1\x04\x02\x06\n\r\n\x05\x04\x1e\x02\x02\x01\x12\x04\
    \xd1\x04\x07\x14\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\xd1\x04\x17\x18\n\
    H\n\x02\x05\t\x12\x06\xd5\x04\0\xde\x04\x01\x1a:\x20====================\
    \x20SUBSCRIBE\x20LOGS\x20====================\n\n\x0b\n\x03\x05\t\x01\
    \x12\x04\xd5\x04\x05\r\n\x0c\n\x04\x05\t\x02\0\x12\x04\xd6\x04\x02\x15\n\
    \r\n\x05\x05\t\x02\0\x01\x12\x04\xd6\x04\x02\x10\n\r\n\x05\x05\t\x02\0\
    \x02\x12\x04\xd6\x04\x13\x14\n\x0c\n\x04\x05\t\x02\x01\x12\x04\xd7\x04\
    \x02\x16\n\r\n\x05\x05\t\x02\x01\x01\x12\x04\xd7\x04\x02\x11\n\r\n\x05\
    \x05\t\x02\x01\x02\x12\x04\xd7\x04\x14\x15\n\x0c\n\x04\x05\t\x02\x02\x12\
    \x04\xd8\x04\x02\x15\n\r\n\x05\x05\t\x02\x02\x01\x12\x04\xd8\x04\x02\x10\
    \n\r\n\x05\x05\t\x02\x02\x02\x12\x04\xd8\x04\x13\x14\n\x0c\n\x04\x05\t\
    \x02\x03\x12\x04\xd9\x04\x02\x15\n\r\n\x05\x05\t\x02\x03\x01\x12\x04\xd9\
    \x04\x02\x10\n\r\n\x05\x05\t\x02\x03\x02\x12\x04\xd9\x04\x13\x14\n\x0c\n\
    \x04\x05\t\x02\x04\x12\x04\xda\x04\x02\x17\n\r\n\x05\x05\t\x02\x04\x01\
    \x12\x04\xda\x04\x02\x12\n\r\n\x05\x05\t\x02\x04\x02\x12\x04\xda\x04\x15\
    \x16\n\x0c\n\x04\x05\t\x02\x05\x12\x04\xdb\x04\x02\x16\n\r\n\x05\x05\t\
    \x02\x05\x01\x12\x04\xdb\x04\x02\x11\n\r\n\x05\x05\t\x02\x05\x02\x12\x04\
    \xdb\x04\x14\x15\n\x0c\n\x04\x05\t\x02\x06\x12\x04\xdc\x04\x02\x18\n\r\n\
    \x05\x05\t\x02\x06\x01\x12\x04\xdc\x04\x02\x13\n\r\n\x05\x05\t\x02\x06\
    \x02\x12\x04\xdc\x04\x16\x17\n\x0c\n\x04\x05\t\x02\x07\x12\x04\xdd\x04\
    \x02\x1d\n\r\n\x05\x05\t\x02\x07\x01\x12\x04\xdd\x04\x02\x18\n\r\n\x05\
    \x05\t\x02\x07\x02\x12\x04\xdd\x04\x1b\x1c\n\x0c\n\x02\x04\x1f\x12\x06\
    \xdf\x04\0\xe4\x04\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\xdf\x04\x08\x1c\n\
    \x0b\n\x03\x04\x1f\x07\x12\x04\xe0\x04\x02\x13\n\r\n\x05\x04\x1f\x07\x8c\
    \x08\x12\x04\xe0\x04\x02\x13\n\x0b\n\x03\x04\x1f\x07\x12\x04\xe1\x04\x02\
    \"\n\r\n\x05\x04\x1f\x07\x8d\x08\x12\x04\xe1\x04\x02\"\n\x0c\n\x04\x04\
    \x1f\x02\0\x12\x04\xe2\x04\x02\x15\n\r\n\x05\x04\x1f\x02\0\x06\x12\x04\
    \xe2\x04\x02\n\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xe2\x04\x0b\x10\n\r\n\
    \x05\x04\x1f\x02\0\x03\x12\x04\xe2\x04\x13\x14\n\x0c\n\x04\x04\x1f\x02\
    \x01\x12\x04\xe3\x04\x02\x17\n\r\n\x05\x04\x1f\x02\x01\x05\x12\x04\xe3\
    \x04\x02\x06\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\xe3\x04\x07\x12\n\r\n\
    \x05\x04\x1f\x02\x01\x03\x12\x04\xe3\x04\x15\x16\n\x0c\n\x02\x04\x20\x12\
    \x06\xe5\x04\0\xee\x04\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\xe5\x04\x08\
    \x1d\n\x0b\n\x03\x04\x20\x07\x12\x04\xe6\x04\x02\x13\n\r\n\x05\x04\x20\
    \x07\x8c\x08\x12\x04\xe6\x04\x02\x13\n\x0b\n\x03\x04\x20\x07\x12\x04\xe7\
    \x04\x02\"\n\r\n\x05\x04\x20\x07\x8d\x08\x12\x04\xe7\x04\x02\"\n\x0b\n\
    \x03\x04\x20\x07\x12\x04\xe8\x04\x02\x17\n\r\n\x05\x04\x20\x07\x8f\x08\
    \x12\x04\xe8\x04\x02\x17\n\x0b\n\x03\x04\x20\x07\x12\x04\xe9\x04\x02\x1c\
    \n\r\n\x05\x04\x20\x07\x90\x08\x12\x04\xe9\x04\x02\x1c\n\x0c\n\x04\x04\
    \x20\x02\0\x12\x04\xeb\x04\x02\x15\n\r\n\x05\x04\x20\x02\0\x06\x12\x04\
    \xeb\x04\x02\n\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xeb\x04\x0b\x10\n\r\n\
    \x05\x04\x20\x02\0\x03\x12\x04\xeb\x04\x13\x14\n\x0c\n\x04\x04\x20\x02\
    \x01\x12\x04\xec\x04\x02\x15\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\xec\
    \x04\x02\x08\n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\xec\x04\t\x10\n\r\n\
    \x05\x04\x20\x02\x01\x03\x12\x04\xec\x04\x13\x14\n\x0c\n\x04\x04\x20\x02\
    \x02\x12\x04\xed\x04\x02\x17\n\r\n\x05\x04\x20\x02\x02\x05\x12\x04\xed\
    \x04\x02\x06\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\xed\x04\x07\x12\n\r\n\
    \x05\x04\x20\x02\x02\x03\x12\x04\xed\x04\x15\x16\nO\n\x02\x04!\x12\x06\
    \xf1\x04\0\xf4\x04\x01\x1aA\x20====================\x20HOMEASSISTANT.SER\
    VICE\x20====================\n\n\x0b\n\x03\x04!\x01\x12\x04\xf1\x04\x08-\
    \n\x0b\n\x03\x04!\x07\x12\x04\xf2\x04\x02\x13\n\r\n\x05\x04!\x07\x8c\x08\
    \x12\x04\xf2\x04\x02\x13\n\x0b\n\x03\x04!\x07\x12\x04\xf3\x04\x02\"\n\r\
    \n\x05\x04!\x07\x8d\x08\x12\x04\xf3\x04\x02\"\n\x0c\n\x02\x04\"\x12\x06\
    \xf6\x04\0\xf9\x04\x01\n\x0b\n\x03\x04\"\x01\x12\x04\xf6\x04\x08\x1f\n\
    \x0c\n\x04\x04\"\x02\0\x12\x04\xf7\x04\x02\x11\n\r\n\x05\x04\"\x02\0\x05\
    \x12\x04\xf7\x04\x02\x08\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xf7\x04\t\x0c\
    \n\r\n\x05\x04\"\x02\0\x03\x12\x04\xf7\x04\x0f\x10\n\x0c\n\x04\x04\"\x02\
    \x01\x12\x04\xf8\x04\x02\x13\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\xf8\x04\
    \x02\x08\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\xf8\x04\t\x0e\n\r\n\x05\x04\
    \"\x02\x01\x03\x12\x04\xf8\x04\x11\x12\n\x0c\n\x02\x04#\x12\x06\xfb\x04\
    \0\x85\x05\x01\n\x0b\n\x03\x04#\x01\x12\x04\xfb\x04\x08$\n\x0b\n\x03\x04\
    #\x07\x12\x04\xfc\x04\x02\x13\n\r\n\x05\x04#\x07\x8c\x08\x12\x04\xfc\x04\
    \x02\x13\n\x0b\n\x03\x04#\x07\x12\x04\xfd\x04\x02\"\n\r\n\x05\x04#\x07\
    \x8d\x08\x12\x04\xfd\x04\x02\"\n\x0b\n\x03\x04#\x07\x12\x04\xfe\x04\x02\
    \x1b\n\r\n\x05\x04#\x07\x90\x08\x12\x04\xfe\x04\x02\x1b\n\x0c\n\x04\x04#\
    \x02\0\x12\x04\x80\x05\x02\x15\n\r\n\x05\x04#\x02\0\x05\x12\x04\x80\x05\
    \x02\x08\n\r\n\x05\x04#\x02\0\x01\x12\x04\x80\x05\t\x10\n\r\n\x05\x04#\
    \x02\0\x03\x12\x04\x80\x05\x13\x14\n\x0c\n\x04\x04#\x02\x01\x12\x04\x81\
    \x05\x02,\n\r\n\x05\x04#\x02\x01\x04\x12\x04\x81\x05\x02\n\n\r\n\x05\x04\
    #\x02\x01\x06\x12\x04\x81\x05\x0b\"\n\r\n\x05\x04#\x02\x01\x01\x12\x04\
    \x81\x05#'\n\r\n\x05\x04#\x02\x01\x03\x12\x04\x81\x05*+\n\x0c\n\x04\x04#\
    \x02\x02\x12\x04\x82\x05\x025\n\r\n\x05\x04#\x02\x02\x04\x12\x04\x82\x05\
    \x02\n\n\r\n\x05\x04#\x02\x02\x06\x12\x04\x82\x05\x0b\"\n\r\n\x05\x04#\
    \x02\x02\x01\x12\x04\x82\x05#0\n\r\n\x05\x04#\x02\x02\x03\x12\x04\x82\
    \x0534\n\x0c\n\x04\x04#\x02\x03\x12\x04\x83\x05\x021\n\r\n\x05\x04#\x02\
    \x03\x04\x12\x04\x83\x05\x02\n\n\r\n\x05\x04#\x02\x03\x06\x12\x04\x83\
    \x05\x0b\"\n\r\n\x05\x04#\x02\x03\x01\x12\x04\x83\x05#,\n\r\n\x05\x04#\
    \x02\x03\x03\x12\x04\x83\x05/0\n\x0c\n\x04\x04#\x02\x04\x12\x04\x84\x05\
    \x02\x14\n\r\n\x05\x04#\x02\x04\x05\x12\x04\x84\x05\x02\x06\n\r\n\x05\
    \x04#\x02\x04\x01\x12\x04\x84\x05\x07\x0f\n\r\n\x05\x04#\x02\x04\x03\x12\
    \x04\x84\x05\x12\x13\n\x9d\x02\n\x02\x04$\x12\x06\x8b\x05\0\x8e\x05\x01\
    \x1a\x8e\x02\x20====================\x20IMPORT\x20HOME\x20ASSISTANT\x20S\
    TATES\x20====================\n\x201.\x20Client\x20sends\x20SubscribeHom\
    eAssistantStatesRequest\n\x202.\x20Server\x20responds\x20with\x20zero\
    \x20or\x20more\x20SubscribeHomeAssistantStateResponse\x20(async)\n\x203.\
    \x20Client\x20sends\x20HomeAssistantStateResponse\x20for\x20state\x20cha\
    nges.\n\n\x0b\n\x03\x04$\x01\x12\x04\x8b\x05\x08+\n\x0b\n\x03\x04$\x07\
    \x12\x04\x8c\x05\x02\x13\n\r\n\x05\x04$\x07\x8c\x08\x12\x04\x8c\x05\x02\
    \x13\n\x0b\n\x03\x04$\x07\x12\x04\x8d\x05\x02\"\n\r\n\x05\x04$\x07\x8d\
    \x08\x12\x04\x8d\x05\x02\"\n\x0c\n\x02\x04%\x12\x06\x90\x05\0\x95\x05\
    \x01\n\x0b\n\x03\x04%\x01\x12\x04\x90\x05\x08+\n\x0b\n\x03\x04%\x07\x12\
    \x04\x91\x05\x02\x13\n\r\n\x05\x04%\x07\x8c\x08\x12\x04\x91\x05\x02\x13\
    \n\x0b\n\x03\x04%\x07\x12\x04\x92\x05\x02\"\n\r\n\x05\x04%\x07\x8d\x08\
    \x12\x04\x92\x05\x02\"\n\x0c\n\x04\x04%\x02\0\x12\x04\x93\x05\x02\x17\n\
    \r\n\x05\x04%\x02\0\x05\x12\x04\x93\x05\x02\x08\n\r\n\x05\x04%\x02\0\x01\
    \x12\x04\x93\x05\t\x12\n\r\n\x05\x04%\x02\0\x03\x12\x04\x93\x05\x15\x16\
    \n\x0c\n\x04\x04%\x02\x01\x12\x04\x94\x05\x02\x17\n\r\n\x05\x04%\x02\x01\
    \x05\x12\x04\x94\x05\x02\x08\n\r\n\x05\x04%\x02\x01\x01\x12\x04\x94\x05\
    \t\x12\n\r\n\x05\x04%\x02\x01\x03\x12\x04\x94\x05\x15\x16\n\x0c\n\x02\
    \x04&\x12\x06\x97\x05\0\x9f\x05\x01\n\x0b\n\x03\x04&\x01\x12\x04\x97\x05\
    \x08\"\n\x0b\n\x03\x04&\x07\x12\x04\x98\x05\x02\x13\n\r\n\x05\x04&\x07\
    \x8c\x08\x12\x04\x98\x05\x02\x13\n\x0b\n\x03\x04&\x07\x12\x04\x99\x05\
    \x02\"\n\r\n\x05\x04&\x07\x8d\x08\x12\x04\x99\x05\x02\"\n\x0b\n\x03\x04&\
    \x07\x12\x04\x9a\x05\x02\x1b\n\r\n\x05\x04&\x07\x90\x08\x12\x04\x9a\x05\
    \x02\x1b\n\x0c\n\x04\x04&\x02\0\x12\x04\x9c\x05\x02\x17\n\r\n\x05\x04&\
    \x02\0\x05\x12\x04\x9c\x05\x02\x08\n\r\n\x05\x04&\x02\0\x01\x12\x04\x9c\
    \x05\t\x12\n\r\n\x05\x04&\x02\0\x03\x12\x04\x9c\x05\x15\x16\n\x0c\n\x04\
    \x04&\x02\x01\x12\x04\x9d\x05\x02\x13\n\r\n\x05\x04&\x02\x01\x05\x12\x04\
    \x9d\x05\x02\x08\n\r\n\x05\x04&\x02\x01\x01\x12\x04\x9d\x05\t\x0e\n\r\n\
    \x05\x04&\x02\x01\x03\x12\x04\x9d\x05\x11\x12\n\x0c\n\x04\x04&\x02\x02\
    \x12\x04\x9e\x05\x02\x17\n\r\n\x05\x04&\x02\x02\x05\x12\x04\x9e\x05\x02\
    \x08\n\r\n\x05\x04&\x02\x02\x01\x12\x04\x9e\x05\t\x12\n\r\n\x05\x04&\x02\
    \x02\x03\x12\x04\x9e\x05\x15\x16\nE\n\x02\x04'\x12\x06\xa2\x05\0\xa5\x05\
    \x01\x1a7\x20====================\x20IMPORT\x20TIME\x20=================\
    ===\n\n\x0b\n\x03\x04'\x01\x12\x04\xa2\x05\x08\x16\n\x0b\n\x03\x04'\x07\
    \x12\x04\xa3\x05\x02\x13\n\r\n\x05\x04'\x07\x8c\x08\x12\x04\xa3\x05\x02\
    \x13\n\x0b\n\x03\x04'\x07\x12\x04\xa4\x05\x02\x20\n\r\n\x05\x04'\x07\x8d\
    \x08\x12\x04\xa4\x05\x02\x20\n\x0c\n\x02\x04(\x12\x06\xa7\x05\0\xad\x05\
    \x01\n\x0b\n\x03\x04(\x01\x12\x04\xa7\x05\x08\x17\n\x0b\n\x03\x04(\x07\
    \x12\x04\xa8\x05\x02\x13\n\r\n\x05\x04(\x07\x8c\x08\x12\x04\xa8\x05\x02\
    \x13\n\x0b\n\x03\x04(\x07\x12\x04\xa9\x05\x02\x20\n\r\n\x05\x04(\x07\x8d\
    \x08\x12\x04\xa9\x05\x02\x20\n\x0b\n\x03\x04(\x07\x12\x04\xaa\x05\x02\
    \x1b\n\r\n\x05\x04(\x07\x90\x08\x12\x04\xaa\x05\x02\x1b\n\x0c\n\x04\x04(\
    \x02\0\x12\x04\xac\x05\x02\x1c\n\r\n\x05\x04(\x02\0\x05\x12\x04\xac\x05\
    \x02\t\n\r\n\x05\x04(\x02\0\x01\x12\x04\xac\x05\n\x17\n\r\n\x05\x04(\x02\
    \0\x03\x12\x04\xac\x05\x1a\x1b\nO\n\x02\x05\n\x12\x06\xb0\x05\0\xb9\x05\
    \x01\x1aA\x20====================\x20USER-DEFINES\x20SERVICES\x20=======\
    =============\n\n\x0b\n\x03\x05\n\x01\x12\x04\xb0\x05\x05\x13\n\x0c\n\
    \x04\x05\n\x02\0\x12\x04\xb1\x05\x02\x1c\n\r\n\x05\x05\n\x02\0\x01\x12\
    \x04\xb1\x05\x02\x17\n\r\n\x05\x05\n\x02\0\x02\x12\x04\xb1\x05\x1a\x1b\n\
    \x0c\n\x04\x05\n\x02\x01\x12\x04\xb2\x05\x02\x1b\n\r\n\x05\x05\n\x02\x01\
    \x01\x12\x04\xb2\x05\x02\x16\n\r\n\x05\x05\n\x02\x01\x02\x12\x04\xb2\x05\
    \x19\x1a\n\x0c\n\x04\x05\n\x02\x02\x12\x04\xb3\x05\x02\x1d\n\r\n\x05\x05\
    \n\x02\x02\x01\x12\x04\xb3\x05\x02\x18\n\r\n\x05\x05\n\x02\x02\x02\x12\
    \x04\xb3\x05\x1b\x1c\n\x0c\n\x04\x05\n\x02\x03\x12\x04\xb4\x05\x02\x1e\n\
    \r\n\x05\x05\n\x02\x03\x01\x12\x04\xb4\x05\x02\x19\n\r\n\x05\x05\n\x02\
    \x03\x02\x12\x04\xb4\x05\x1c\x1d\n\x0c\n\x04\x05\n\x02\x04\x12\x04\xb5\
    \x05\x02\"\n\r\n\x05\x05\n\x02\x04\x01\x12\x04\xb5\x05\x02\x1d\n\r\n\x05\
    \x05\n\x02\x04\x02\x12\x04\xb5\x05\x20!\n\x0c\n\x04\x05\n\x02\x05\x12\
    \x04\xb6\x05\x02!\n\r\n\x05\x05\n\x02\x05\x01\x12\x04\xb6\x05\x02\x1c\n\
    \r\n\x05\x05\n\x02\x05\x02\x12\x04\xb6\x05\x1f\x20\n\x0c\n\x04\x05\n\x02\
    \x06\x12\x04\xb7\x05\x02#\n\r\n\x05\x05\n\x02\x06\x01\x12\x04\xb7\x05\
    \x02\x1e\n\r\n\x05\x05\n\x02\x06\x02\x12\x04\xb7\x05!\"\n\x0c\n\x04\x05\
    \n\x02\x07\x12\x04\xb8\x05\x02$\n\r\n\x05\x05\n\x02\x07\x01\x12\x04\xb8\
    \x05\x02\x1f\n\r\n\x05\x05\n\x02\x07\x02\x12\x04\xb8\x05\"#\n\x0c\n\x02\
    \x04)\x12\x06\xba\x05\0\xbd\x05\x01\n\x0b\n\x03\x04)\x01\x12\x04\xba\x05\
    \x08$\n\x0c\n\x04\x04)\x02\0\x12\x04\xbb\x05\x02\x12\n\r\n\x05\x04)\x02\
    \0\x05\x12\x04\xbb\x05\x02\x08\n\r\n\x05\x04)\x02\0\x01\x12\x04\xbb\x05\
    \t\r\n\r\n\x05\x04)\x02\0\x03\x12\x04\xbb\x05\x10\x11\n\x0c\n\x04\x04)\
    \x02\x01\x12\x04\xbc\x05\x02\x1a\n\r\n\x05\x04)\x02\x01\x06\x12\x04\xbc\
    \x05\x02\x10\n\r\n\x05\x04)\x02\x01\x01\x12\x04\xbc\x05\x11\x15\n\r\n\
    \x05\x04)\x02\x01\x03\x12\x04\xbc\x05\x18\x19\n\x0c\n\x02\x04*\x12\x06\
    \xbe\x05\0\xc5\x05\x01\n\x0b\n\x03\x04*\x01\x12\x04\xbe\x05\x08$\n\x0b\n\
    \x03\x04*\x07\x12\x04\xbf\x05\x02\x13\n\r\n\x05\x04*\x07\x8c\x08\x12\x04\
    \xbf\x05\x02\x13\n\x0b\n\x03\x04*\x07\x12\x04\xc0\x05\x02\"\n\r\n\x05\
    \x04*\x07\x8d\x08\x12\x04\xc0\x05\x02\"\n\x0c\n\x04\x04*\x02\0\x12\x04\
    \xc2\x05\x02\x12\n\r\n\x05\x04*\x02\0\x05\x12\x04\xc2\x05\x02\x08\n\r\n\
    \x05\x04*\x02\0\x01\x12\x04\xc2\x05\t\r\n\r\n\x05\x04*\x02\0\x03\x12\x04\
    \xc2\x05\x10\x11\n\x0c\n\x04\x04*\x02\x01\x12\x04\xc3\x05\x02\x12\n\r\n\
    \x05\x04*\x02\x01\x05\x12\x04\xc3\x05\x02\t\n\r\n\x05\x04*\x02\x01\x01\
    \x12\x04\xc3\x05\n\r\n\r\n\x05\x04*\x02\x01\x03\x12\x04\xc3\x05\x10\x11\
    \n\x0c\n\x04\x04*\x02\x02\x12\x04\xc4\x05\x021\n\r\n\x05\x04*\x02\x02\
    \x04\x12\x04\xc4\x05\x02\n\n\r\n\x05\x04*\x02\x02\x06\x12\x04\xc4\x05\
    \x0b'\n\r\n\x05\x04*\x02\x02\x01\x12\x04\xc4\x05(,\n\r\n\x05\x04*\x02\
    \x02\x03\x12\x04\xc4\x05/0\n\x0c\n\x02\x04+\x12\x06\xc6\x05\0\xd1\x05\
    \x01\n\x0b\n\x03\x04+\x01\x12\x04\xc6\x05\x08\x1e\n\x0c\n\x04\x04+\x02\0\
    \x12\x04\xc7\x05\x02\x11\n\r\n\x05\x04+\x02\0\x05\x12\x04\xc7\x05\x02\
    \x06\n\r\n\x05\x04+\x02\0\x01\x12\x04\xc7\x05\x07\x0c\n\r\n\x05\x04+\x02\
    \0\x03\x12\x04\xc7\x05\x0f\x10\n\x0c\n\x04\x04+\x02\x01\x12\x04\xc8\x05\
    \x02\x17\n\r\n\x05\x04+\x02\x01\x05\x12\x04\xc8\x05\x02\x07\n\r\n\x05\
    \x04+\x02\x01\x01\x12\x04\xc8\x05\x08\x12\n\r\n\x05\x04+\x02\x01\x03\x12\
    \x04\xc8\x05\x15\x16\n\x0c\n\x04\x04+\x02\x02\x12\x04\xc9\x05\x02\x13\n\
    \r\n\x05\x04+\x02\x02\x05\x12\x04\xc9\x05\x02\x07\n\r\n\x05\x04+\x02\x02\
    \x01\x12\x04\xc9\x05\x08\x0e\n\r\n\x05\x04+\x02\x02\x03\x12\x04\xc9\x05\
    \x11\x12\n\x0c\n\x04\x04+\x02\x03\x12\x04\xca\x05\x02\x15\n\r\n\x05\x04+\
    \x02\x03\x05\x12\x04\xca\x05\x02\x08\n\r\n\x05\x04+\x02\x03\x01\x12\x04\
    \xca\x05\t\x10\n\r\n\x05\x04+\x02\x03\x03\x12\x04\xca\x05\x13\x14\n?\n\
    \x04\x04+\x02\x04\x12\x04\xcc\x05\x02\x12\x1a1\x20ESPHome\x201.14\x20(ap\
    i\x20v1.3)\x20make\x20int\x20a\x20signed\x20value\n\n\r\n\x05\x04+\x02\
    \x04\x05\x12\x04\xcc\x05\x02\x08\n\r\n\x05\x04+\x02\x04\x01\x12\x04\xcc\
    \x05\t\r\n\r\n\x05\x04+\x02\x04\x03\x12\x04\xcc\x05\x10\x11\n\x0c\n\x04\
    \x04+\x02\x05\x12\x04\xcd\x05\x02.\n\r\n\x05\x04+\x02\x05\x04\x12\x04\
    \xcd\x05\x02\n\n\r\n\x05\x04+\x02\x05\x05\x12\x04\xcd\x05\x0b\x0f\n\r\n\
    \x05\x04+\x02\x05\x01\x12\x04\xcd\x05\x10\x1a\n\r\n\x05\x04+\x02\x05\x03\
    \x12\x04\xcd\x05\x1d\x1e\n\r\n\x05\x04+\x02\x05\x08\x12\x04\xcd\x05\x1f-\
    \n\x0e\n\x06\x04+\x02\x05\x08\x02\x12\x04\xcd\x05\x20,\n\x0c\n\x04\x04+\
    \x02\x06\x12\x04\xce\x05\x02/\n\r\n\x05\x04+\x02\x06\x04\x12\x04\xce\x05\
    \x02\n\n\r\n\x05\x04+\x02\x06\x05\x12\x04\xce\x05\x0b\x11\n\r\n\x05\x04+\
    \x02\x06\x01\x12\x04\xce\x05\x12\x1b\n\r\n\x05\x04+\x02\x06\x03\x12\x04\
    \xce\x05\x1e\x1f\n\r\n\x05\x04+\x02\x06\x08\x12\x04\xce\x05\x20.\n\x0e\n\
    \x06\x04+\x02\x06\x08\x02\x12\x04\xce\x05!-\n\x0c\n\x04\x04+\x02\x07\x12\
    \x04\xcf\x05\x020\n\r\n\x05\x04+\x02\x07\x04\x12\x04\xcf\x05\x02\n\n\r\n\
    \x05\x04+\x02\x07\x05\x12\x04\xcf\x05\x0b\x10\n\r\n\x05\x04+\x02\x07\x01\
    \x12\x04\xcf\x05\x11\x1c\n\r\n\x05\x04+\x02\x07\x03\x12\x04\xcf\x05\x1f\
    \x20\n\r\n\x05\x04+\x02\x07\x08\x12\x04\xcf\x05!/\n\x0e\n\x06\x04+\x02\
    \x07\x08\x02\x12\x04\xcf\x05\".\n\x0c\n\x04\x04+\x02\x08\x12\x04\xd0\x05\
    \x02#\n\r\n\x05\x04+\x02\x08\x04\x12\x04\xd0\x05\x02\n\n\r\n\x05\x04+\
    \x02\x08\x05\x12\x04\xd0\x05\x0b\x11\n\r\n\x05\x04+\x02\x08\x01\x12\x04\
    \xd0\x05\x12\x1e\n\r\n\x05\x04+\x02\x08\x03\x12\x04\xd0\x05!\"\n\x0c\n\
    \x02\x04,\x12\x06\xd2\x05\0\xd9\x05\x01\n\x0b\n\x03\x04,\x01\x12\x04\xd2\
    \x05\x08\x1d\n\x0b\n\x03\x04,\x07\x12\x04\xd3\x05\x02\x13\n\r\n\x05\x04,\
    \x07\x8c\x08\x12\x04\xd3\x05\x02\x13\n\x0b\n\x03\x04,\x07\x12\x04\xd4\
    \x05\x02\"\n\r\n\x05\x04,\x07\x8d\x08\x12\x04\xd4\x05\x02\"\n\x0b\n\x03\
    \x04,\x07\x12\x04\xd5\x05\x02\x1b\n\r\n\x05\x04,\x07\x90\x08\x12\x04\xd5\
    \x05\x02\x1b\n\x0c\n\x04\x04,\x02\0\x12\x04\xd7\x05\x02\x12\n\r\n\x05\
    \x04,\x02\0\x05\x12\x04\xd7\x05\x02\t\n\r\n\x05\x04,\x02\0\x01\x12\x04\
    \xd7\x05\n\r\n\r\n\x05\x04,\x02\0\x03\x12\x04\xd7\x05\x10\x11\n\x0c\n\
    \x04\x04,\x02\x01\x12\x04\xd8\x05\x02+\n\r\n\x05\x04,\x02\x01\x04\x12\
    \x04\xd8\x05\x02\n\n\r\n\x05\x04,\x02\x01\x06\x12\x04\xd8\x05\x0b!\n\r\n\
    \x05\x04,\x02\x01\x01\x12\x04\xd8\x05\"&\n\r\n\x05\x04,\x02\x01\x03\x12\
    \x04\xd8\x05)*\n@\n\x02\x04-\x12\x06\xdc\x05\0\xe8\x05\x01\x1a2\x20=====\
    ===============\x20CAMERA\x20====================\n\n\x0b\n\x03\x04-\x01\
    \x12\x04\xdc\x05\x08\"\n\x0b\n\x03\x04-\x07\x12\x04\xdd\x05\x02\x13\n\r\
    \n\x05\x04-\x07\x8c\x08\x12\x04\xdd\x05\x02\x13\n\x0b\n\x03\x04-\x07\x12\
    \x04\xde\x05\x02\"\n\r\n\x05\x04-\x07\x8d\x08\x12\x04\xde\x05\x02\"\n\
    \x0b\n\x03\x04-\x07\x12\x04\xdf\x05\x02&\n\r\n\x05\x04-\x07\x8e\x08\x12\
    \x04\xdf\x05\x02&\n\x0c\n\x04\x04-\x02\0\x12\x04\xe1\x05\x02\x17\n\r\n\
    \x05\x04-\x02\0\x05\x12\x04\xe1\x05\x02\x08\n\r\n\x05\x04-\x02\0\x01\x12\
    \x04\xe1\x05\t\x12\n\r\n\x05\x04-\x02\0\x03\x12\x04\xe1\x05\x15\x16\n\
    \x0c\n\x04\x04-\x02\x01\x12\x04\xe2\x05\x02\x12\n\r\n\x05\x04-\x02\x01\
    \x05\x12\x04\xe2\x05\x02\t\n\r\n\x05\x04-\x02\x01\x01\x12\x04\xe2\x05\n\
    \r\n\r\n\x05\x04-\x02\x01\x03\x12\x04\xe2\x05\x10\x11\n\x0c\n\x04\x04-\
    \x02\x02\x12\x04\xe3\x05\x02\x12\n\r\n\x05\x04-\x02\x02\x05\x12\x04\xe3\
    \x05\x02\x08\n\r\n\x05\x04-\x02\x02\x01\x12\x04\xe3\x05\t\r\n\r\n\x05\
    \x04-\x02\x02\x03\x12\x04\xe3\x05\x10\x11\n\x0c\n\x04\x04-\x02\x03\x12\
    \x04\xe4\x05\x02\x17\n\r\n\x05\x04-\x02\x03\x05\x12\x04\xe4\x05\x02\x08\
    \n\r\n\x05\x04-\x02\x03\x01\x12\x04\xe4\x05\t\x12\n\r\n\x05\x04-\x02\x03\
    \x03\x12\x04\xe4\x05\x15\x16\n\x0c\n\x04\x04-\x02\x04\x12\x04\xe5\x05\
    \x02\x1f\n\r\n\x05\x04-\x02\x04\x05\x12\x04\xe5\x05\x02\x06\n\r\n\x05\
    \x04-\x02\x04\x01\x12\x04\xe5\x05\x07\x1a\n\r\n\x05\x04-\x02\x04\x03\x12\
    \x04\xe5\x05\x1d\x1e\n\x0c\n\x04\x04-\x02\x05\x12\x04\xe6\x05\x02\x12\n\
    \r\n\x05\x04-\x02\x05\x05\x12\x04\xe6\x05\x02\x08\n\r\n\x05\x04-\x02\x05\
    \x01\x12\x04\xe6\x05\t\r\n\r\n\x05\x04-\x02\x05\x03\x12\x04\xe6\x05\x10\
    \x11\n\x0c\n\x04\x04-\x02\x06\x12\x04\xe7\x05\x02%\n\r\n\x05\x04-\x02\
    \x06\x06\x12\x04\xe7\x05\x02\x10\n\r\n\x05\x04-\x02\x06\x01\x12\x04\xe7\
    \x05\x11\x20\n\r\n\x05\x04-\x02\x06\x03\x12\x04\xe7\x05#$\n\x0c\n\x02\
    \x04.\x12\x06\xea\x05\0\xf2\x05\x01\n\x0b\n\x03\x04.\x01\x12\x04\xea\x05\
    \x08\x1b\n\x0b\n\x03\x04.\x07\x12\x04\xeb\x05\x02\x13\n\r\n\x05\x04.\x07\
    \x8c\x08\x12\x04\xeb\x05\x02\x13\n\x0b\n\x03\x04.\x07\x12\x04\xec\x05\
    \x02\"\n\r\n\x05\x04.\x07\x8d\x08\x12\x04\xec\x05\x02\"\n\x0b\n\x03\x04.\
    \x07\x12\x04\xed\x05\x02&\n\r\n\x05\x04.\x07\x8e\x08\x12\x04\xed\x05\x02\
    &\n\x0c\n\x04\x04.\x02\0\x12\x04\xef\x05\x02\x12\n\r\n\x05\x04.\x02\0\
    \x05\x12\x04\xef\x05\x02\t\n\r\n\x05\x04.\x02\0\x01\x12\x04\xef\x05\n\r\
    \n\r\n\x05\x04.\x02\0\x03\x12\x04\xef\x05\x10\x11\n\x0c\n\x04\x04.\x02\
    \x01\x12\x04\xf0\x05\x02\x11\n\r\n\x05\x04.\x02\x01\x05\x12\x04\xf0\x05\
    \x02\x07\n\r\n\x05\x04.\x02\x01\x01\x12\x04\xf0\x05\x08\x0c\n\r\n\x05\
    \x04.\x02\x01\x03\x12\x04\xf0\x05\x0f\x10\n\x0c\n\x04\x04.\x02\x02\x12\
    \x04\xf1\x05\x02\x10\n\r\n\x05\x04.\x02\x02\x05\x12\x04\xf1\x05\x02\x06\
    \n\r\n\x05\x04.\x02\x02\x01\x12\x04\xf1\x05\x07\x0b\n\r\n\x05\x04.\x02\
    \x02\x03\x12\x04\xf1\x05\x0e\x0f\n\x0c\n\x02\x04/\x12\x06\xf3\x05\0\xfb\
    \x05\x01\n\x0b\n\x03\x04/\x01\x12\x04\xf3\x05\x08\x1a\n\x0b\n\x03\x04/\
    \x07\x12\x04\xf4\x05\x02\x13\n\r\n\x05\x04/\x07\x8c\x08\x12\x04\xf4\x05\
    \x02\x13\n\x0b\n\x03\x04/\x07\x12\x04\xf5\x05\x02\"\n\r\n\x05\x04/\x07\
    \x8d\x08\x12\x04\xf5\x05\x02\"\n\x0b\n\x03\x04/\x07\x12\x04\xf6\x05\x02&\
    \n\r\n\x05\x04/\x07\x8e\x08\x12\x04\xf6\x05\x02&\n\x0b\n\x03\x04/\x07\
    \x12\x04\xf7\x05\x02\x1b\n\r\n\x05\x04/\x07\x90\x08\x12\x04\xf7\x05\x02\
    \x1b\n\x0c\n\x04\x04/\x02\0\x12\x04\xf9\x05\x02\x12\n\r\n\x05\x04/\x02\0\
    \x05\x12\x04\xf9\x05\x02\x06\n\r\n\x05\x04/\x02\0\x01\x12\x04\xf9\x05\
    \x07\r\n\r\n\x05\x04/\x02\0\x03\x12\x04\xf9\x05\x10\x11\n\x0c\n\x04\x04/\
    \x02\x01\x12\x04\xfa\x05\x02\x12\n\r\n\x05\x04/\x02\x01\x05\x12\x04\xfa\
    \x05\x02\x06\n\r\n\x05\x04/\x02\x01\x01\x12\x04\xfa\x05\x07\r\n\r\n\x05\
    \x04/\x02\x01\x03\x12\x04\xfa\x05\x10\x11\nA\n\x02\x05\x0b\x12\x06\xfe\
    \x05\0\x86\x06\x01\x1a3\x20====================\x20CLIMATE\x20==========\
    ==========\n\n\x0b\n\x03\x05\x0b\x01\x12\x04\xfe\x05\x05\x10\n\x0c\n\x04\
    \x05\x0b\x02\0\x12\x04\xff\x05\x02\x17\n\r\n\x05\x05\x0b\x02\0\x01\x12\
    \x04\xff\x05\x02\x12\n\r\n\x05\x05\x0b\x02\0\x02\x12\x04\xff\x05\x15\x16\
    \n\x0c\n\x04\x05\x0b\x02\x01\x12\x04\x80\x06\x02\x1d\n\r\n\x05\x05\x0b\
    \x02\x01\x01\x12\x04\x80\x06\x02\x18\n\r\n\x05\x05\x0b\x02\x01\x02\x12\
    \x04\x80\x06\x1b\x1c\n\x0c\n\x04\x05\x0b\x02\x02\x12\x04\x81\x06\x02\x18\
    \n\r\n\x05\x05\x0b\x02\x02\x01\x12\x04\x81\x06\x02\x13\n\r\n\x05\x05\x0b\
    \x02\x02\x02\x12\x04\x81\x06\x16\x17\n\x0c\n\x04\x05\x0b\x02\x03\x12\x04\
    \x82\x06\x02\x18\n\r\n\x05\x05\x0b\x02\x03\x01\x12\x04\x82\x06\x02\x13\n\
    \r\n\x05\x05\x0b\x02\x03\x02\x12\x04\x82\x06\x16\x17\n\x0c\n\x04\x05\x0b\
    \x02\x04\x12\x04\x83\x06\x02\x1c\n\r\n\x05\x05\x0b\x02\x04\x01\x12\x04\
    \x83\x06\x02\x17\n\r\n\x05\x05\x0b\x02\x04\x02\x12\x04\x83\x06\x1a\x1b\n\
    \x0c\n\x04\x05\x0b\x02\x05\x12\x04\x84\x06\x02\x17\n\r\n\x05\x05\x0b\x02\
    \x05\x01\x12\x04\x84\x06\x02\x12\n\r\n\x05\x05\x0b\x02\x05\x02\x12\x04\
    \x84\x06\x15\x16\n\x0c\n\x04\x05\x0b\x02\x06\x12\x04\x85\x06\x02\x18\n\r\
    \n\x05\x05\x0b\x02\x06\x01\x12\x04\x85\x06\x02\x13\n\r\n\x05\x05\x0b\x02\
    \x06\x02\x12\x04\x85\x06\x16\x17\n\x0c\n\x02\x05\x0c\x12\x06\x87\x06\0\
    \x91\x06\x01\n\x0b\n\x03\x05\x0c\x01\x12\x04\x87\x06\x05\x13\n\x0c\n\x04\
    \x05\x0c\x02\0\x12\x04\x88\x06\x02\x15\n\r\n\x05\x05\x0c\x02\0\x01\x12\
    \x04\x88\x06\x02\x10\n\r\n\x05\x05\x0c\x02\0\x02\x12\x04\x88\x06\x13\x14\
    \n\x0c\n\x04\x05\x0c\x02\x01\x12\x04\x89\x06\x02\x16\n\r\n\x05\x05\x0c\
    \x02\x01\x01\x12\x04\x89\x06\x02\x11\n\r\n\x05\x05\x0c\x02\x01\x02\x12\
    \x04\x89\x06\x14\x15\n\x0c\n\x04\x05\x0c\x02\x02\x12\x04\x8a\x06\x02\x17\
    \n\r\n\x05\x05\x0c\x02\x02\x01\x12\x04\x8a\x06\x02\x12\n\r\n\x05\x05\x0c\
    \x02\x02\x02\x12\x04\x8a\x06\x15\x16\n\x0c\n\x04\x05\x0c\x02\x03\x12\x04\
    \x8b\x06\x02\x16\n\r\n\x05\x05\x0c\x02\x03\x01\x12\x04\x8b\x06\x02\x11\n\
    \r\n\x05\x05\x0c\x02\x03\x02\x12\x04\x8b\x06\x14\x15\n\x0c\n\x04\x05\x0c\
    \x02\x04\x12\x04\x8c\x06\x02\x19\n\r\n\x05\x05\x0c\x02\x04\x01\x12\x04\
    \x8c\x06\x02\x14\n\r\n\x05\x05\x0c\x02\x04\x02\x12\x04\x8c\x06\x17\x18\n\
    \x0c\n\x04\x05\x0c\x02\x05\x12\x04\x8d\x06\x02\x17\n\r\n\x05\x05\x0c\x02\
    \x05\x01\x12\x04\x8d\x06\x02\x12\n\r\n\x05\x05\x0c\x02\x05\x02\x12\x04\
    \x8d\x06\x15\x16\n\x0c\n\x04\x05\x0c\x02\x06\x12\x04\x8e\x06\x02\x19\n\r\
    \n\x05\x05\x0c\x02\x06\x01\x12\x04\x8e\x06\x02\x14\n\r\n\x05\x05\x0c\x02\
    \x06\x02\x12\x04\x8e\x06\x17\x18\n\x0c\n\x04\x05\x0c\x02\x07\x12\x04\x8f\
    \x06\x02\x18\n\r\n\x05\x05\x0c\x02\x07\x01\x12\x04\x8f\x06\x02\x13\n\r\n\
    \x05\x05\x0c\x02\x07\x02\x12\x04\x8f\x06\x16\x17\n\x0c\n\x04\x05\x0c\x02\
    \x08\x12\x04\x90\x06\x02\x1a\n\r\n\x05\x05\x0c\x02\x08\x01\x12\x04\x90\
    \x06\x02\x15\n\r\n\x05\x05\x0c\x02\x08\x02\x12\x04\x90\x06\x18\x19\n\x0c\
    \n\x02\x05\r\x12\x06\x92\x06\0\x97\x06\x01\n\x0b\n\x03\x05\r\x01\x12\x04\
    \x92\x06\x05\x15\n\x0c\n\x04\x05\r\x02\0\x12\x04\x93\x06\x02\x18\n\r\n\
    \x05\x05\r\x02\0\x01\x12\x04\x93\x06\x02\x13\n\r\n\x05\x05\r\x02\0\x02\
    \x12\x04\x93\x06\x16\x17\n\x0c\n\x04\x05\r\x02\x01\x12\x04\x94\x06\x02\
    \x19\n\r\n\x05\x05\r\x02\x01\x01\x12\x04\x94\x06\x02\x14\n\r\n\x05\x05\r\
    \x02\x01\x02\x12\x04\x94\x06\x17\x18\n\x0c\n\x04\x05\r\x02\x02\x12\x04\
    \x95\x06\x02\x1d\n\r\n\x05\x05\r\x02\x02\x01\x12\x04\x95\x06\x02\x18\n\r\
    \n\x05\x05\r\x02\x02\x02\x12\x04\x95\x06\x1b\x1c\n\x0c\n\x04\x05\r\x02\
    \x03\x12\x04\x96\x06\x02\x1f\n\r\n\x05\x05\r\x02\x03\x01\x12\x04\x96\x06\
    \x02\x1a\n\r\n\x05\x05\r\x02\x03\x02\x12\x04\x96\x06\x1d\x1e\n\x0c\n\x02\
    \x05\x0e\x12\x06\x98\x06\0\xa0\x06\x01\n\x0b\n\x03\x05\x0e\x01\x12\x04\
    \x98\x06\x05\x12\n\x0c\n\x04\x05\x0e\x02\0\x12\x04\x99\x06\x02\x19\n\r\n\
    \x05\x05\x0e\x02\0\x01\x12\x04\x99\x06\x02\x14\n\r\n\x05\x05\x0e\x02\0\
    \x02\x12\x04\x99\x06\x17\x18\n3\n\x04\x05\x0e\x02\x01\x12\x04\x9b\x06\
    \x02\x1d\x1a%\x20values\x20same\x20as\x20mode\x20for\x20readability\n\n\
    \r\n\x05\x05\x0e\x02\x01\x01\x12\x04\x9b\x06\x02\x18\n\r\n\x05\x05\x0e\
    \x02\x01\x02\x12\x04\x9b\x06\x1b\x1c\n\x0c\n\x04\x05\x0e\x02\x02\x12\x04\
    \x9c\x06\x02\x1d\n\r\n\x05\x05\x0e\x02\x02\x01\x12\x04\x9c\x06\x02\x18\n\
    \r\n\x05\x05\x0e\x02\x02\x02\x12\x04\x9c\x06\x1b\x1c\n\x0c\n\x04\x05\x0e\
    \x02\x03\x12\x04\x9d\x06\x02\x1a\n\r\n\x05\x05\x0e\x02\x03\x01\x12\x04\
    \x9d\x06\x02\x15\n\r\n\x05\x05\x0e\x02\x03\x02\x12\x04\x9d\x06\x18\x19\n\
    \x0c\n\x04\x05\x0e\x02\x04\x12\x04\x9e\x06\x02\x1c\n\r\n\x05\x05\x0e\x02\
    \x04\x01\x12\x04\x9e\x06\x02\x17\n\r\n\x05\x05\x0e\x02\x04\x02\x12\x04\
    \x9e\x06\x1a\x1b\n\x0c\n\x04\x05\x0e\x02\x05\x12\x04\x9f\x06\x02\x19\n\r\
    \n\x05\x05\x0e\x02\x05\x01\x12\x04\x9f\x06\x02\x14\n\r\n\x05\x05\x0e\x02\
    \x05\x02\x12\x04\x9f\x06\x17\x18\n\x0c\n\x02\x05\x0f\x12\x06\xa1\x06\0\
    \xaa\x06\x01\n\x0b\n\x03\x05\x0f\x01\x12\x04\xa1\x06\x05\x12\n\x0c\n\x04\
    \x05\x0f\x02\0\x12\x04\xa2\x06\x02\x1a\n\r\n\x05\x05\x0f\x02\0\x01\x12\
    \x04\xa2\x06\x02\x15\n\r\n\x05\x05\x0f\x02\0\x02\x12\x04\xa2\x06\x18\x19\
    \n\x0c\n\x04\x05\x0f\x02\x01\x12\x04\xa3\x06\x02\x1a\n\r\n\x05\x05\x0f\
    \x02\x01\x01\x12\x04\xa3\x06\x02\x15\n\r\n\x05\x05\x0f\x02\x01\x02\x12\
    \x04\xa3\x06\x18\x19\n\x0c\n\x04\x05\x0f\x02\x02\x12\x04\xa4\x06\x02\x1a\
    \n\r\n\x05\x05\x0f\x02\x02\x01\x12\x04\xa4\x06\x02\x15\n\r\n\x05\x05\x0f\
    \x02\x02\x02\x12\x04\xa4\x06\x18\x19\n\x0c\n\x04\x05\x0f\x02\x03\x12\x04\
    \xa5\x06\x02\x1b\n\r\n\x05\x05\x0f\x02\x03\x01\x12\x04\xa5\x06\x02\x16\n\
    \r\n\x05\x05\x0f\x02\x03\x02\x12\x04\xa5\x06\x19\x1a\n\x0c\n\x04\x05\x0f\
    \x02\x04\x12\x04\xa6\x06\x02\x1d\n\r\n\x05\x05\x0f\x02\x04\x01\x12\x04\
    \xa6\x06\x02\x18\n\r\n\x05\x05\x0f\x02\x04\x02\x12\x04\xa6\x06\x1b\x1c\n\
    \x0c\n\x04\x05\x0f\x02\x05\x12\x04\xa7\x06\x02\x19\n\r\n\x05\x05\x0f\x02\
    \x05\x01\x12\x04\xa7\x06\x02\x14\n\r\n\x05\x05\x0f\x02\x05\x02\x12\x04\
    \xa7\x06\x17\x18\n\x0c\n\x04\x05\x0f\x02\x06\x12\x04\xa8\x06\x02\x1b\n\r\
    \n\x05\x05\x0f\x02\x06\x01\x12\x04\xa8\x06\x02\x16\n\r\n\x05\x05\x0f\x02\
    \x06\x02\x12\x04\xa8\x06\x19\x1a\n\x0c\n\x04\x05\x0f\x02\x07\x12\x04\xa9\
    \x06\x02\x1e\n\r\n\x05\x05\x0f\x02\x07\x01\x12\x04\xa9\x06\x02\x19\n\r\n\
    \x05\x05\x0f\x02\x07\x02\x12\x04\xa9\x06\x1c\x1d\n\x0c\n\x02\x040\x12\
    \x06\xab\x06\0\xc7\x06\x01\n\x0b\n\x03\x040\x01\x12\x04\xab\x06\x08#\n\
    \x0b\n\x03\x040\x07\x12\x04\xac\x06\x02\x13\n\r\n\x05\x040\x07\x8c\x08\
    \x12\x04\xac\x06\x02\x13\n\x0b\n\x03\x040\x07\x12\x04\xad\x06\x02\"\n\r\
    \n\x05\x040\x07\x8d\x08\x12\x04\xad\x06\x02\"\n\x0b\n\x03\x040\x07\x12\
    \x04\xae\x06\x02!\n\r\n\x05\x040\x07\x8e\x08\x12\x04\xae\x06\x02!\n\x0c\
    \n\x04\x040\x02\0\x12\x04\xb0\x06\x02\x17\n\r\n\x05\x040\x02\0\x05\x12\
    \x04\xb0\x06\x02\x08\n\r\n\x05\x040\x02\0\x01\x12\x04\xb0\x06\t\x12\n\r\
    \n\x05\x040\x02\0\x03\x12\x04\xb0\x06\x15\x16\n\x0c\n\x04\x040\x02\x01\
    \x12\x04\xb1\x06\x02\x12\n\r\n\x05\x040\x02\x01\x05\x12\x04\xb1\x06\x02\
    \t\n\r\n\x05\x040\x02\x01\x01\x12\x04\xb1\x06\n\r\n\r\n\x05\x040\x02\x01\
    \x03\x12\x04\xb1\x06\x10\x11\n\x0c\n\x04\x040\x02\x02\x12\x04\xb2\x06\
    \x02\x12\n\r\n\x05\x040\x02\x02\x05\x12\x04\xb2\x06\x02\x08\n\r\n\x05\
    \x040\x02\x02\x01\x12\x04\xb2\x06\t\r\n\r\n\x05\x040\x02\x02\x03\x12\x04\
    \xb2\x06\x10\x11\n\x0c\n\x04\x040\x02\x03\x12\x04\xb3\x06\x02\x17\n\r\n\
    \x05\x040\x02\x03\x05\x12\x04\xb3\x06\x02\x08\n\r\n\x05\x040\x02\x03\x01\
    \x12\x04\xb3\x06\t\x12\n\r\n\x05\x040\x02\x03\x03\x12\x04\xb3\x06\x15\
    \x16\n\x0c\n\x04\x040\x02\x04\x12\x04\xb5\x06\x02(\n\r\n\x05\x040\x02\
    \x04\x05\x12\x04\xb5\x06\x02\x06\n\r\n\x05\x040\x02\x04\x01\x12\x04\xb5\
    \x06\x07#\n\r\n\x05\x040\x02\x04\x03\x12\x04\xb5\x06&'\n\x0c\n\x04\x040\
    \x02\x05\x12\x04\xb6\x06\x021\n\r\n\x05\x040\x02\x05\x05\x12\x04\xb6\x06\
    \x02\x06\n\r\n\x05\x040\x02\x05\x01\x12\x04\xb6\x06\x07,\n\r\n\x05\x040\
    \x02\x05\x03\x12\x04\xb6\x06/0\n\x0c\n\x04\x040\x02\x06\x12\x04\xb7\x06\
    \x02+\n\r\n\x05\x040\x02\x06\x04\x12\x04\xb7\x06\x02\n\n\r\n\x05\x040\
    \x02\x06\x06\x12\x04\xb7\x06\x0b\x16\n\r\n\x05\x040\x02\x06\x01\x12\x04\
    \xb7\x06\x17&\n\r\n\x05\x040\x02\x06\x03\x12\x04\xb7\x06)*\n\x0c\n\x04\
    \x040\x02\x07\x12\x04\xb8\x06\x02#\n\r\n\x05\x040\x02\x07\x05\x12\x04\
    \xb8\x06\x02\x07\n\r\n\x05\x040\x02\x07\x01\x12\x04\xb8\x06\x08\x1e\n\r\
    \n\x05\x040\x02\x07\x03\x12\x04\xb8\x06!\"\n\x0c\n\x04\x040\x02\x08\x12\
    \x04\xb9\x06\x02#\n\r\n\x05\x040\x02\x08\x05\x12\x04\xb9\x06\x02\x07\n\r\
    \n\x05\x040\x02\x08\x01\x12\x04\xb9\x06\x08\x1e\n\r\n\x05\x040\x02\x08\
    \x03\x12\x04\xb9\x06!\"\n\x0c\n\x04\x040\x02\t\x12\x04\xba\x06\x02%\n\r\
    \n\x05\x040\x02\t\x05\x12\x04\xba\x06\x02\x07\n\r\n\x05\x040\x02\t\x01\
    \x12\x04\xba\x06\x08\x1f\n\r\n\x05\x040\x02\t\x03\x12\x04\xba\x06\"$\ns\
    \n\x04\x040\x02\n\x12\x04\xbd\x06\x02!\x1ae\x20for\x20older\x20peer\x20v\
    ersions\x20-\x20in\x20new\x20system\x20this\n\x20is\x20if\x20CLIMATE_PRE\
    SET_AWAY\x20exists\x20is\x20supported_presets\n\n\r\n\x05\x040\x02\n\x05\
    \x12\x04\xbd\x06\x02\x06\n\r\n\x05\x040\x02\n\x01\x12\x04\xbd\x06\x07\
    \x1b\n\r\n\x05\x040\x02\n\x03\x12\x04\xbd\x06\x1e\x20\n\x0c\n\x04\x040\
    \x02\x0b\x12\x04\xbe\x06\x02\x1c\n\r\n\x05\x040\x02\x0b\x05\x12\x04\xbe\
    \x06\x02\x06\n\r\n\x05\x040\x02\x0b\x01\x12\x04\xbe\x06\x07\x16\n\r\n\
    \x05\x040\x02\x0b\x03\x12\x04\xbe\x06\x19\x1b\n\x0c\n\x04\x040\x02\x0c\
    \x12\x04\xbf\x06\x023\n\r\n\x05\x040\x02\x0c\x04\x12\x04\xbf\x06\x02\n\n\
    \r\n\x05\x040\x02\x0c\x06\x12\x04\xbf\x06\x0b\x19\n\r\n\x05\x040\x02\x0c\
    \x01\x12\x04\xbf\x06\x1a-\n\r\n\x05\x040\x02\x0c\x03\x12\x04\xbf\x0602\n\
    \x0c\n\x04\x040\x02\r\x12\x04\xc0\x06\x027\n\r\n\x05\x040\x02\r\x04\x12\
    \x04\xc0\x06\x02\n\n\r\n\x05\x040\x02\r\x06\x12\x04\xc0\x06\x0b\x1b\n\r\
    \n\x05\x040\x02\r\x01\x12\x04\xc0\x06\x1c1\n\r\n\x05\x040\x02\r\x03\x12\
    \x04\xc0\x0646\n\x0c\n\x04\x040\x02\x0e\x12\x04\xc1\x06\x022\n\r\n\x05\
    \x040\x02\x0e\x04\x12\x04\xc1\x06\x02\n\n\r\n\x05\x040\x02\x0e\x05\x12\
    \x04\xc1\x06\x0b\x11\n\r\n\x05\x040\x02\x0e\x01\x12\x04\xc1\x06\x12,\n\r\
    \n\x05\x040\x02\x0e\x03\x12\x04\xc1\x06/1\n\x0c\n\x04\x040\x02\x0f\x12\
    \x04\xc2\x06\x020\n\r\n\x05\x040\x02\x0f\x04\x12\x04\xc2\x06\x02\n\n\r\n\
    \x05\x040\x02\x0f\x06\x12\x04\xc2\x06\x0b\x18\n\r\n\x05\x040\x02\x0f\x01\
    \x12\x04\xc2\x06\x19*\n\r\n\x05\x040\x02\x0f\x03\x12\x04\xc2\x06-/\n\x0c\
    \n\x04\x040\x02\x10\x12\x04\xc3\x06\x020\n\r\n\x05\x040\x02\x10\x04\x12\
    \x04\xc3\x06\x02\n\n\r\n\x05\x040\x02\x10\x05\x12\x04\xc3\x06\x0b\x11\n\
    \r\n\x05\x040\x02\x10\x01\x12\x04\xc3\x06\x12*\n\r\n\x05\x040\x02\x10\
    \x03\x12\x04\xc3\x06-/\n\x0c\n\x04\x040\x02\x11\x12\x04\xc4\x06\x02\x20\
    \n\r\n\x05\x040\x02\x11\x05\x12\x04\xc4\x06\x02\x06\n\r\n\x05\x040\x02\
    \x11\x01\x12\x04\xc4\x06\x07\x1a\n\r\n\x05\x040\x02\x11\x03\x12\x04\xc4\
    \x06\x1d\x1f\n\x0c\n\x04\x040\x02\x12\x12\x04\xc5\x06\x02\x13\n\r\n\x05\
    \x040\x02\x12\x05\x12\x04\xc5\x06\x02\x08\n\r\n\x05\x040\x02\x12\x01\x12\
    \x04\xc5\x06\t\r\n\r\n\x05\x040\x02\x12\x03\x12\x04\xc5\x06\x10\x12\n\
    \x0c\n\x04\x040\x02\x13\x12\x04\xc6\x06\x02&\n\r\n\x05\x040\x02\x13\x06\
    \x12\x04\xc6\x06\x02\x10\n\r\n\x05\x040\x02\x13\x01\x12\x04\xc6\x06\x11\
    \x20\n\r\n\x05\x040\x02\x13\x03\x12\x04\xc6\x06#%\n\x0c\n\x02\x041\x12\
    \x06\xc8\x06\0\xdc\x06\x01\n\x0b\n\x03\x041\x01\x12\x04\xc8\x06\x08\x1c\
    \n\x0b\n\x03\x041\x07\x12\x04\xc9\x06\x02\x13\n\r\n\x05\x041\x07\x8c\x08\
    \x12\x04\xc9\x06\x02\x13\n\x0b\n\x03\x041\x07\x12\x04\xca\x06\x02\"\n\r\
    \n\x05\x041\x07\x8d\x08\x12\x04\xca\x06\x02\"\n\x0b\n\x03\x041\x07\x12\
    \x04\xcb\x06\x02!\n\r\n\x05\x041\x07\x8e\x08\x12\x04\xcb\x06\x02!\n\x0b\
    \n\x03\x041\x07\x12\x04\xcc\x06\x02\x1b\n\r\n\x05\x041\x07\x90\x08\x12\
    \x04\xcc\x06\x02\x1b\n\x0c\n\x04\x041\x02\0\x12\x04\xce\x06\x02\x12\n\r\
    \n\x05\x041\x02\0\x05\x12\x04\xce\x06\x02\t\n\r\n\x05\x041\x02\0\x01\x12\
    \x04\xce\x06\n\r\n\r\n\x05\x041\x02\0\x03\x12\x04\xce\x06\x10\x11\n\x0c\
    \n\x04\x041\x02\x01\x12\x04\xcf\x06\x02\x17\n\r\n\x05\x041\x02\x01\x06\
    \x12\x04\xcf\x06\x02\r\n\r\n\x05\x041\x02\x01\x01\x12\x04\xcf\x06\x0e\
    \x12\n\r\n\x05\x041\x02\x01\x03\x12\x04\xcf\x06\x15\x16\n\x0c\n\x04\x041\
    \x02\x02\x12\x04\xd0\x06\x02\x20\n\r\n\x05\x041\x02\x02\x05\x12\x04\xd0\
    \x06\x02\x07\n\r\n\x05\x041\x02\x02\x01\x12\x04\xd0\x06\x08\x1b\n\r\n\
    \x05\x041\x02\x02\x03\x12\x04\xd0\x06\x1e\x1f\n\x0c\n\x04\x041\x02\x03\
    \x12\x04\xd1\x06\x02\x1f\n\r\n\x05\x041\x02\x03\x05\x12\x04\xd1\x06\x02\
    \x07\n\r\n\x05\x041\x02\x03\x01\x12\x04\xd1\x06\x08\x1a\n\r\n\x05\x041\
    \x02\x03\x03\x12\x04\xd1\x06\x1d\x1e\n\x0c\n\x04\x041\x02\x04\x12\x04\
    \xd2\x06\x02#\n\r\n\x05\x041\x02\x04\x05\x12\x04\xd2\x06\x02\x07\n\r\n\
    \x05\x041\x02\x04\x01\x12\x04\xd2\x06\x08\x1e\n\r\n\x05\x041\x02\x04\x03\
    \x12\x04\xd2\x06!\"\n\x0c\n\x04\x041\x02\x05\x12\x04\xd3\x06\x02$\n\r\n\
    \x05\x041\x02\x05\x05\x12\x04\xd3\x06\x02\x07\n\r\n\x05\x041\x02\x05\x01\
    \x12\x04\xd3\x06\x08\x1f\n\r\n\x05\x041\x02\x05\x03\x12\x04\xd3\x06\"#\n\
    G\n\x04\x041\x02\x06\x12\x04\xd5\x06\x02\x17\x1a9\x20For\x20older\x20pee\
    rs,\x20equal\x20to\x20preset\x20==\x20CLIMATE_PRESET_AWAY\n\n\r\n\x05\
    \x041\x02\x06\x05\x12\x04\xd5\x06\x02\x06\n\r\n\x05\x041\x02\x06\x01\x12\
    \x04\xd5\x06\x07\x12\n\r\n\x05\x041\x02\x06\x03\x12\x04\xd5\x06\x15\x16\
    \n\x0c\n\x04\x041\x02\x07\x12\x04\xd6\x06\x02\x1b\n\r\n\x05\x041\x02\x07\
    \x06\x12\x04\xd6\x06\x02\x0f\n\r\n\x05\x041\x02\x07\x01\x12\x04\xd6\x06\
    \x10\x16\n\r\n\x05\x041\x02\x07\x03\x12\x04\xd6\x06\x19\x1a\n\x0c\n\x04\
    \x041\x02\x08\x12\x04\xd7\x06\x02\x1e\n\r\n\x05\x041\x02\x08\x06\x12\x04\
    \xd7\x06\x02\x10\n\r\n\x05\x041\x02\x08\x01\x12\x04\xd7\x06\x11\x19\n\r\
    \n\x05\x041\x02\x08\x03\x12\x04\xd7\x06\x1c\x1d\n\x0c\n\x04\x041\x02\t\
    \x12\x04\xd8\x06\x02#\n\r\n\x05\x041\x02\t\x06\x12\x04\xd8\x06\x02\x12\n\
    \r\n\x05\x041\x02\t\x01\x12\x04\xd8\x06\x13\x1d\n\r\n\x05\x041\x02\t\x03\
    \x12\x04\xd8\x06\x20\"\n\x0c\n\x04\x041\x02\n\x12\x04\xd9\x06\x02\x1e\n\
    \r\n\x05\x041\x02\n\x05\x12\x04\xd9\x06\x02\x08\n\r\n\x05\x041\x02\n\x01\
    \x12\x04\xd9\x06\t\x18\n\r\n\x05\x041\x02\n\x03\x12\x04\xd9\x06\x1b\x1d\
    \n\x0c\n\x04\x041\x02\x0b\x12\x04\xda\x06\x02\x1c\n\r\n\x05\x041\x02\x0b\
    \x06\x12\x04\xda\x06\x02\x0f\n\r\n\x05\x041\x02\x0b\x01\x12\x04\xda\x06\
    \x10\x16\n\r\n\x05\x041\x02\x0b\x03\x12\x04\xda\x06\x19\x1b\n\x0c\n\x04\
    \x041\x02\x0c\x12\x04\xdb\x06\x02\x1c\n\r\n\x05\x041\x02\x0c\x05\x12\x04\
    \xdb\x06\x02\x08\n\r\n\x05\x041\x02\x0c\x01\x12\x04\xdb\x06\t\x16\n\r\n\
    \x05\x041\x02\x0c\x03\x12\x04\xdb\x06\x19\x1b\n\x0c\n\x02\x042\x12\x06\
    \xdd\x06\0\xf9\x06\x01\n\x0b\n\x03\x042\x01\x12\x04\xdd\x06\x08\x1d\n\
    \x0b\n\x03\x042\x07\x12\x04\xde\x06\x02\x13\n\r\n\x05\x042\x07\x8c\x08\
    \x12\x04\xde\x06\x02\x13\n\x0b\n\x03\x042\x07\x12\x04\xdf\x06\x02\"\n\r\
    \n\x05\x042\x07\x8d\x08\x12\x04\xdf\x06\x02\"\n\x0b\n\x03\x042\x07\x12\
    \x04\xe0\x06\x02!\n\r\n\x05\x042\x07\x8e\x08\x12\x04\xe0\x06\x02!\n\x0b\
    \n\x03\x042\x07\x12\x04\xe1\x06\x02\x1b\n\r\n\x05\x042\x07\x90\x08\x12\
    \x04\xe1\x06\x02\x1b\n\x0c\n\x04\x042\x02\0\x12\x04\xe3\x06\x02\x12\n\r\
    \n\x05\x042\x02\0\x05\x12\x04\xe3\x06\x02\t\n\r\n\x05\x042\x02\0\x01\x12\
    \x04\xe3\x06\n\r\n\r\n\x05\x042\x02\0\x03\x12\x04\xe3\x06\x10\x11\n\x0c\
    \n\x04\x042\x02\x01\x12\x04\xe4\x06\x02\x14\n\r\n\x05\x042\x02\x01\x05\
    \x12\x04\xe4\x06\x02\x06\n\r\n\x05\x042\x02\x01\x01\x12\x04\xe4\x06\x07\
    \x0f\n\r\n\x05\x042\x02\x01\x03\x12\x04\xe4\x06\x12\x13\n\x0c\n\x04\x042\
    \x02\x02\x12\x04\xe5\x06\x02\x17\n\r\n\x05\x042\x02\x02\x06\x12\x04\xe5\
    \x06\x02\r\n\r\n\x05\x042\x02\x02\x01\x12\x04\xe5\x06\x0e\x12\n\r\n\x05\
    \x042\x02\x02\x03\x12\x04\xe5\x06\x15\x16\n\x0c\n\x04\x042\x02\x03\x12\
    \x04\xe6\x06\x02\"\n\r\n\x05\x042\x02\x03\x05\x12\x04\xe6\x06\x02\x06\n\
    \r\n\x05\x042\x02\x03\x01\x12\x04\xe6\x06\x07\x1d\n\r\n\x05\x042\x02\x03\
    \x03\x12\x04\xe6\x06\x20!\n\x0c\n\x04\x042\x02\x04\x12\x04\xe7\x06\x02\
    \x1f\n\r\n\x05\x042\x02\x04\x05\x12\x04\xe7\x06\x02\x07\n\r\n\x05\x042\
    \x02\x04\x01\x12\x04\xe7\x06\x08\x1a\n\r\n\x05\x042\x02\x04\x03\x12\x04\
    \xe7\x06\x1d\x1e\n\x0c\n\x04\x042\x02\x05\x12\x04\xe8\x06\x02&\n\r\n\x05\
    \x042\x02\x05\x05\x12\x04\xe8\x06\x02\x06\n\r\n\x05\x042\x02\x05\x01\x12\
    \x04\xe8\x06\x07!\n\r\n\x05\x042\x02\x05\x03\x12\x04\xe8\x06$%\n\x0c\n\
    \x04\x042\x02\x06\x12\x04\xe9\x06\x02#\n\r\n\x05\x042\x02\x06\x05\x12\
    \x04\xe9\x06\x02\x07\n\r\n\x05\x042\x02\x06\x01\x12\x04\xe9\x06\x08\x1e\
    \n\r\n\x05\x042\x02\x06\x03\x12\x04\xe9\x06!\"\n\x0c\n\x04\x042\x02\x07\
    \x12\x04\xea\x06\x02'\n\r\n\x05\x042\x02\x07\x05\x12\x04\xea\x06\x02\x06\
    \n\r\n\x05\x042\x02\x07\x01\x12\x04\xea\x06\x07\"\n\r\n\x05\x042\x02\x07\
    \x03\x12\x04\xea\x06%&\n\x0c\n\x04\x042\x02\x08\x12\x04\xeb\x06\x02$\n\r\
    \n\x05\x042\x02\x08\x05\x12\x04\xeb\x06\x02\x07\n\r\n\x05\x042\x02\x08\
    \x01\x12\x04\xeb\x06\x08\x1f\n\r\n\x05\x042\x02\x08\x03\x12\x04\xeb\x06\
    \"#\n\\\n\x04\x042\x02\t\x12\x04\xed\x06\x02\x1c\x1aN\x20legacy,\x20for\
    \x20older\x20peers,\x20newer\x20ones\x20should\x20use\x20CLIMATE_PRESET_\
    AWAY\x20in\x20preset\n\n\r\n\x05\x042\x02\t\x05\x12\x04\xed\x06\x02\x06\
    \n\r\n\x05\x042\x02\t\x01\x12\x04\xed\x06\x07\x16\n\r\n\x05\x042\x02\t\
    \x03\x12\x04\xed\x06\x19\x1b\n\x0c\n\x04\x042\x02\n\x12\x04\xee\x06\x02\
    \x18\n\r\n\x05\x042\x02\n\x05\x12\x04\xee\x06\x02\x06\n\r\n\x05\x042\x02\
    \n\x01\x12\x04\xee\x06\x07\x12\n\r\n\x05\x042\x02\n\x03\x12\x04\xee\x06\
    \x15\x17\n\x0c\n\x04\x042\x02\x0b\x12\x04\xef\x06\x02\x19\n\r\n\x05\x042\
    \x02\x0b\x05\x12\x04\xef\x06\x02\x06\n\r\n\x05\x042\x02\x0b\x01\x12\x04\
    \xef\x06\x07\x13\n\r\n\x05\x042\x02\x0b\x03\x12\x04\xef\x06\x16\x18\n\
    \x0c\n\x04\x042\x02\x0c\x12\x04\xf0\x06\x02\x1f\n\r\n\x05\x042\x02\x0c\
    \x06\x12\x04\xf0\x06\x02\x10\n\r\n\x05\x042\x02\x0c\x01\x12\x04\xf0\x06\
    \x11\x19\n\r\n\x05\x042\x02\x0c\x03\x12\x04\xf0\x06\x1c\x1e\n\x0c\n\x04\
    \x042\x02\r\x12\x04\xf1\x06\x02\x1b\n\r\n\x05\x042\x02\r\x05\x12\x04\xf1\
    \x06\x02\x06\n\r\n\x05\x042\x02\r\x01\x12\x04\xf1\x06\x07\x15\n\r\n\x05\
    \x042\x02\r\x03\x12\x04\xf1\x06\x18\x1a\n\x0c\n\x04\x042\x02\x0e\x12\x04\
    \xf2\x06\x02#\n\r\n\x05\x042\x02\x0e\x06\x12\x04\xf2\x06\x02\x12\n\r\n\
    \x05\x042\x02\x0e\x01\x12\x04\xf2\x06\x13\x1d\n\r\n\x05\x042\x02\x0e\x03\
    \x12\x04\xf2\x06\x20\"\n\x0c\n\x04\x042\x02\x0f\x12\x04\xf3\x06\x02\x20\
    \n\r\n\x05\x042\x02\x0f\x05\x12\x04\xf3\x06\x02\x06\n\r\n\x05\x042\x02\
    \x0f\x01\x12\x04\xf3\x06\x07\x1a\n\r\n\x05\x042\x02\x0f\x03\x12\x04\xf3\
    \x06\x1d\x1f\n\x0c\n\x04\x042\x02\x10\x12\x04\xf4\x06\x02\x1e\n\r\n\x05\
    \x042\x02\x10\x05\x12\x04\xf4\x06\x02\x08\n\r\n\x05\x042\x02\x10\x01\x12\
    \x04\xf4\x06\t\x18\n\r\n\x05\x042\x02\x10\x03\x12\x04\xf4\x06\x1b\x1d\n\
    \x0c\n\x04\x042\x02\x11\x12\x04\xf5\x06\x02\x17\n\r\n\x05\x042\x02\x11\
    \x05\x12\x04\xf5\x06\x02\x06\n\r\n\x05\x042\x02\x11\x01\x12\x04\xf5\x06\
    \x07\x11\n\r\n\x05\x042\x02\x11\x03\x12\x04\xf5\x06\x14\x16\n\x0c\n\x04\
    \x042\x02\x12\x12\x04\xf6\x06\x02\x1c\n\r\n\x05\x042\x02\x12\x06\x12\x04\
    \xf6\x06\x02\x0f\n\r\n\x05\x042\x02\x12\x01\x12\x04\xf6\x06\x10\x16\n\r\
    \n\x05\x042\x02\x12\x03\x12\x04\xf6\x06\x19\x1b\n\x0c\n\x04\x042\x02\x13\
    \x12\x04\xf7\x06\x02\x1e\n\r\n\x05\x042\x02\x13\x05\x12\x04\xf7\x06\x02\
    \x06\n\r\n\x05\x042\x02\x13\x01\x12\x04\xf7\x06\x07\x18\n\r\n\x05\x042\
    \x02\x13\x03\x12\x04\xf7\x06\x1b\x1d\n\x0c\n\x04\x042\x02\x14\x12\x04\
    \xf8\x06\x02\x1c\n\r\n\x05\x042\x02\x14\x05\x12\x04\xf8\x06\x02\x08\n\r\
    \n\x05\x042\x02\x14\x01\x12\x04\xf8\x06\t\x16\n\r\n\x05\x042\x02\x14\x03\
    \x12\x04\xf8\x06\x19\x1b\n@\n\x02\x05\x10\x12\x06\xfc\x06\0\x80\x07\x01\
    \x1a2\x20====================\x20NUMBER\x20====================\n\n\x0b\
    \n\x03\x05\x10\x01\x12\x04\xfc\x06\x05\x0f\n\x0c\n\x04\x05\x10\x02\0\x12\
    \x04\xfd\x06\x02\x17\n\r\n\x05\x05\x10\x02\0\x01\x12\x04\xfd\x06\x02\x12\
    \n\r\n\x05\x05\x10\x02\0\x02\x12\x04\xfd\x06\x15\x16\n\x0c\n\x04\x05\x10\
    \x02\x01\x12\x04\xfe\x06\x02\x16\n\r\n\x05\x05\x10\x02\x01\x01\x12\x04\
    \xfe\x06\x02\x11\n\r\n\x05\x05\x10\x02\x01\x02\x12\x04\xfe\x06\x14\x15\n\
    \x0c\n\x04\x05\x10\x02\x02\x12\x04\xff\x06\x02\x19\n\r\n\x05\x05\x10\x02\
    \x02\x01\x12\x04\xff\x06\x02\x14\n\r\n\x05\x05\x10\x02\x02\x02\x12\x04\
    \xff\x06\x17\x18\n\x0c\n\x02\x043\x12\x06\x81\x07\0\x93\x07\x01\n\x0b\n\
    \x03\x043\x01\x12\x04\x81\x07\x08\"\n\x0b\n\x03\x043\x07\x12\x04\x82\x07\
    \x02\x13\n\r\n\x05\x043\x07\x8c\x08\x12\x04\x82\x07\x02\x13\n\x0b\n\x03\
    \x043\x07\x12\x04\x83\x07\x02\"\n\r\n\x05\x043\x07\x8d\x08\x12\x04\x83\
    \x07\x02\"\n\x0b\n\x03\x043\x07\x12\x04\x84\x07\x02\x20\n\r\n\x05\x043\
    \x07\x8e\x08\x12\x04\x84\x07\x02\x20\n\x0c\n\x04\x043\x02\0\x12\x04\x86\
    \x07\x02\x17\n\r\n\x05\x043\x02\0\x05\x12\x04\x86\x07\x02\x08\n\r\n\x05\
    \x043\x02\0\x01\x12\x04\x86\x07\t\x12\n\r\n\x05\x043\x02\0\x03\x12\x04\
    \x86\x07\x15\x16\n\x0c\n\x04\x043\x02\x01\x12\x04\x87\x07\x02\x12\n\r\n\
    \x05\x043\x02\x01\x05\x12\x04\x87\x07\x02\t\n\r\n\x05\x043\x02\x01\x01\
    \x12\x04\x87\x07\n\r\n\r\n\x05\x043\x02\x01\x03\x12\x04\x87\x07\x10\x11\
    \n\x0c\n\x04\x043\x02\x02\x12\x04\x88\x07\x02\x12\n\r\n\x05\x043\x02\x02\
    \x05\x12\x04\x88\x07\x02\x08\n\r\n\x05\x043\x02\x02\x01\x12\x04\x88\x07\
    \t\r\n\r\n\x05\x043\x02\x02\x03\x12\x04\x88\x07\x10\x11\n\x0c\n\x04\x043\
    \x02\x03\x12\x04\x89\x07\x02\x17\n\r\n\x05\x043\x02\x03\x05\x12\x04\x89\
    \x07\x02\x08\n\r\n\x05\x043\x02\x03\x01\x12\x04\x89\x07\t\x12\n\r\n\x05\
    \x043\x02\x03\x03\x12\x04\x89\x07\x15\x16\n\x0c\n\x04\x043\x02\x04\x12\
    \x04\x8b\x07\x02\x12\n\r\n\x05\x043\x02\x04\x05\x12\x04\x8b\x07\x02\x08\
    \n\r\n\x05\x043\x02\x04\x01\x12\x04\x8b\x07\t\r\n\r\n\x05\x043\x02\x04\
    \x03\x12\x04\x8b\x07\x10\x11\n\x0c\n\x04\x043\x02\x05\x12\x04\x8c\x07\
    \x02\x16\n\r\n\x05\x043\x02\x05\x05\x12\x04\x8c\x07\x02\x07\n\r\n\x05\
    \x043\x02\x05\x01\x12\x04\x8c\x07\x08\x11\n\r\n\x05\x043\x02\x05\x03\x12\
    \x04\x8c\x07\x14\x15\n\x0c\n\x04\x043\x02\x06\x12\x04\x8d\x07\x02\x16\n\
    \r\n\x05\x043\x02\x06\x05\x12\x04\x8d\x07\x02\x07\n\r\n\x05\x043\x02\x06\
    \x01\x12\x04\x8d\x07\x08\x11\n\r\n\x05\x043\x02\x06\x03\x12\x04\x8d\x07\
    \x14\x15\n\x0c\n\x04\x043\x02\x07\x12\x04\x8e\x07\x02\x11\n\r\n\x05\x043\
    \x02\x07\x05\x12\x04\x8e\x07\x02\x07\n\r\n\x05\x043\x02\x07\x01\x12\x04\
    \x8e\x07\x08\x0c\n\r\n\x05\x043\x02\x07\x03\x12\x04\x8e\x07\x0f\x10\n\
    \x0c\n\x04\x043\x02\x08\x12\x04\x8f\x07\x02\x1f\n\r\n\x05\x043\x02\x08\
    \x05\x12\x04\x8f\x07\x02\x06\n\r\n\x05\x043\x02\x08\x01\x12\x04\x8f\x07\
    \x07\x1a\n\r\n\x05\x043\x02\x08\x03\x12\x04\x8f\x07\x1d\x1e\n\x0c\n\x04\
    \x043\x02\t\x12\x04\x90\x07\x02&\n\r\n\x05\x043\x02\t\x06\x12\x04\x90\
    \x07\x02\x10\n\r\n\x05\x043\x02\t\x01\x12\x04\x90\x07\x11\x20\n\r\n\x05\
    \x043\x02\t\x03\x12\x04\x90\x07#%\n\x0c\n\x04\x043\x02\n\x12\x04\x91\x07\
    \x02\"\n\r\n\x05\x043\x02\n\x05\x12\x04\x91\x07\x02\x08\n\r\n\x05\x043\
    \x02\n\x01\x12\x04\x91\x07\t\x1c\n\r\n\x05\x043\x02\n\x03\x12\x04\x91\
    \x07\x1f!\n\x0c\n\x04\x043\x02\x0b\x12\x04\x92\x07\x02\x17\n\r\n\x05\x04\
    3\x02\x0b\x06\x12\x04\x92\x07\x02\x0c\n\r\n\x05\x043\x02\x0b\x01\x12\x04\
    \x92\x07\r\x11\n\r\n\x05\x043\x02\x0b\x03\x12\x04\x92\x07\x14\x16\n\x0c\
    \n\x02\x044\x12\x06\x94\x07\0\x9f\x07\x01\n\x0b\n\x03\x044\x01\x12\x04\
    \x94\x07\x08\x1b\n\x0b\n\x03\x044\x07\x12\x04\x95\x07\x02\x13\n\r\n\x05\
    \x044\x07\x8c\x08\x12\x04\x95\x07\x02\x13\n\x0b\n\x03\x044\x07\x12\x04\
    \x96\x07\x02\"\n\r\n\x05\x044\x07\x8d\x08\x12\x04\x96\x07\x02\"\n\x0b\n\
    \x03\x044\x07\x12\x04\x97\x07\x02\x20\n\r\n\x05\x044\x07\x8e\x08\x12\x04\
    \x97\x07\x02\x20\n\x0b\n\x03\x044\x07\x12\x04\x98\x07\x02\x1b\n\r\n\x05\
    \x044\x07\x90\x08\x12\x04\x98\x07\x02\x1b\n\x0c\n\x04\x044\x02\0\x12\x04\
    \x9a\x07\x02\x12\n\r\n\x05\x044\x02\0\x05\x12\x04\x9a\x07\x02\t\n\r\n\
    \x05\x044\x02\0\x01\x12\x04\x9a\x07\n\r\n\r\n\x05\x044\x02\0\x03\x12\x04\
    \x9a\x07\x10\x11\n\x0c\n\x04\x044\x02\x01\x12\x04\x9b\x07\x02\x12\n\r\n\
    \x05\x044\x02\x01\x05\x12\x04\x9b\x07\x02\x07\n\r\n\x05\x044\x02\x01\x01\
    \x12\x04\x9b\x07\x08\r\n\r\n\x05\x044\x02\x01\x03\x12\x04\x9b\x07\x10\
    \x11\n\x90\x01\n\x04\x044\x02\x02\x12\x04\x9e\x07\x02\x19\x1a\x81\x01\
    \x20If\x20the\x20number\x20does\x20not\x20have\x20a\x20valid\x20state\
    \x20yet.\n\x20Equivalent\x20to\x20`!obj->has_state()`\x20-\x20inverse\
    \x20logic\x20to\x20make\x20state\x20packets\x20smaller\n\n\r\n\x05\x044\
    \x02\x02\x05\x12\x04\x9e\x07\x02\x06\n\r\n\x05\x044\x02\x02\x01\x12\x04\
    \x9e\x07\x07\x14\n\r\n\x05\x044\x02\x02\x03\x12\x04\x9e\x07\x17\x18\n\
    \x0c\n\x02\x045\x12\x06\xa0\x07\0\xa8\x07\x01\n\x0b\n\x03\x045\x01\x12\
    \x04\xa0\x07\x08\x1c\n\x0b\n\x03\x045\x07\x12\x04\xa1\x07\x02\x13\n\r\n\
    \x05\x045\x07\x8c\x08\x12\x04\xa1\x07\x02\x13\n\x0b\n\x03\x045\x07\x12\
    \x04\xa2\x07\x02\"\n\r\n\x05\x045\x07\x8d\x08\x12\x04\xa2\x07\x02\"\n\
    \x0b\n\x03\x045\x07\x12\x04\xa3\x07\x02\x20\n\r\n\x05\x045\x07\x8e\x08\
    \x12\x04\xa3\x07\x02\x20\n\x0b\n\x03\x045\x07\x12\x04\xa4\x07\x02\x1b\n\
    \r\n\x05\x045\x07\x90\x08\x12\x04\xa4\x07\x02\x1b\n\x0c\n\x04\x045\x02\0\
    \x12\x04\xa6\x07\x02\x12\n\r\n\x05\x045\x02\0\x05\x12\x04\xa6\x07\x02\t\
    \n\r\n\x05\x045\x02\0\x01\x12\x04\xa6\x07\n\r\n\r\n\x05\x045\x02\0\x03\
    \x12\x04\xa6\x07\x10\x11\n\x0c\n\x04\x045\x02\x01\x12\x04\xa7\x07\x02\
    \x12\n\r\n\x05\x045\x02\x01\x05\x12\x04\xa7\x07\x02\x07\n\r\n\x05\x045\
    \x02\x01\x01\x12\x04\xa7\x07\x08\r\n\r\n\x05\x045\x02\x01\x03\x12\x04\
    \xa7\x07\x10\x11\n@\n\x02\x046\x12\x06\xab\x07\0\xb9\x07\x01\x1a2\x20===\
    =================\x20SELECT\x20====================\n\n\x0b\n\x03\x046\
    \x01\x12\x04\xab\x07\x08\"\n\x0b\n\x03\x046\x07\x12\x04\xac\x07\x02\x13\
    \n\r\n\x05\x046\x07\x8c\x08\x12\x04\xac\x07\x02\x13\n\x0b\n\x03\x046\x07\
    \x12\x04\xad\x07\x02\"\n\r\n\x05\x046\x07\x8d\x08\x12\x04\xad\x07\x02\"\
    \n\x0b\n\x03\x046\x07\x12\x04\xae\x07\x02\x20\n\r\n\x05\x046\x07\x8e\x08\
    \x12\x04\xae\x07\x02\x20\n\x0c\n\x04\x046\x02\0\x12\x04\xb0\x07\x02\x17\
    \n\r\n\x05\x046\x02\0\x05\x12\x04\xb0\x07\x02\x08\n\r\n\x05\x046\x02\0\
    \x01\x12\x04\xb0\x07\t\x12\n\r\n\x05\x046\x02\0\x03\x12\x04\xb0\x07\x15\
    \x16\n\x0c\n\x04\x046\x02\x01\x12\x04\xb1\x07\x02\x12\n\r\n\x05\x046\x02\
    \x01\x05\x12\x04\xb1\x07\x02\t\n\r\n\x05\x046\x02\x01\x01\x12\x04\xb1\
    \x07\n\r\n\r\n\x05\x046\x02\x01\x03\x12\x04\xb1\x07\x10\x11\n\x0c\n\x04\
    \x046\x02\x02\x12\x04\xb2\x07\x02\x12\n\r\n\x05\x046\x02\x02\x05\x12\x04\
    \xb2\x07\x02\x08\n\r\n\x05\x046\x02\x02\x01\x12\x04\xb2\x07\t\r\n\r\n\
    \x05\x046\x02\x02\x03\x12\x04\xb2\x07\x10\x11\n\x0c\n\x04\x046\x02\x03\
    \x12\x04\xb3\x07\x02\x17\n\r\n\x05\x046\x02\x03\x05\x12\x04\xb3\x07\x02\
    \x08\n\r\n\x05\x046\x02\x03\x01\x12\x04\xb3\x07\t\x12\n\r\n\x05\x046\x02\
    \x03\x03\x12\x04\xb3\x07\x15\x16\n\x0c\n\x04\x046\x02\x04\x12\x04\xb5\
    \x07\x02\x12\n\r\n\x05\x046\x02\x04\x05\x12\x04\xb5\x07\x02\x08\n\r\n\
    \x05\x046\x02\x04\x01\x12\x04\xb5\x07\t\r\n\r\n\x05\x046\x02\x04\x03\x12\
    \x04\xb5\x07\x10\x11\n\x0c\n\x04\x046\x02\x05\x12\x04\xb6\x07\x02\x1e\n\
    \r\n\x05\x046\x02\x05\x04\x12\x04\xb6\x07\x02\n\n\r\n\x05\x046\x02\x05\
    \x05\x12\x04\xb6\x07\x0b\x11\n\r\n\x05\x046\x02\x05\x01\x12\x04\xb6\x07\
    \x12\x19\n\r\n\x05\x046\x02\x05\x03\x12\x04\xb6\x07\x1c\x1d\n\x0c\n\x04\
    \x046\x02\x06\x12\x04\xb7\x07\x02\x1f\n\r\n\x05\x046\x02\x06\x05\x12\x04\
    \xb7\x07\x02\x06\n\r\n\x05\x046\x02\x06\x01\x12\x04\xb7\x07\x07\x1a\n\r\
    \n\x05\x046\x02\x06\x03\x12\x04\xb7\x07\x1d\x1e\n\x0c\n\x04\x046\x02\x07\
    \x12\x04\xb8\x07\x02%\n\r\n\x05\x046\x02\x07\x06\x12\x04\xb8\x07\x02\x10\
    \n\r\n\x05\x046\x02\x07\x01\x12\x04\xb8\x07\x11\x20\n\r\n\x05\x046\x02\
    \x07\x03\x12\x04\xb8\x07#$\n\x0c\n\x02\x047\x12\x06\xba\x07\0\xc5\x07\
    \x01\n\x0b\n\x03\x047\x01\x12\x04\xba\x07\x08\x1b\n\x0b\n\x03\x047\x07\
    \x12\x04\xbb\x07\x02\x13\n\r\n\x05\x047\x07\x8c\x08\x12\x04\xbb\x07\x02\
    \x13\n\x0b\n\x03\x047\x07\x12\x04\xbc\x07\x02\"\n\r\n\x05\x047\x07\x8d\
    \x08\x12\x04\xbc\x07\x02\"\n\x0b\n\x03\x047\x07\x12\x04\xbd\x07\x02\x20\
    \n\r\n\x05\x047\x07\x8e\x08\x12\x04\xbd\x07\x02\x20\n\x0b\n\x03\x047\x07\
    \x12\x04\xbe\x07\x02\x1b\n\r\n\x05\x047\x07\x90\x08\x12\x04\xbe\x07\x02\
    \x1b\n\x0c\n\x04\x047\x02\0\x12\x04\xc0\x07\x02\x12\n\r\n\x05\x047\x02\0\
    \x05\x12\x04\xc0\x07\x02\t\n\r\n\x05\x047\x02\0\x01\x12\x04\xc0\x07\n\r\
    \n\r\n\x05\x047\x02\0\x03\x12\x04\xc0\x07\x10\x11\n\x0c\n\x04\x047\x02\
    \x01\x12\x04\xc1\x07\x02\x13\n\r\n\x05\x047\x02\x01\x05\x12\x04\xc1\x07\
    \x02\x08\n\r\n\x05\x047\x02\x01\x01\x12\x04\xc1\x07\t\x0e\n\r\n\x05\x047\
    \x02\x01\x03\x12\x04\xc1\x07\x11\x12\n\x90\x01\n\x04\x047\x02\x02\x12\
    \x04\xc4\x07\x02\x19\x1a\x81\x01\x20If\x20the\x20select\x20does\x20not\
    \x20have\x20a\x20valid\x20state\x20yet.\n\x20Equivalent\x20to\x20`!obj->\
    has_state()`\x20-\x20inverse\x20logic\x20to\x20make\x20state\x20packets\
    \x20smaller\n\n\r\n\x05\x047\x02\x02\x05\x12\x04\xc4\x07\x02\x06\n\r\n\
    \x05\x047\x02\x02\x01\x12\x04\xc4\x07\x07\x14\n\r\n\x05\x047\x02\x02\x03\
    \x12\x04\xc4\x07\x17\x18\n\x0c\n\x02\x048\x12\x06\xc6\x07\0\xce\x07\x01\
    \n\x0b\n\x03\x048\x01\x12\x04\xc6\x07\x08\x1c\n\x0b\n\x03\x048\x07\x12\
    \x04\xc7\x07\x02\x13\n\r\n\x05\x048\x07\x8c\x08\x12\x04\xc7\x07\x02\x13\
    \n\x0b\n\x03\x048\x07\x12\x04\xc8\x07\x02\"\n\r\n\x05\x048\x07\x8d\x08\
    \x12\x04\xc8\x07\x02\"\n\x0b\n\x03\x048\x07\x12\x04\xc9\x07\x02\x20\n\r\
    \n\x05\x048\x07\x8e\x08\x12\x04\xc9\x07\x02\x20\n\x0b\n\x03\x048\x07\x12\
    \x04\xca\x07\x02\x1b\n\r\n\x05\x048\x07\x90\x08\x12\x04\xca\x07\x02\x1b\
    \n\x0c\n\x04\x048\x02\0\x12\x04\xcc\x07\x02\x12\n\r\n\x05\x048\x02\0\x05\
    \x12\x04\xcc\x07\x02\t\n\r\n\x05\x048\x02\0\x01\x12\x04\xcc\x07\n\r\n\r\
    \n\x05\x048\x02\0\x03\x12\x04\xcc\x07\x10\x11\n\x0c\n\x04\x048\x02\x01\
    \x12\x04\xcd\x07\x02\x13\n\r\n\x05\x048\x02\x01\x05\x12\x04\xcd\x07\x02\
    \x08\n\r\n\x05\x048\x02\x01\x01\x12\x04\xcd\x07\t\x0e\n\r\n\x05\x048\x02\
    \x01\x03\x12\x04\xcd\x07\x11\x12\n>\n\x02\x05\x11\x12\x06\xd2\x07\0\xd9\
    \x07\x01\x1a0\x20====================\x20LOCK\x20====================\n\
    \n\x0b\n\x03\x05\x11\x01\x12\x04\xd2\x07\x05\x0e\n\x0c\n\x04\x05\x11\x02\
    \0\x12\x04\xd3\x07\x02\x16\n\r\n\x05\x05\x11\x02\0\x01\x12\x04\xd3\x07\
    \x02\x11\n\r\n\x05\x05\x11\x02\0\x02\x12\x04\xd3\x07\x14\x15\n\x0c\n\x04\
    \x05\x11\x02\x01\x12\x04\xd4\x07\x02\x18\n\r\n\x05\x05\x11\x02\x01\x01\
    \x12\x04\xd4\x07\x02\x13\n\r\n\x05\x05\x11\x02\x01\x02\x12\x04\xd4\x07\
    \x16\x17\n\x0c\n\x04\x05\x11\x02\x02\x12\x04\xd5\x07\x02\x1a\n\r\n\x05\
    \x05\x11\x02\x02\x01\x12\x04\xd5\x07\x02\x15\n\r\n\x05\x05\x11\x02\x02\
    \x02\x12\x04\xd5\x07\x18\x19\n\x0c\n\x04\x05\x11\x02\x03\x12\x04\xd6\x07\
    \x02\x18\n\r\n\x05\x05\x11\x02\x03\x01\x12\x04\xd6\x07\x02\x13\n\r\n\x05\
    \x05\x11\x02\x03\x02\x12\x04\xd6\x07\x16\x17\n\x0c\n\x04\x05\x11\x02\x04\
    \x12\x04\xd7\x07\x02\x19\n\r\n\x05\x05\x11\x02\x04\x01\x12\x04\xd7\x07\
    \x02\x14\n\r\n\x05\x05\x11\x02\x04\x02\x12\x04\xd7\x07\x17\x18\n\x0c\n\
    \x04\x05\x11\x02\x05\x12\x04\xd8\x07\x02\x1b\n\r\n\x05\x05\x11\x02\x05\
    \x01\x12\x04\xd8\x07\x02\x16\n\r\n\x05\x05\x11\x02\x05\x02\x12\x04\xd8\
    \x07\x19\x1a\n\x0c\n\x02\x05\x12\x12\x06\xda\x07\0\xde\x07\x01\n\x0b\n\
    \x03\x05\x12\x01\x12\x04\xda\x07\x05\x10\n\x0c\n\x04\x05\x12\x02\0\x12\
    \x04\xdb\x07\x02\x12\n\r\n\x05\x05\x12\x02\0\x01\x12\x04\xdb\x07\x02\r\n\
    \r\n\x05\x05\x12\x02\0\x02\x12\x04\xdb\x07\x10\x11\n\x0c\n\x04\x05\x12\
    \x02\x01\x12\x04\xdc\x07\x02\x10\n\r\n\x05\x05\x12\x02\x01\x01\x12\x04\
    \xdc\x07\x02\x0b\n\r\n\x05\x05\x12\x02\x01\x02\x12\x04\xdc\x07\x0e\x0f\n\
    \x0c\n\x04\x05\x12\x02\x02\x12\x04\xdd\x07\x02\x10\n\r\n\x05\x05\x12\x02\
    \x02\x01\x12\x04\xdd\x07\x02\x0b\n\r\n\x05\x05\x12\x02\x02\x02\x12\x04\
    \xdd\x07\x0e\x0f\n\x0c\n\x02\x049\x12\x06\xdf\x07\0\xf3\x07\x01\n\x0b\n\
    \x03\x049\x01\x12\x04\xdf\x07\x08\x20\n\x0b\n\x03\x049\x07\x12\x04\xe0\
    \x07\x02\x13\n\r\n\x05\x049\x07\x8c\x08\x12\x04\xe0\x07\x02\x13\n\x0b\n\
    \x03\x049\x07\x12\x04\xe1\x07\x02\"\n\r\n\x05\x049\x07\x8d\x08\x12\x04\
    \xe1\x07\x02\"\n\x0b\n\x03\x049\x07\x12\x04\xe2\x07\x02\x1e\n\r\n\x05\
    \x049\x07\x8e\x08\x12\x04\xe2\x07\x02\x1e\n\x0c\n\x04\x049\x02\0\x12\x04\
    \xe4\x07\x02\x17\n\r\n\x05\x049\x02\0\x05\x12\x04\xe4\x07\x02\x08\n\r\n\
    \x05\x049\x02\0\x01\x12\x04\xe4\x07\t\x12\n\r\n\x05\x049\x02\0\x03\x12\
    \x04\xe4\x07\x15\x16\n\x0c\n\x04\x049\x02\x01\x12\x04\xe5\x07\x02\x12\n\
    \r\n\x05\x049\x02\x01\x05\x12\x04\xe5\x07\x02\t\n\r\n\x05\x049\x02\x01\
    \x01\x12\x04\xe5\x07\n\r\n\r\n\x05\x049\x02\x01\x03\x12\x04\xe5\x07\x10\
    \x11\n\x0c\n\x04\x049\x02\x02\x12\x04\xe6\x07\x02\x12\n\r\n\x05\x049\x02\
    \x02\x05\x12\x04\xe6\x07\x02\x08\n\r\n\x05\x049\x02\x02\x01\x12\x04\xe6\
    \x07\t\r\n\r\n\x05\x049\x02\x02\x03\x12\x04\xe6\x07\x10\x11\n\x0c\n\x04\
    \x049\x02\x03\x12\x04\xe7\x07\x02\x17\n\r\n\x05\x049\x02\x03\x05\x12\x04\
    \xe7\x07\x02\x08\n\r\n\x05\x049\x02\x03\x01\x12\x04\xe7\x07\t\x12\n\r\n\
    \x05\x049\x02\x03\x03\x12\x04\xe7\x07\x15\x16\n\x0c\n\x04\x049\x02\x04\
    \x12\x04\xe9\x07\x02\x12\n\r\n\x05\x049\x02\x04\x05\x12\x04\xe9\x07\x02\
    \x08\n\r\n\x05\x049\x02\x04\x01\x12\x04\xe9\x07\t\r\n\r\n\x05\x049\x02\
    \x04\x03\x12\x04\xe9\x07\x10\x11\n\x0c\n\x04\x049\x02\x05\x12\x04\xea\
    \x07\x02\x1f\n\r\n\x05\x049\x02\x05\x05\x12\x04\xea\x07\x02\x06\n\r\n\
    \x05\x049\x02\x05\x01\x12\x04\xea\x07\x07\x1a\n\r\n\x05\x049\x02\x05\x03\
    \x12\x04\xea\x07\x1d\x1e\n\x0c\n\x04\x049\x02\x06\x12\x04\xeb\x07\x02%\n\
    \r\n\x05\x049\x02\x06\x06\x12\x04\xeb\x07\x02\x10\n\r\n\x05\x049\x02\x06\
    \x01\x12\x04\xeb\x07\x11\x20\n\r\n\x05\x049\x02\x06\x03\x12\x04\xeb\x07#\
    $\n\x0c\n\x04\x049\x02\x07\x12\x04\xec\x07\x02\x19\n\r\n\x05\x049\x02\
    \x07\x05\x12\x04\xec\x07\x02\x06\n\r\n\x05\x049\x02\x07\x01\x12\x04\xec\
    \x07\x07\x14\n\r\n\x05\x049\x02\x07\x03\x12\x04\xec\x07\x17\x18\n\x0c\n\
    \x04\x049\x02\x08\x12\x04\xee\x07\x02\x19\n\r\n\x05\x049\x02\x08\x05\x12\
    \x04\xee\x07\x02\x06\n\r\n\x05\x049\x02\x08\x01\x12\x04\xee\x07\x07\x14\
    \n\r\n\x05\x049\x02\x08\x03\x12\x04\xee\x07\x17\x18\n\x0c\n\x04\x049\x02\
    \t\x12\x04\xef\x07\x02\x1a\n\r\n\x05\x049\x02\t\x05\x12\x04\xef\x07\x02\
    \x06\n\r\n\x05\x049\x02\t\x01\x12\x04\xef\x07\x07\x14\n\r\n\x05\x049\x02\
    \t\x03\x12\x04\xef\x07\x17\x19\n$\n\x04\x049\x02\n\x12\x04\xf2\x07\x02\
    \x1a\x1a\x16\x20Not\x20yet\x20implemented:\n\n\r\n\x05\x049\x02\n\x05\
    \x12\x04\xf2\x07\x02\x08\n\r\n\x05\x049\x02\n\x01\x12\x04\xf2\x07\t\x14\
    \n\r\n\x05\x049\x02\n\x03\x12\x04\xf2\x07\x17\x19\n\x0c\n\x02\x04:\x12\
    \x06\xf4\x07\0\xfb\x07\x01\n\x0b\n\x03\x04:\x01\x12\x04\xf4\x07\x08\x19\
    \n\x0b\n\x03\x04:\x07\x12\x04\xf5\x07\x02\x13\n\r\n\x05\x04:\x07\x8c\x08\
    \x12\x04\xf5\x07\x02\x13\n\x0b\n\x03\x04:\x07\x12\x04\xf6\x07\x02\"\n\r\
    \n\x05\x04:\x07\x8d\x08\x12\x04\xf6\x07\x02\"\n\x0b\n\x03\x04:\x07\x12\
    \x04\xf7\x07\x02\x1e\n\r\n\x05\x04:\x07\x8e\x08\x12\x04\xf7\x07\x02\x1e\
    \n\x0b\n\x03\x04:\x07\x12\x04\xf8\x07\x02\x1b\n\r\n\x05\x04:\x07\x90\x08\
    \x12\x04\xf8\x07\x02\x1b\n\x0c\n\x04\x04:\x02\0\x12\x04\xf9\x07\x02\x12\
    \n\r\n\x05\x04:\x02\0\x05\x12\x04\xf9\x07\x02\t\n\r\n\x05\x04:\x02\0\x01\
    \x12\x04\xf9\x07\n\r\n\r\n\x05\x04:\x02\0\x03\x12\x04\xf9\x07\x10\x11\n\
    \x0c\n\x04\x04:\x02\x01\x12\x04\xfa\x07\x02\x16\n\r\n\x05\x04:\x02\x01\
    \x06\x12\x04\xfa\x07\x02\x0b\n\r\n\x05\x04:\x02\x01\x01\x12\x04\xfa\x07\
    \x0c\x11\n\r\n\x05\x04:\x02\x01\x03\x12\x04\xfa\x07\x14\x15\n\x0c\n\x02\
    \x04;\x12\x06\xfc\x07\0\x87\x08\x01\n\x0b\n\x03\x04;\x01\x12\x04\xfc\x07\
    \x08\x1a\n\x0b\n\x03\x04;\x07\x12\x04\xfd\x07\x02\x13\n\r\n\x05\x04;\x07\
    \x8c\x08\x12\x04\xfd\x07\x02\x13\n\x0b\n\x03\x04;\x07\x12\x04\xfe\x07\
    \x02\"\n\r\n\x05\x04;\x07\x8d\x08\x12\x04\xfe\x07\x02\"\n\x0b\n\x03\x04;\
    \x07\x12\x04\xff\x07\x02\x1e\n\r\n\x05\x04;\x07\x8e\x08\x12\x04\xff\x07\
    \x02\x1e\n\x0b\n\x03\x04;\x07\x12\x04\x80\x08\x02\x1b\n\r\n\x05\x04;\x07\
    \x90\x08\x12\x04\x80\x08\x02\x1b\n\x0c\n\x04\x04;\x02\0\x12\x04\x81\x08\
    \x02\x12\n\r\n\x05\x04;\x02\0\x05\x12\x04\x81\x08\x02\t\n\r\n\x05\x04;\
    \x02\0\x01\x12\x04\x81\x08\n\r\n\r\n\x05\x04;\x02\0\x03\x12\x04\x81\x08\
    \x10\x11\n\x0c\n\x04\x04;\x02\x01\x12\x04\x82\x08\x02\x1a\n\r\n\x05\x04;\
    \x02\x01\x06\x12\x04\x82\x08\x02\r\n\r\n\x05\x04;\x02\x01\x01\x12\x04\
    \x82\x08\x0e\x15\n\r\n\x05\x04;\x02\x01\x03\x12\x04\x82\x08\x18\x19\n$\n\
    \x04\x04;\x02\x02\x12\x04\x85\x08\x02\x14\x1a\x16\x20Not\x20yet\x20imple\
    mented:\n\n\r\n\x05\x04;\x02\x02\x05\x12\x04\x85\x08\x02\x06\n\r\n\x05\
    \x04;\x02\x02\x01\x12\x04\x85\x08\x07\x0f\n\r\n\x05\x04;\x02\x02\x03\x12\
    \x04\x85\x08\x12\x13\n\x0c\n\x04\x04;\x02\x03\x12\x04\x86\x08\x02\x12\n\
    \r\n\x05\x04;\x02\x03\x05\x12\x04\x86\x08\x02\x08\n\r\n\x05\x04;\x02\x03\
    \x01\x12\x04\x86\x08\t\r\n\r\n\x05\x04;\x02\x03\x03\x12\x04\x86\x08\x10\
    \x11\n@\n\x02\x04<\x12\x06\x8a\x08\0\x98\x08\x01\x1a2\x20===============\
    =====\x20BUTTON\x20====================\n\n\x0b\n\x03\x04<\x01\x12\x04\
    \x8a\x08\x08\"\n\x0b\n\x03\x04<\x07\x12\x04\x8b\x08\x02\x13\n\r\n\x05\
    \x04<\x07\x8c\x08\x12\x04\x8b\x08\x02\x13\n\x0b\n\x03\x04<\x07\x12\x04\
    \x8c\x08\x02\"\n\r\n\x05\x04<\x07\x8d\x08\x12\x04\x8c\x08\x02\"\n\x0b\n\
    \x03\x04<\x07\x12\x04\x8d\x08\x02\x20\n\r\n\x05\x04<\x07\x8e\x08\x12\x04\
    \x8d\x08\x02\x20\n\x0c\n\x04\x04<\x02\0\x12\x04\x8f\x08\x02\x17\n\r\n\
    \x05\x04<\x02\0\x05\x12\x04\x8f\x08\x02\x08\n\r\n\x05\x04<\x02\0\x01\x12\
    \x04\x8f\x08\t\x12\n\r\n\x05\x04<\x02\0\x03\x12\x04\x8f\x08\x15\x16\n\
    \x0c\n\x04\x04<\x02\x01\x12\x04\x90\x08\x02\x12\n\r\n\x05\x04<\x02\x01\
    \x05\x12\x04\x90\x08\x02\t\n\r\n\x05\x04<\x02\x01\x01\x12\x04\x90\x08\n\
    \r\n\r\n\x05\x04<\x02\x01\x03\x12\x04\x90\x08\x10\x11\n\x0c\n\x04\x04<\
    \x02\x02\x12\x04\x91\x08\x02\x12\n\r\n\x05\x04<\x02\x02\x05\x12\x04\x91\
    \x08\x02\x08\n\r\n\x05\x04<\x02\x02\x01\x12\x04\x91\x08\t\r\n\r\n\x05\
    \x04<\x02\x02\x03\x12\x04\x91\x08\x10\x11\n\x0c\n\x04\x04<\x02\x03\x12\
    \x04\x92\x08\x02\x17\n\r\n\x05\x04<\x02\x03\x05\x12\x04\x92\x08\x02\x08\
    \n\r\n\x05\x04<\x02\x03\x01\x12\x04\x92\x08\t\x12\n\r\n\x05\x04<\x02\x03\
    \x03\x12\x04\x92\x08\x15\x16\n\x0c\n\x04\x04<\x02\x04\x12\x04\x94\x08\
    \x02\x12\n\r\n\x05\x04<\x02\x04\x05\x12\x04\x94\x08\x02\x08\n\r\n\x05\
    \x04<\x02\x04\x01\x12\x04\x94\x08\t\r\n\r\n\x05\x04<\x02\x04\x03\x12\x04\
    \x94\x08\x10\x11\n\x0c\n\x04\x04<\x02\x05\x12\x04\x95\x08\x02\x1f\n\r\n\
    \x05\x04<\x02\x05\x05\x12\x04\x95\x08\x02\x06\n\r\n\x05\x04<\x02\x05\x01\
    \x12\x04\x95\x08\x07\x1a\n\r\n\x05\x04<\x02\x05\x03\x12\x04\x95\x08\x1d\
    \x1e\n\x0c\n\x04\x04<\x02\x06\x12\x04\x96\x08\x02%\n\r\n\x05\x04<\x02\
    \x06\x06\x12\x04\x96\x08\x02\x10\n\r\n\x05\x04<\x02\x06\x01\x12\x04\x96\
    \x08\x11\x20\n\r\n\x05\x04<\x02\x06\x03\x12\x04\x96\x08#$\n\x0c\n\x04\
    \x04<\x02\x07\x12\x04\x97\x08\x02\x1a\n\r\n\x05\x04<\x02\x07\x05\x12\x04\
    \x97\x08\x02\x08\n\r\n\x05\x04<\x02\x07\x01\x12\x04\x97\x08\t\x15\n\r\n\
    \x05\x04<\x02\x07\x03\x12\x04\x97\x08\x18\x19\n\x0c\n\x02\x04=\x12\x06\
    \x99\x08\0\xa0\x08\x01\n\x0b\n\x03\x04=\x01\x12\x04\x99\x08\x08\x1c\n\
    \x0b\n\x03\x04=\x07\x12\x04\x9a\x08\x02\x13\n\r\n\x05\x04=\x07\x8c\x08\
    \x12\x04\x9a\x08\x02\x13\n\x0b\n\x03\x04=\x07\x12\x04\x9b\x08\x02\"\n\r\
    \n\x05\x04=\x07\x8d\x08\x12\x04\x9b\x08\x02\"\n\x0b\n\x03\x04=\x07\x12\
    \x04\x9c\x08\x02\x20\n\r\n\x05\x04=\x07\x8e\x08\x12\x04\x9c\x08\x02\x20\
    \n\x0b\n\x03\x04=\x07\x12\x04\x9d\x08\x02\x1b\n\r\n\x05\x04=\x07\x90\x08\
    \x12\x04\x9d\x08\x02\x1b\n\x0c\n\x04\x04=\x02\0\x12\x04\x9f\x08\x02\x12\
    \n\r\n\x05\x04=\x02\0\x05\x12\x04\x9f\x08\x02\t\n\r\n\x05\x04=\x02\0\x01\
    \x12\x04\x9f\x08\n\r\n\r\n\x05\x04=\x02\0\x03\x12\x04\x9f\x08\x10\x11\nF\
    \n\x02\x05\x13\x12\x06\xa3\x08\0\xa8\x08\x01\x1a8\x20===================\
    =\x20MEDIA\x20PLAYER\x20====================\n\n\x0b\n\x03\x05\x13\x01\
    \x12\x04\xa3\x08\x05\x15\n\x0c\n\x04\x05\x13\x02\0\x12\x04\xa4\x08\x02\
    \x1e\n\r\n\x05\x05\x13\x02\0\x01\x12\x04\xa4\x08\x02\x19\n\r\n\x05\x05\
    \x13\x02\0\x02\x12\x04\xa4\x08\x1c\x1d\n\x0c\n\x04\x05\x13\x02\x01\x12\
    \x04\xa5\x08\x02\x1e\n\r\n\x05\x05\x13\x02\x01\x01\x12\x04\xa5\x08\x02\
    \x19\n\r\n\x05\x05\x13\x02\x01\x02\x12\x04\xa5\x08\x1c\x1d\n\x0c\n\x04\
    \x05\x13\x02\x02\x12\x04\xa6\x08\x02!\n\r\n\x05\x05\x13\x02\x02\x01\x12\
    \x04\xa6\x08\x02\x1c\n\r\n\x05\x05\x13\x02\x02\x02\x12\x04\xa6\x08\x1f\
    \x20\n\x0c\n\x04\x05\x13\x02\x03\x12\x04\xa7\x08\x02\x20\n\r\n\x05\x05\
    \x13\x02\x03\x01\x12\x04\xa7\x08\x02\x1b\n\r\n\x05\x05\x13\x02\x03\x02\
    \x12\x04\xa7\x08\x1e\x1f\n\x0c\n\x02\x05\x14\x12\x06\xa9\x08\0\xaf\x08\
    \x01\n\x0b\n\x03\x05\x14\x01\x12\x04\xa9\x08\x05\x17\n\x0c\n\x04\x05\x14\
    \x02\0\x12\x04\xaa\x08\x02\x20\n\r\n\x05\x05\x14\x02\0\x01\x12\x04\xaa\
    \x08\x02\x1b\n\r\n\x05\x05\x14\x02\0\x02\x12\x04\xaa\x08\x1e\x1f\n\x0c\n\
    \x04\x05\x14\x02\x01\x12\x04\xab\x08\x02!\n\r\n\x05\x05\x14\x02\x01\x01\
    \x12\x04\xab\x08\x02\x1c\n\r\n\x05\x05\x14\x02\x01\x02\x12\x04\xab\x08\
    \x1f\x20\n\x0c\n\x04\x05\x14\x02\x02\x12\x04\xac\x08\x02\x20\n\r\n\x05\
    \x05\x14\x02\x02\x01\x12\x04\xac\x08\x02\x1b\n\r\n\x05\x05\x14\x02\x02\
    \x02\x12\x04\xac\x08\x1e\x1f\n\x0c\n\x04\x05\x14\x02\x03\x12\x04\xad\x08\
    \x02\x20\n\r\n\x05\x05\x14\x02\x03\x01\x12\x04\xad\x08\x02\x1b\n\r\n\x05\
    \x05\x14\x02\x03\x02\x12\x04\xad\x08\x1e\x1f\n\x0c\n\x04\x05\x14\x02\x04\
    \x12\x04\xae\x08\x02\"\n\r\n\x05\x05\x14\x02\x04\x01\x12\x04\xae\x08\x02\
    \x1d\n\r\n\x05\x05\x14\x02\x04\x02\x12\x04\xae\x08\x20!\n\x0c\n\x02\x04>\
    \x12\x06\xb0\x08\0\xbf\x08\x01\n\x0b\n\x03\x04>\x01\x12\x04\xb0\x08\x08'\
    \n\x0b\n\x03\x04>\x07\x12\x04\xb1\x08\x02\x13\n\r\n\x05\x04>\x07\x8c\x08\
    \x12\x04\xb1\x08\x02\x13\n\x0b\n\x03\x04>\x07\x12\x04\xb2\x08\x02\"\n\r\
    \n\x05\x04>\x07\x8d\x08\x12\x04\xb2\x08\x02\"\n\x0b\n\x03\x04>\x07\x12\
    \x04\xb3\x08\x02&\n\r\n\x05\x04>\x07\x8e\x08\x12\x04\xb3\x08\x02&\n\x0c\
    \n\x04\x04>\x02\0\x12\x04\xb5\x08\x02\x17\n\r\n\x05\x04>\x02\0\x05\x12\
    \x04\xb5\x08\x02\x08\n\r\n\x05\x04>\x02\0\x01\x12\x04\xb5\x08\t\x12\n\r\
    \n\x05\x04>\x02\0\x03\x12\x04\xb5\x08\x15\x16\n\x0c\n\x04\x04>\x02\x01\
    \x12\x04\xb6\x08\x02\x12\n\r\n\x05\x04>\x02\x01\x05\x12\x04\xb6\x08\x02\
    \t\n\r\n\x05\x04>\x02\x01\x01\x12\x04\xb6\x08\n\r\n\r\n\x05\x04>\x02\x01\
    \x03\x12\x04\xb6\x08\x10\x11\n\x0c\n\x04\x04>\x02\x02\x12\x04\xb7\x08\
    \x02\x12\n\r\n\x05\x04>\x02\x02\x05\x12\x04\xb7\x08\x02\x08\n\r\n\x05\
    \x04>\x02\x02\x01\x12\x04\xb7\x08\t\r\n\r\n\x05\x04>\x02\x02\x03\x12\x04\
    \xb7\x08\x10\x11\n\x0c\n\x04\x04>\x02\x03\x12\x04\xb8\x08\x02\x17\n\r\n\
    \x05\x04>\x02\x03\x05\x12\x04\xb8\x08\x02\x08\n\r\n\x05\x04>\x02\x03\x01\
    \x12\x04\xb8\x08\t\x12\n\r\n\x05\x04>\x02\x03\x03\x12\x04\xb8\x08\x15\
    \x16\n\x0c\n\x04\x04>\x02\x04\x12\x04\xba\x08\x02\x12\n\r\n\x05\x04>\x02\
    \x04\x05\x12\x04\xba\x08\x02\x08\n\r\n\x05\x04>\x02\x04\x01\x12\x04\xba\
    \x08\t\r\n\r\n\x05\x04>\x02\x04\x03\x12\x04\xba\x08\x10\x11\n\x0c\n\x04\
    \x04>\x02\x05\x12\x04\xbb\x08\x02\x1f\n\r\n\x05\x04>\x02\x05\x05\x12\x04\
    \xbb\x08\x02\x06\n\r\n\x05\x04>\x02\x05\x01\x12\x04\xbb\x08\x07\x1a\n\r\
    \n\x05\x04>\x02\x05\x03\x12\x04\xbb\x08\x1d\x1e\n\x0c\n\x04\x04>\x02\x06\
    \x12\x04\xbc\x08\x02%\n\r\n\x05\x04>\x02\x06\x06\x12\x04\xbc\x08\x02\x10\
    \n\r\n\x05\x04>\x02\x06\x01\x12\x04\xbc\x08\x11\x20\n\r\n\x05\x04>\x02\
    \x06\x03\x12\x04\xbc\x08#$\n\x0c\n\x04\x04>\x02\x07\x12\x04\xbe\x08\x02\
    \x1a\n\r\n\x05\x04>\x02\x07\x05\x12\x04\xbe\x08\x02\x06\n\r\n\x05\x04>\
    \x02\x07\x01\x12\x04\xbe\x08\x07\x15\n\r\n\x05\x04>\x02\x07\x03\x12\x04\
    \xbe\x08\x18\x19\n\x0c\n\x02\x04?\x12\x06\xc0\x08\0\xc9\x08\x01\n\x0b\n\
    \x03\x04?\x01\x12\x04\xc0\x08\x08\x20\n\x0b\n\x03\x04?\x07\x12\x04\xc1\
    \x08\x02\x13\n\r\n\x05\x04?\x07\x8c\x08\x12\x04\xc1\x08\x02\x13\n\x0b\n\
    \x03\x04?\x07\x12\x04\xc2\x08\x02\"\n\r\n\x05\x04?\x07\x8d\x08\x12\x04\
    \xc2\x08\x02\"\n\x0b\n\x03\x04?\x07\x12\x04\xc3\x08\x02&\n\r\n\x05\x04?\
    \x07\x8e\x08\x12\x04\xc3\x08\x02&\n\x0b\n\x03\x04?\x07\x12\x04\xc4\x08\
    \x02\x1b\n\r\n\x05\x04?\x07\x90\x08\x12\x04\xc4\x08\x02\x1b\n\x0c\n\x04\
    \x04?\x02\0\x12\x04\xc5\x08\x02\x12\n\r\n\x05\x04?\x02\0\x05\x12\x04\xc5\
    \x08\x02\t\n\r\n\x05\x04?\x02\0\x01\x12\x04\xc5\x08\n\r\n\r\n\x05\x04?\
    \x02\0\x03\x12\x04\xc5\x08\x10\x11\n\x0c\n\x04\x04?\x02\x01\x12\x04\xc6\
    \x08\x02\x1d\n\r\n\x05\x04?\x02\x01\x06\x12\x04\xc6\x08\x02\x12\n\r\n\
    \x05\x04?\x02\x01\x01\x12\x04\xc6\x08\x13\x18\n\r\n\x05\x04?\x02\x01\x03\
    \x12\x04\xc6\x08\x1b\x1c\n\x0c\n\x04\x04?\x02\x02\x12\x04\xc7\x08\x02\
    \x13\n\r\n\x05\x04?\x02\x02\x05\x12\x04\xc7\x08\x02\x07\n\r\n\x05\x04?\
    \x02\x02\x01\x12\x04\xc7\x08\x08\x0e\n\r\n\x05\x04?\x02\x02\x03\x12\x04\
    \xc7\x08\x11\x12\n\x0c\n\x04\x04?\x02\x03\x12\x04\xc8\x08\x02\x11\n\r\n\
    \x05\x04?\x02\x03\x05\x12\x04\xc8\x08\x02\x06\n\r\n\x05\x04?\x02\x03\x01\
    \x12\x04\xc8\x08\x07\x0c\n\r\n\x05\x04?\x02\x03\x03\x12\x04\xc8\x08\x0f\
    \x10\n\x0c\n\x02\x04@\x12\x06\xca\x08\0\xda\x08\x01\n\x0b\n\x03\x04@\x01\
    \x12\x04\xca\x08\x08!\n\x0b\n\x03\x04@\x07\x12\x04\xcb\x08\x02\x13\n\r\n\
    \x05\x04@\x07\x8c\x08\x12\x04\xcb\x08\x02\x13\n\x0b\n\x03\x04@\x07\x12\
    \x04\xcc\x08\x02\"\n\r\n\x05\x04@\x07\x8d\x08\x12\x04\xcc\x08\x02\"\n\
    \x0b\n\x03\x04@\x07\x12\x04\xcd\x08\x02&\n\r\n\x05\x04@\x07\x8e\x08\x12\
    \x04\xcd\x08\x02&\n\x0b\n\x03\x04@\x07\x12\x04\xce\x08\x02\x1b\n\r\n\x05\
    \x04@\x07\x90\x08\x12\x04\xce\x08\x02\x1b\n\x0c\n\x04\x04@\x02\0\x12\x04\
    \xd0\x08\x02\x12\n\r\n\x05\x04@\x02\0\x05\x12\x04\xd0\x08\x02\t\n\r\n\
    \x05\x04@\x02\0\x01\x12\x04\xd0\x08\n\r\n\r\n\x05\x04@\x02\0\x03\x12\x04\
    \xd0\x08\x10\x11\n\x0c\n\x04\x04@\x02\x01\x12\x04\xd2\x08\x02\x17\n\r\n\
    \x05\x04@\x02\x01\x05\x12\x04\xd2\x08\x02\x06\n\r\n\x05\x04@\x02\x01\x01\
    \x12\x04\xd2\x08\x07\x12\n\r\n\x05\x04@\x02\x01\x03\x12\x04\xd2\x08\x15\
    \x16\n\x0c\n\x04\x04@\x02\x02\x12\x04\xd3\x08\x02!\n\r\n\x05\x04@\x02\
    \x02\x06\x12\x04\xd3\x08\x02\x14\n\r\n\x05\x04@\x02\x02\x01\x12\x04\xd3\
    \x08\x15\x1c\n\r\n\x05\x04@\x02\x02\x03\x12\x04\xd3\x08\x1f\x20\n\x0c\n\
    \x04\x04@\x02\x03\x12\x04\xd5\x08\x02\x16\n\r\n\x05\x04@\x02\x03\x05\x12\
    \x04\xd5\x08\x02\x06\n\r\n\x05\x04@\x02\x03\x01\x12\x04\xd5\x08\x07\x11\
    \n\r\n\x05\x04@\x02\x03\x03\x12\x04\xd5\x08\x14\x15\n\x0c\n\x04\x04@\x02\
    \x04\x12\x04\xd6\x08\x02\x13\n\r\n\x05\x04@\x02\x04\x05\x12\x04\xd6\x08\
    \x02\x07\n\r\n\x05\x04@\x02\x04\x01\x12\x04\xd6\x08\x08\x0e\n\r\n\x05\
    \x04@\x02\x04\x03\x12\x04\xd6\x08\x11\x12\n\x0c\n\x04\x04@\x02\x05\x12\
    \x04\xd8\x08\x02\x19\n\r\n\x05\x04@\x02\x05\x05\x12\x04\xd8\x08\x02\x06\
    \n\r\n\x05\x04@\x02\x05\x01\x12\x04\xd8\x08\x07\x14\n\r\n\x05\x04@\x02\
    \x05\x03\x12\x04\xd8\x08\x17\x18\n\x0c\n\x04\x04@\x02\x06\x12\x04\xd9\
    \x08\x02\x17\n\r\n\x05\x04@\x02\x06\x05\x12\x04\xd9\x08\x02\x08\n\r\n\
    \x05\x04@\x02\x06\x01\x12\x04\xd9\x08\t\x12\n\r\n\x05\x04@\x02\x06\x03\
    \x12\x04\xd9\x08\x15\x16\nC\n\x02\x04A\x12\x06\xdd\x08\0\xe0\x08\x01\x1a\
    5\x20====================\x20BLUETOOTH\x20====================\n\n\x0b\n\
    \x03\x04A\x01\x12\x04\xdd\x08\x081\n\x0b\n\x03\x04A\x07\x12\x04\xde\x08\
    \x02\x13\n\r\n\x05\x04A\x07\x8c\x08\x12\x04\xde\x08\x02\x13\n\x0b\n\x03\
    \x04A\x07\x12\x04\xdf\x08\x02\"\n\r\n\x05\x04A\x07\x8d\x08\x12\x04\xdf\
    \x08\x02\"\n\x0c\n\x02\x04B\x12\x06\xe2\x08\0\xe6\x08\x01\n\x0b\n\x03\
    \x04B\x01\x12\x04\xe2\x08\x08\x1c\n\x0c\n\x04\x04B\x02\0\x12\x04\xe3\x08\
    \x02\x12\n\r\n\x05\x04B\x02\0\x05\x12\x04\xe3\x08\x02\x08\n\r\n\x05\x04B\
    \x02\0\x01\x12\x04\xe3\x08\t\r\n\r\n\x05\x04B\x02\0\x03\x12\x04\xe3\x08\
    \x10\x11\n\x0c\n\x04\x04B\x02\x01\x12\x04\xe4\x08\x026\n\r\n\x05\x04B\
    \x02\x01\x04\x12\x04\xe4\x08\x02\n\n\r\n\x05\x04B\x02\x01\x05\x12\x04\
    \xe4\x08\x0b\x11\n\r\n\x05\x04B\x02\x01\x01\x12\x04\xe4\x08\x12\x1d\n\r\
    \n\x05\x04B\x02\x01\x03\x12\x04\xe4\x08\x20!\n\r\n\x05\x04B\x02\x01\x08\
    \x12\x04\xe4\x08\"5\n\x0e\n\x06\x04B\x02\x01\x08\x03\x12\x04\xe4\x08#4\n\
    ,\n\x04\x04B\x02\x02\x12\x04\xe5\x08\x02\x11\"\x1e\x20Changed\x20in\x20p\
    roto\x20version\x201.7\n\n\r\n\x05\x04B\x02\x02\x05\x12\x04\xe5\x08\x02\
    \x07\n\r\n\x05\x04B\x02\x02\x01\x12\x04\xe5\x08\x08\x0c\n\r\n\x05\x04B\
    \x02\x02\x03\x12\x04\xe5\x08\x0f\x10\n\x0c\n\x02\x04C\x12\x06\xe7\x08\0\
    \xf4\x08\x01\n\x0b\n\x03\x04C\x01\x12\x04\xe7\x08\x08(\n\x0b\n\x03\x04C\
    \x07\x12\x04\xe8\x08\x02\x13\n\r\n\x05\x04C\x07\x8c\x08\x12\x04\xe8\x08\
    \x02\x13\n\x0b\n\x03\x04C\x07\x12\x04\xe9\x08\x02\"\n\r\n\x05\x04C\x07\
    \x8d\x08\x12\x04\xe9\x08\x02\"\n\x0b\n\x03\x04C\x07\x12\x04\xea\x08\x02)\
    \n\r\n\x05\x04C\x07\x8e\x08\x12\x04\xea\x08\x02)\n\x0b\n\x03\x04C\x07\
    \x12\x04\xeb\x08\x02\x1b\n\r\n\x05\x04C\x07\x90\x08\x12\x04\xeb\x08\x02\
    \x1b\n\x0c\n\x04\x04C\x02\0\x12\x04\xed\x08\x02\x15\n\r\n\x05\x04C\x02\0\
    \x05\x12\x04\xed\x08\x02\x08\n\r\n\x05\x04C\x02\0\x01\x12\x04\xed\x08\t\
    \x10\n\r\n\x05\x04C\x02\0\x03\x12\x04\xed\x08\x13\x14\n\x0c\n\x04\x04C\
    \x02\x01\x12\x04\xee\x08\x02\x12\n\r\n\x05\x04C\x02\x01\x05\x12\x04\xee\
    \x08\x02\x08\n\r\n\x05\x04C\x02\x01\x01\x12\x04\xee\x08\t\r\n\r\n\x05\
    \x04C\x02\x01\x03\x12\x04\xee\x08\x10\x11\n\x0c\n\x04\x04C\x02\x02\x12\
    \x04\xef\x08\x02\x12\n\r\n\x05\x04C\x02\x02\x05\x12\x04\xef\x08\x02\x08\
    \n\r\n\x05\x04C\x02\x02\x01\x12\x04\xef\x08\t\r\n\r\n\x05\x04C\x02\x02\
    \x03\x12\x04\xef\x08\x10\x11\n\x0c\n\x04\x04C\x02\x03\x12\x04\xf1\x08\
    \x02$\n\r\n\x05\x04C\x02\x03\x04\x12\x04\xf1\x08\x02\n\n\r\n\x05\x04C\
    \x02\x03\x05\x12\x04\xf1\x08\x0b\x11\n\r\n\x05\x04C\x02\x03\x01\x12\x04\
    \xf1\x08\x12\x1f\n\r\n\x05\x04C\x02\x03\x03\x12\x04\xf1\x08\"#\n\x0c\n\
    \x04\x04C\x02\x04\x12\x04\xf2\x08\x021\n\r\n\x05\x04C\x02\x04\x04\x12\
    \x04\xf2\x08\x02\n\n\r\n\x05\x04C\x02\x04\x06\x12\x04\xf2\x08\x0b\x1f\n\
    \r\n\x05\x04C\x02\x04\x01\x12\x04\xf2\x08\x20,\n\r\n\x05\x04C\x02\x04\
    \x03\x12\x04\xf2\x08/0\n\x0c\n\x04\x04C\x02\x05\x12\x04\xf3\x08\x026\n\r\
    \n\x05\x04C\x02\x05\x04\x12\x04\xf3\x08\x02\n\n\r\n\x05\x04C\x02\x05\x06\
    \x12\x04\xf3\x08\x0b\x1f\n\r\n\x05\x04C\x02\x05\x01\x12\x04\xf3\x08\x201\
    \n\r\n\x05\x04C\x02\x05\x03\x12\x04\xf3\x0845\n\x0c\n\x02\x05\x15\x12\
    \x06\xf6\x08\0\xfb\x08\x01\n\x0b\n\x03\x05\x15\x01\x12\x04\xf6\x08\x05\
    \x1f\n\x0c\n\x04\x05\x15\x02\0\x12\x04\xf7\x08\x02,\n\r\n\x05\x05\x15\
    \x02\0\x01\x12\x04\xf7\x08\x02'\n\r\n\x05\x05\x15\x02\0\x02\x12\x04\xf7\
    \x08*+\n\x0c\n\x04\x05\x15\x02\x01\x12\x04\xf8\x08\x02/\n\r\n\x05\x05\
    \x15\x02\x01\x01\x12\x04\xf8\x08\x02*\n\r\n\x05\x05\x15\x02\x01\x02\x12\
    \x04\xf8\x08-.\n\x0c\n\x04\x05\x15\x02\x02\x12\x04\xf9\x08\x02)\n\r\n\
    \x05\x05\x15\x02\x02\x01\x12\x04\xf9\x08\x02$\n\r\n\x05\x05\x15\x02\x02\
    \x02\x12\x04\xf9\x08'(\n\x0c\n\x04\x05\x15\x02\x03\x12\x04\xfa\x08\x02+\
    \n\r\n\x05\x05\x15\x02\x03\x01\x12\x04\xfa\x08\x02&\n\r\n\x05\x05\x15\
    \x02\x03\x02\x12\x04\xfa\x08)*\n\x0c\n\x02\x04D\x12\x06\xfd\x08\0\x84\t\
    \x01\n\x0b\n\x03\x04D\x01\x12\x04\xfd\x08\x08\x1e\n\x0b\n\x03\x04D\x07\
    \x12\x04\xfe\x08\x02\x13\n\r\n\x05\x04D\x07\x8c\x08\x12\x04\xfe\x08\x02\
    \x13\n\x0b\n\x03\x04D\x07\x12\x04\xff\x08\x02\"\n\r\n\x05\x04D\x07\x8d\
    \x08\x12\x04\xff\x08\x02\"\n\x0b\n\x03\x04D\x07\x12\x04\x80\t\x02)\n\r\n\
    \x05\x04D\x07\x8e\x08\x12\x04\x80\t\x02)\n\x0c\n\x04\x04D\x02\0\x12\x04\
    \x82\t\x02\x15\n\r\n\x05\x04D\x02\0\x05\x12\x04\x82\t\x02\x08\n\r\n\x05\
    \x04D\x02\0\x01\x12\x04\x82\t\t\x10\n\r\n\x05\x04D\x02\0\x03\x12\x04\x82\
    \t\x13\x14\n\x0c\n\x04\x04D\x02\x01\x12\x04\x83\t\x02.\n\r\n\x05\x04D\
    \x02\x01\x06\x12\x04\x83\t\x02\x1c\n\r\n\x05\x04D\x02\x01\x01\x12\x04\
    \x83\t\x1d)\n\r\n\x05\x04D\x02\x01\x03\x12\x04\x83\t,-\n\x0c\n\x02\x04E\
    \x12\x06\x86\t\0\x8f\t\x01\n\x0b\n\x03\x04E\x01\x12\x04\x86\t\x08)\n\x0b\
    \n\x03\x04E\x07\x12\x04\x87\t\x02\x13\n\r\n\x05\x04E\x07\x8c\x08\x12\x04\
    \x87\t\x02\x13\n\x0b\n\x03\x04E\x07\x12\x04\x88\t\x02\"\n\r\n\x05\x04E\
    \x07\x8d\x08\x12\x04\x88\t\x02\"\n\x0b\n\x03\x04E\x07\x12\x04\x89\t\x02)\
    \n\r\n\x05\x04E\x07\x8e\x08\x12\x04\x89\t\x02)\n\x0c\n\x04\x04E\x02\0\
    \x12\x04\x8b\t\x02\x15\n\r\n\x05\x04E\x02\0\x05\x12\x04\x8b\t\x02\x08\n\
    \r\n\x05\x04E\x02\0\x01\x12\x04\x8b\t\t\x10\n\r\n\x05\x04E\x02\0\x03\x12\
    \x04\x8b\t\x13\x14\n\x0c\n\x04\x04E\x02\x01\x12\x04\x8c\t\x02\x15\n\r\n\
    \x05\x04E\x02\x01\x05\x12\x04\x8c\t\x02\x06\n\r\n\x05\x04E\x02\x01\x01\
    \x12\x04\x8c\t\x07\x10\n\r\n\x05\x04E\x02\x01\x03\x12\x04\x8c\t\x13\x14\
    \n\x0c\n\x04\x04E\x02\x02\x12\x04\x8d\t\x02\x11\n\r\n\x05\x04E\x02\x02\
    \x05\x12\x04\x8d\t\x02\x08\n\r\n\x05\x04E\x02\x02\x01\x12\x04\x8d\t\t\
    \x0c\n\r\n\x05\x04E\x02\x02\x03\x12\x04\x8d\t\x0f\x10\n\x0c\n\x04\x04E\
    \x02\x03\x12\x04\x8e\t\x02\x12\n\r\n\x05\x04E\x02\x03\x05\x12\x04\x8e\t\
    \x02\x07\n\r\n\x05\x04E\x02\x03\x01\x12\x04\x8e\t\x08\r\n\r\n\x05\x04E\
    \x02\x03\x03\x12\x04\x8e\t\x10\x11\n\x0c\n\x02\x04F\x12\x06\x91\t\0\x97\
    \t\x01\n\x0b\n\x03\x04F\x01\x12\x04\x91\t\x08'\n\x0b\n\x03\x04F\x07\x12\
    \x04\x92\t\x02\x13\n\r\n\x05\x04F\x07\x8c\x08\x12\x04\x92\t\x02\x13\n\
    \x0b\n\x03\x04F\x07\x12\x04\x93\t\x02\"\n\r\n\x05\x04F\x07\x8d\x08\x12\
    \x04\x93\t\x02\"\n\x0b\n\x03\x04F\x07\x12\x04\x94\t\x02)\n\r\n\x05\x04F\
    \x07\x8e\x08\x12\x04\x94\t\x02)\n\x0c\n\x04\x04F\x02\0\x12\x04\x96\t\x02\
    \x15\n\r\n\x05\x04F\x02\0\x05\x12\x04\x96\t\x02\x08\n\r\n\x05\x04F\x02\0\
    \x01\x12\x04\x96\t\t\x10\n\r\n\x05\x04F\x02\0\x03\x12\x04\x96\t\x13\x14\
    \n\x0c\n\x02\x04G\x12\x06\x99\t\0\x9c\t\x01\n\x0b\n\x03\x04G\x01\x12\x04\
    \x99\t\x08\x1f\n\x0c\n\x04\x04G\x02\0\x12\x04\x9a\t\x02\x1b\n\r\n\x05\
    \x04G\x02\0\x04\x12\x04\x9a\t\x02\n\n\r\n\x05\x04G\x02\0\x05\x12\x04\x9a\
    \t\x0b\x11\n\r\n\x05\x04G\x02\0\x01\x12\x04\x9a\t\x12\x16\n\r\n\x05\x04G\
    \x02\0\x03\x12\x04\x9a\t\x19\x1a\n\x0c\n\x04\x04G\x02\x01\x12\x04\x9b\t\
    \x02\x14\n\r\n\x05\x04G\x02\x01\x05\x12\x04\x9b\t\x02\x08\n\r\n\x05\x04G\
    \x02\x01\x01\x12\x04\x9b\t\t\x0f\n\r\n\x05\x04G\x02\x01\x03\x12\x04\x9b\
    \t\x12\x13\n\x0c\n\x02\x04H\x12\x06\x9e\t\0\xa3\t\x01\n\x0b\n\x03\x04H\
    \x01\x12\x04\x9e\t\x08#\n\x0c\n\x04\x04H\x02\0\x12\x04\x9f\t\x02\x1b\n\r\
    \n\x05\x04H\x02\0\x04\x12\x04\x9f\t\x02\n\n\r\n\x05\x04H\x02\0\x05\x12\
    \x04\x9f\t\x0b\x11\n\r\n\x05\x04H\x02\0\x01\x12\x04\x9f\t\x12\x16\n\r\n\
    \x05\x04H\x02\0\x03\x12\x04\x9f\t\x19\x1a\n\x0c\n\x04\x04H\x02\x01\x12\
    \x04\xa0\t\x02\x14\n\r\n\x05\x04H\x02\x01\x05\x12\x04\xa0\t\x02\x08\n\r\
    \n\x05\x04H\x02\x01\x01\x12\x04\xa0\t\t\x0f\n\r\n\x05\x04H\x02\x01\x03\
    \x12\x04\xa0\t\x12\x13\n\x0c\n\x04\x04H\x02\x02\x12\x04\xa1\t\x02\x18\n\
    \r\n\x05\x04H\x02\x02\x05\x12\x04\xa1\t\x02\x08\n\r\n\x05\x04H\x02\x02\
    \x01\x12\x04\xa1\t\t\x13\n\r\n\x05\x04H\x02\x02\x03\x12\x04\xa1\t\x16\
    \x17\n\x0c\n\x04\x04H\x02\x03\x12\x04\xa2\t\x023\n\r\n\x05\x04H\x02\x03\
    \x04\x12\x04\xa2\t\x02\n\n\r\n\x05\x04H\x02\x03\x06\x12\x04\xa2\t\x0b\"\
    \n\r\n\x05\x04H\x02\x03\x01\x12\x04\xa2\t#.\n\r\n\x05\x04H\x02\x03\x03\
    \x12\x04\xa2\t12\n\x0c\n\x02\x04I\x12\x06\xa5\t\0\xa9\t\x01\n\x0b\n\x03\
    \x04I\x01\x12\x04\xa5\t\x08\x1c\n\x0c\n\x04\x04I\x02\0\x12\x04\xa6\t\x02\
    \x1b\n\r\n\x05\x04I\x02\0\x04\x12\x04\xa6\t\x02\n\n\r\n\x05\x04I\x02\0\
    \x05\x12\x04\xa6\t\x0b\x11\n\r\n\x05\x04I\x02\0\x01\x12\x04\xa6\t\x12\
    \x16\n\r\n\x05\x04I\x02\0\x03\x12\x04\xa6\t\x19\x1a\n\x0c\n\x04\x04I\x02\
    \x01\x12\x04\xa7\t\x02\x14\n\r\n\x05\x04I\x02\x01\x05\x12\x04\xa7\t\x02\
    \x08\n\r\n\x05\x04I\x02\x01\x01\x12\x04\xa7\t\t\x0f\n\r\n\x05\x04I\x02\
    \x01\x03\x12\x04\xa7\t\x12\x13\n\x0c\n\x04\x04I\x02\x02\x12\x04\xa8\t\
    \x02;\n\r\n\x05\x04I\x02\x02\x04\x12\x04\xa8\t\x02\n\n\r\n\x05\x04I\x02\
    \x02\x06\x12\x04\xa8\t\x0b&\n\r\n\x05\x04I\x02\x02\x01\x12\x04\xa8\t'6\n\
    \r\n\x05\x04I\x02\x02\x03\x12\x04\xa8\t9:\n\x0c\n\x02\x04J\x12\x06\xab\t\
    \0\xb2\t\x01\n\x0b\n\x03\x04J\x01\x12\x04\xab\t\x08(\n\x0b\n\x03\x04J\
    \x07\x12\x04\xac\t\x02\x13\n\r\n\x05\x04J\x07\x8c\x08\x12\x04\xac\t\x02\
    \x13\n\x0b\n\x03\x04J\x07\x12\x04\xad\t\x02\"\n\r\n\x05\x04J\x07\x8d\x08\
    \x12\x04\xad\t\x02\"\n\x0b\n\x03\x04J\x07\x12\x04\xae\t\x02)\n\r\n\x05\
    \x04J\x07\x8e\x08\x12\x04\xae\t\x02)\n\x0c\n\x04\x04J\x02\0\x12\x04\xb0\
    \t\x02\x15\n\r\n\x05\x04J\x02\0\x05\x12\x04\xb0\t\x02\x08\n\r\n\x05\x04J\
    \x02\0\x01\x12\x04\xb0\t\t\x10\n\r\n\x05\x04J\x02\0\x03\x12\x04\xb0\t\
    \x13\x14\n\x0c\n\x04\x04J\x02\x01\x12\x04\xb1\t\x02-\n\r\n\x05\x04J\x02\
    \x01\x04\x12\x04\xb1\t\x02\n\n\r\n\x05\x04J\x02\x01\x06\x12\x04\xb1\t\
    \x0b\x1f\n\r\n\x05\x04J\x02\x01\x01\x12\x04\xb1\t\x20(\n\r\n\x05\x04J\
    \x02\x01\x03\x12\x04\xb1\t+,\n\x0c\n\x02\x04K\x12\x06\xb4\t\0\xba\t\x01\
    \n\x0b\n\x03\x04K\x01\x12\x04\xb4\t\x08,\n\x0b\n\x03\x04K\x07\x12\x04\
    \xb5\t\x02\x13\n\r\n\x05\x04K\x07\x8c\x08\x12\x04\xb5\t\x02\x13\n\x0b\n\
    \x03\x04K\x07\x12\x04\xb6\t\x02\"\n\r\n\x05\x04K\x07\x8d\x08\x12\x04\xb6\
    \t\x02\"\n\x0b\n\x03\x04K\x07\x12\x04\xb7\t\x02)\n\r\n\x05\x04K\x07\x8e\
    \x08\x12\x04\xb7\t\x02)\n\x0c\n\x04\x04K\x02\0\x12\x04\xb9\t\x02\x15\n\r\
    \n\x05\x04K\x02\0\x05\x12\x04\xb9\t\x02\x08\n\r\n\x05\x04K\x02\0\x01\x12\
    \x04\xb9\t\t\x10\n\r\n\x05\x04K\x02\0\x03\x12\x04\xb9\t\x13\x14\n\x0c\n\
    \x02\x04L\x12\x06\xbc\t\0\xc3\t\x01\n\x0b\n\x03\x04L\x01\x12\x04\xbc\t\
    \x08\x20\n\x0b\n\x03\x04L\x07\x12\x04\xbd\t\x02\x13\n\r\n\x05\x04L\x07\
    \x8c\x08\x12\x04\xbd\t\x02\x13\n\x0b\n\x03\x04L\x07\x12\x04\xbe\t\x02\"\
    \n\r\n\x05\x04L\x07\x8d\x08\x12\x04\xbe\t\x02\"\n\x0b\n\x03\x04L\x07\x12\
    \x04\xbf\t\x02)\n\r\n\x05\x04L\x07\x8e\x08\x12\x04\xbf\t\x02)\n\x0c\n\
    \x04\x04L\x02\0\x12\x04\xc1\t\x02\x15\n\r\n\x05\x04L\x02\0\x05\x12\x04\
    \xc1\t\x02\x08\n\r\n\x05\x04L\x02\0\x01\x12\x04\xc1\t\t\x10\n\r\n\x05\
    \x04L\x02\0\x03\x12\x04\xc1\t\x13\x14\n\x0c\n\x04\x04L\x02\x01\x12\x04\
    \xc2\t\x02\x14\n\r\n\x05\x04L\x02\x01\x05\x12\x04\xc2\t\x02\x08\n\r\n\
    \x05\x04L\x02\x01\x01\x12\x04\xc2\t\t\x0f\n\r\n\x05\x04L\x02\x01\x03\x12\
    \x04\xc2\t\x12\x13\n\x0c\n\x02\x04M\x12\x06\xc5\t\0\xcf\t\x01\n\x0b\n\
    \x03\x04M\x01\x12\x04\xc5\t\x08!\n\x0b\n\x03\x04M\x07\x12\x04\xc6\t\x02\
    \x13\n\r\n\x05\x04M\x07\x8c\x08\x12\x04\xc6\t\x02\x13\n\x0b\n\x03\x04M\
    \x07\x12\x04\xc7\t\x02\"\n\r\n\x05\x04M\x07\x8d\x08\x12\x04\xc7\t\x02\"\
    \n\x0b\n\x03\x04M\x07\x12\x04\xc8\t\x02)\n\r\n\x05\x04M\x07\x8e\x08\x12\
    \x04\xc8\t\x02)\n\x0c\n\x04\x04M\x02\0\x12\x04\xca\t\x02\x15\n\r\n\x05\
    \x04M\x02\0\x05\x12\x04\xca\t\x02\x08\n\r\n\x05\x04M\x02\0\x01\x12\x04\
    \xca\t\t\x10\n\r\n\x05\x04M\x02\0\x03\x12\x04\xca\t\x13\x14\n\x0c\n\x04\
    \x04M\x02\x01\x12\x04\xcb\t\x02\x14\n\r\n\x05\x04M\x02\x01\x05\x12\x04\
    \xcb\t\x02\x08\n\r\n\x05\x04M\x02\x01\x01\x12\x04\xcb\t\t\x0f\n\r\n\x05\
    \x04M\x02\x01\x03\x12\x04\xcb\t\x12\x13\n\x0c\n\x04\x04M\x02\x02\x12\x04\
    \xcd\t\x02\x11\n\r\n\x05\x04M\x02\x02\x05\x12\x04\xcd\t\x02\x07\n\r\n\
    \x05\x04M\x02\x02\x01\x12\x04\xcd\t\x08\x0c\n\r\n\x05\x04M\x02\x02\x03\
    \x12\x04\xcd\t\x0f\x10\n\x0c\n\x02\x04N\x12\x06\xd1\t\0\xdb\t\x01\n\x0b\
    \n\x03\x04N\x01\x12\x04\xd1\t\x08!\n\x0b\n\x03\x04N\x07\x12\x04\xd2\t\
    \x02\x13\n\r\n\x05\x04N\x07\x8c\x08\x12\x04\xd2\t\x02\x13\n\x0b\n\x03\
    \x04N\x07\x12\x04\xd3\t\x02\"\n\r\n\x05\x04N\x07\x8d\x08\x12\x04\xd3\t\
    \x02\"\n\x0b\n\x03\x04N\x07\x12\x04\xd4\t\x02)\n\r\n\x05\x04N\x07\x8e\
    \x08\x12\x04\xd4\t\x02)\n\x0c\n\x04\x04N\x02\0\x12\x04\xd6\t\x02\x15\n\r\
    \n\x05\x04N\x02\0\x05\x12\x04\xd6\t\x02\x08\n\r\n\x05\x04N\x02\0\x01\x12\
    \x04\xd6\t\t\x10\n\r\n\x05\x04N\x02\0\x03\x12\x04\xd6\t\x13\x14\n\x0c\n\
    \x04\x04N\x02\x01\x12\x04\xd7\t\x02\x14\n\r\n\x05\x04N\x02\x01\x05\x12\
    \x04\xd7\t\x02\x08\n\r\n\x05\x04N\x02\x01\x01\x12\x04\xd7\t\t\x0f\n\r\n\
    \x05\x04N\x02\x01\x03\x12\x04\xd7\t\x12\x13\n\x0c\n\x04\x04N\x02\x02\x12\
    \x04\xd8\t\x02\x14\n\r\n\x05\x04N\x02\x02\x05\x12\x04\xd8\t\x02\x06\n\r\
    \n\x05\x04N\x02\x02\x01\x12\x04\xd8\t\x07\x0f\n\r\n\x05\x04N\x02\x02\x03\
    \x12\x04\xd8\t\x12\x13\n\x0c\n\x04\x04N\x02\x03\x12\x04\xda\t\x02\x11\n\
    \r\n\x05\x04N\x02\x03\x05\x12\x04\xda\t\x02\x07\n\r\n\x05\x04N\x02\x03\
    \x01\x12\x04\xda\t\x08\x0c\n\r\n\x05\x04N\x02\x03\x03\x12\x04\xda\t\x0f\
    \x10\n\x0c\n\x02\x04O\x12\x06\xdd\t\0\xe4\t\x01\n\x0b\n\x03\x04O\x01\x12\
    \x04\xdd\t\x08*\n\x0b\n\x03\x04O\x07\x12\x04\xde\t\x02\x13\n\r\n\x05\x04\
    O\x07\x8c\x08\x12\x04\xde\t\x02\x13\n\x0b\n\x03\x04O\x07\x12\x04\xdf\t\
    \x02\"\n\r\n\x05\x04O\x07\x8d\x08\x12\x04\xdf\t\x02\"\n\x0b\n\x03\x04O\
    \x07\x12\x04\xe0\t\x02)\n\r\n\x05\x04O\x07\x8e\x08\x12\x04\xe0\t\x02)\n\
    \x0c\n\x04\x04O\x02\0\x12\x04\xe2\t\x02\x15\n\r\n\x05\x04O\x02\0\x05\x12\
    \x04\xe2\t\x02\x08\n\r\n\x05\x04O\x02\0\x01\x12\x04\xe2\t\t\x10\n\r\n\
    \x05\x04O\x02\0\x03\x12\x04\xe2\t\x13\x14\n\x0c\n\x04\x04O\x02\x01\x12\
    \x04\xe3\t\x02\x14\n\r\n\x05\x04O\x02\x01\x05\x12\x04\xe3\t\x02\x08\n\r\
    \n\x05\x04O\x02\x01\x01\x12\x04\xe3\t\t\x0f\n\r\n\x05\x04O\x02\x01\x03\
    \x12\x04\xe3\t\x12\x13\n\x0c\n\x02\x04P\x12\x06\xe6\t\0\xef\t\x01\n\x0b\
    \n\x03\x04P\x01\x12\x04\xe6\t\x08+\n\x0b\n\x03\x04P\x07\x12\x04\xe7\t\
    \x02\x13\n\r\n\x05\x04P\x07\x8c\x08\x12\x04\xe7\t\x02\x13\n\x0b\n\x03\
    \x04P\x07\x12\x04\xe8\t\x02\"\n\r\n\x05\x04P\x07\x8d\x08\x12\x04\xe8\t\
    \x02\"\n\x0b\n\x03\x04P\x07\x12\x04\xe9\t\x02)\n\r\n\x05\x04P\x07\x8e\
    \x08\x12\x04\xe9\t\x02)\n\x0c\n\x04\x04P\x02\0\x12\x04\xeb\t\x02\x15\n\r\
    \n\x05\x04P\x02\0\x05\x12\x04\xeb\t\x02\x08\n\r\n\x05\x04P\x02\0\x01\x12\
    \x04\xeb\t\t\x10\n\r\n\x05\x04P\x02\0\x03\x12\x04\xeb\t\x13\x14\n\x0c\n\
    \x04\x04P\x02\x01\x12\x04\xec\t\x02\x14\n\r\n\x05\x04P\x02\x01\x05\x12\
    \x04\xec\t\x02\x08\n\r\n\x05\x04P\x02\x01\x01\x12\x04\xec\t\t\x0f\n\r\n\
    \x05\x04P\x02\x01\x03\x12\x04\xec\t\x12\x13\n\x0c\n\x04\x04P\x02\x02\x12\
    \x04\xee\t\x02\x11\n\r\n\x05\x04P\x02\x02\x05\x12\x04\xee\t\x02\x07\n\r\
    \n\x05\x04P\x02\x02\x01\x12\x04\xee\t\x08\x0c\n\r\n\x05\x04P\x02\x02\x03\
    \x12\x04\xee\t\x0f\x10\n\x0c\n\x02\x04Q\x12\x06\xf1\t\0\xf9\t\x01\n\x0b\
    \n\x03\x04Q\x01\x12\x04\xf1\t\x08\"\n\x0b\n\x03\x04Q\x07\x12\x04\xf2\t\
    \x02\x13\n\r\n\x05\x04Q\x07\x8c\x08\x12\x04\xf2\t\x02\x13\n\x0b\n\x03\
    \x04Q\x07\x12\x04\xf3\t\x02\"\n\r\n\x05\x04Q\x07\x8d\x08\x12\x04\xf3\t\
    \x02\"\n\x0b\n\x03\x04Q\x07\x12\x04\xf4\t\x02)\n\r\n\x05\x04Q\x07\x8e\
    \x08\x12\x04\xf4\t\x02)\n\x0c\n\x04\x04Q\x02\0\x12\x04\xf6\t\x02\x15\n\r\
    \n\x05\x04Q\x02\0\x05\x12\x04\xf6\t\x02\x08\n\r\n\x05\x04Q\x02\0\x01\x12\
    \x04\xf6\t\t\x10\n\r\n\x05\x04Q\x02\0\x03\x12\x04\xf6\t\x13\x14\n\x0c\n\
    \x04\x04Q\x02\x01\x12\x04\xf7\t\x02\x14\n\r\n\x05\x04Q\x02\x01\x05\x12\
    \x04\xf7\t\x02\x08\n\r\n\x05\x04Q\x02\x01\x01\x12\x04\xf7\t\t\x0f\n\r\n\
    \x05\x04Q\x02\x01\x03\x12\x04\xf7\t\x12\x13\n\x0c\n\x04\x04Q\x02\x02\x12\
    \x04\xf8\t\x02\x12\n\r\n\x05\x04Q\x02\x02\x05\x12\x04\xf8\t\x02\x06\n\r\
    \n\x05\x04Q\x02\x02\x01\x12\x04\xf8\t\x07\r\n\r\n\x05\x04Q\x02\x02\x03\
    \x12\x04\xf8\t\x10\x11\n\x0c\n\x02\x04R\x12\x06\xfb\t\0\x84\n\x01\n\x0b\
    \n\x03\x04R\x01\x12\x04\xfb\t\x08'\n\x0b\n\x03\x04R\x07\x12\x04\xfc\t\
    \x02\x13\n\r\n\x05\x04R\x07\x8c\x08\x12\x04\xfc\t\x02\x13\n\x0b\n\x03\
    \x04R\x07\x12\x04\xfd\t\x02\"\n\r\n\x05\x04R\x07\x8d\x08\x12\x04\xfd\t\
    \x02\"\n\x0b\n\x03\x04R\x07\x12\x04\xfe\t\x02)\n\r\n\x05\x04R\x07\x8e\
    \x08\x12\x04\xfe\t\x02)\n\x0c\n\x04\x04R\x02\0\x12\x04\x80\n\x02\x15\n\r\
    \n\x05\x04R\x02\0\x05\x12\x04\x80\n\x02\x08\n\r\n\x05\x04R\x02\0\x01\x12\
    \x04\x80\n\t\x10\n\r\n\x05\x04R\x02\0\x03\x12\x04\x80\n\x13\x14\n\x0c\n\
    \x04\x04R\x02\x01\x12\x04\x81\n\x02\x14\n\r\n\x05\x04R\x02\x01\x05\x12\
    \x04\x81\n\x02\x08\n\r\n\x05\x04R\x02\x01\x01\x12\x04\x81\n\t\x0f\n\r\n\
    \x05\x04R\x02\x01\x03\x12\x04\x81\n\x12\x13\n\x0c\n\x04\x04R\x02\x02\x12\
    \x04\x83\n\x02\x11\n\r\n\x05\x04R\x02\x02\x05\x12\x04\x83\n\x02\x07\n\r\
    \n\x05\x04R\x02\x02\x01\x12\x04\x83\n\x08\x0c\n\r\n\x05\x04R\x02\x02\x03\
    \x12\x04\x83\n\x0f\x10\n\x0c\n\x02\x04S\x12\x06\x86\n\0\x8a\n\x01\n\x0b\
    \n\x03\x04S\x01\x12\x04\x86\n\x080\n\x0b\n\x03\x04S\x07\x12\x04\x87\n\
    \x02\x13\n\r\n\x05\x04S\x07\x8c\x08\x12\x04\x87\n\x02\x13\n\x0b\n\x03\
    \x04S\x07\x12\x04\x88\n\x02\"\n\r\n\x05\x04S\x07\x8d\x08\x12\x04\x88\n\
    \x02\"\n\x0b\n\x03\x04S\x07\x12\x04\x89\n\x02)\n\r\n\x05\x04S\x07\x8e\
    \x08\x12\x04\x89\n\x02)\n\x0c\n\x02\x04T\x12\x06\x8c\n\0\x93\n\x01\n\x0b\
    \n\x03\x04T\x01\x12\x04\x8c\n\x08(\n\x0b\n\x03\x04T\x07\x12\x04\x8d\n\
    \x02\x13\n\r\n\x05\x04T\x07\x8c\x08\x12\x04\x8d\n\x02\x13\n\x0b\n\x03\
    \x04T\x07\x12\x04\x8e\n\x02\"\n\r\n\x05\x04T\x07\x8d\x08\x12\x04\x8e\n\
    \x02\"\n\x0b\n\x03\x04T\x07\x12\x04\x8f\n\x02)\n\r\n\x05\x04T\x07\x8e\
    \x08\x12\x04\x8f\n\x02)\n\x0c\n\x04\x04T\x02\0\x12\x04\x91\n\x02\x12\n\r\
    \n\x05\x04T\x02\0\x05\x12\x04\x91\n\x02\x08\n\r\n\x05\x04T\x02\0\x01\x12\
    \x04\x91\n\t\r\n\r\n\x05\x04T\x02\0\x03\x12\x04\x91\n\x10\x11\n\x0c\n\
    \x04\x04T\x02\x01\x12\x04\x92\n\x02\x13\n\r\n\x05\x04T\x02\x01\x05\x12\
    \x04\x92\n\x02\x08\n\r\n\x05\x04T\x02\x01\x01\x12\x04\x92\n\t\x0e\n\r\n\
    \x05\x04T\x02\x01\x03\x12\x04\x92\n\x11\x12b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = Vec::with_capacity(1);
            deps.push(super::api_options::file_descriptor().clone());
            let mut messages = Vec::with_capacity(85);
            messages.push(HelloRequest::generated_message_descriptor_data());
            messages.push(HelloResponse::generated_message_descriptor_data());
            messages.push(ConnectRequest::generated_message_descriptor_data());
            messages.push(ConnectResponse::generated_message_descriptor_data());
            messages.push(DisconnectRequest::generated_message_descriptor_data());
            messages.push(DisconnectResponse::generated_message_descriptor_data());
            messages.push(PingRequest::generated_message_descriptor_data());
            messages.push(PingResponse::generated_message_descriptor_data());
            messages.push(DeviceInfoRequest::generated_message_descriptor_data());
            messages.push(DeviceInfoResponse::generated_message_descriptor_data());
            messages.push(ListEntitiesRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesDoneResponse::generated_message_descriptor_data());
            messages.push(SubscribeStatesRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesBinarySensorResponse::generated_message_descriptor_data());
            messages.push(BinarySensorStateResponse::generated_message_descriptor_data());
            messages.push(ListEntitiesCoverResponse::generated_message_descriptor_data());
            messages.push(CoverStateResponse::generated_message_descriptor_data());
            messages.push(CoverCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesFanResponse::generated_message_descriptor_data());
            messages.push(FanStateResponse::generated_message_descriptor_data());
            messages.push(FanCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesLightResponse::generated_message_descriptor_data());
            messages.push(LightStateResponse::generated_message_descriptor_data());
            messages.push(LightCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesSensorResponse::generated_message_descriptor_data());
            messages.push(SensorStateResponse::generated_message_descriptor_data());
            messages.push(ListEntitiesSwitchResponse::generated_message_descriptor_data());
            messages.push(SwitchStateResponse::generated_message_descriptor_data());
            messages.push(SwitchCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesTextSensorResponse::generated_message_descriptor_data());
            messages.push(TextSensorStateResponse::generated_message_descriptor_data());
            messages.push(SubscribeLogsRequest::generated_message_descriptor_data());
            messages.push(SubscribeLogsResponse::generated_message_descriptor_data());
            messages.push(SubscribeHomeassistantServicesRequest::generated_message_descriptor_data());
            messages.push(HomeassistantServiceMap::generated_message_descriptor_data());
            messages.push(HomeassistantServiceResponse::generated_message_descriptor_data());
            messages.push(SubscribeHomeAssistantStatesRequest::generated_message_descriptor_data());
            messages.push(SubscribeHomeAssistantStateResponse::generated_message_descriptor_data());
            messages.push(HomeAssistantStateResponse::generated_message_descriptor_data());
            messages.push(GetTimeRequest::generated_message_descriptor_data());
            messages.push(GetTimeResponse::generated_message_descriptor_data());
            messages.push(ListEntitiesServicesArgument::generated_message_descriptor_data());
            messages.push(ListEntitiesServicesResponse::generated_message_descriptor_data());
            messages.push(ExecuteServiceArgument::generated_message_descriptor_data());
            messages.push(ExecuteServiceRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesCameraResponse::generated_message_descriptor_data());
            messages.push(CameraImageResponse::generated_message_descriptor_data());
            messages.push(CameraImageRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesClimateResponse::generated_message_descriptor_data());
            messages.push(ClimateStateResponse::generated_message_descriptor_data());
            messages.push(ClimateCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesNumberResponse::generated_message_descriptor_data());
            messages.push(NumberStateResponse::generated_message_descriptor_data());
            messages.push(NumberCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesSelectResponse::generated_message_descriptor_data());
            messages.push(SelectStateResponse::generated_message_descriptor_data());
            messages.push(SelectCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesLockResponse::generated_message_descriptor_data());
            messages.push(LockStateResponse::generated_message_descriptor_data());
            messages.push(LockCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesButtonResponse::generated_message_descriptor_data());
            messages.push(ButtonCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesMediaPlayerResponse::generated_message_descriptor_data());
            messages.push(MediaPlayerStateResponse::generated_message_descriptor_data());
            messages.push(MediaPlayerCommandRequest::generated_message_descriptor_data());
            messages.push(SubscribeBluetoothLEAdvertisementsRequest::generated_message_descriptor_data());
            messages.push(BluetoothServiceData::generated_message_descriptor_data());
            messages.push(BluetoothLEAdvertisementResponse::generated_message_descriptor_data());
            messages.push(BluetoothDeviceRequest::generated_message_descriptor_data());
            messages.push(BluetoothDeviceConnectionResponse::generated_message_descriptor_data());
            messages.push(BluetoothGATTGetServicesRequest::generated_message_descriptor_data());
            messages.push(BluetoothGATTDescriptor::generated_message_descriptor_data());
            messages.push(BluetoothGATTCharacteristic::generated_message_descriptor_data());
            messages.push(BluetoothGATTService::generated_message_descriptor_data());
            messages.push(BluetoothGATTGetServicesResponse::generated_message_descriptor_data());
            messages.push(BluetoothGATTGetServicesDoneResponse::generated_message_descriptor_data());
            messages.push(BluetoothGATTReadRequest::generated_message_descriptor_data());
            messages.push(BluetoothGATTReadResponse::generated_message_descriptor_data());
            messages.push(BluetoothGATTWriteRequest::generated_message_descriptor_data());
            messages.push(BluetoothGATTReadDescriptorRequest::generated_message_descriptor_data());
            messages.push(BluetoothGATTWriteDescriptorRequest::generated_message_descriptor_data());
            messages.push(BluetoothGATTNotifyRequest::generated_message_descriptor_data());
            messages.push(BluetoothGATTNotifyDataResponse::generated_message_descriptor_data());
            messages.push(SubscribeBluetoothConnectionsFreeRequest::generated_message_descriptor_data());
            messages.push(BluetoothConnectionsFreeResponse::generated_message_descriptor_data());
            let mut enums = Vec::with_capacity(22);
            enums.push(EntityCategory::generated_enum_descriptor_data());
            enums.push(LegacyCoverState::generated_enum_descriptor_data());
            enums.push(CoverOperation::generated_enum_descriptor_data());
            enums.push(LegacyCoverCommand::generated_enum_descriptor_data());
            enums.push(FanSpeed::generated_enum_descriptor_data());
            enums.push(FanDirection::generated_enum_descriptor_data());
            enums.push(ColorMode::generated_enum_descriptor_data());
            enums.push(SensorStateClass::generated_enum_descriptor_data());
            enums.push(SensorLastResetType::generated_enum_descriptor_data());
            enums.push(LogLevel::generated_enum_descriptor_data());
            enums.push(ServiceArgType::generated_enum_descriptor_data());
            enums.push(ClimateMode::generated_enum_descriptor_data());
            enums.push(ClimateFanMode::generated_enum_descriptor_data());
            enums.push(ClimateSwingMode::generated_enum_descriptor_data());
            enums.push(ClimateAction::generated_enum_descriptor_data());
            enums.push(ClimatePreset::generated_enum_descriptor_data());
            enums.push(NumberMode::generated_enum_descriptor_data());
            enums.push(LockState::generated_enum_descriptor_data());
            enums.push(LockCommand::generated_enum_descriptor_data());
            enums.push(MediaPlayerState::generated_enum_descriptor_data());
            enums.push(MediaPlayerCommand::generated_enum_descriptor_data());
            enums.push(BluetoothDeviceRequestType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
