// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `api.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
pub struct HelloRequest {
    // message fields
    pub client_info: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HelloRequest {
    fn default() -> &'a HelloRequest {
        <HelloRequest as ::protobuf::Message>::default_instance()
    }
}

impl HelloRequest {
    pub fn new() -> HelloRequest {
        ::std::default::Default::default()
    }

    // string client_info = 1;


    pub fn get_client_info(&self) -> &str {
        &self.client_info
    }
    pub fn clear_client_info(&mut self) {
        self.client_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_info(&mut self, v: ::std::string::String) {
        self.client_info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_info(&mut self) -> &mut ::std::string::String {
        &mut self.client_info
    }

    // Take field
    pub fn take_client_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_info, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HelloRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.client_info.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.client_info);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.client_info.is_empty() {
            os.write_string(1, &self.client_info)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HelloRequest {
        HelloRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_info",
                |m: &HelloRequest| { &m.client_info },
                |m: &mut HelloRequest| { &mut m.client_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HelloRequest>(
                "HelloRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HelloRequest {
        static instance: ::protobuf::rt::LazyV2<HelloRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HelloRequest::new)
    }
}

impl ::protobuf::Clear for HelloRequest {
    fn clear(&mut self) {
        self.client_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HelloRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelloRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HelloResponse {
    // message fields
    pub api_version_major: u32,
    pub api_version_minor: u32,
    pub server_info: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HelloResponse {
    fn default() -> &'a HelloResponse {
        <HelloResponse as ::protobuf::Message>::default_instance()
    }
}

impl HelloResponse {
    pub fn new() -> HelloResponse {
        ::std::default::Default::default()
    }

    // uint32 api_version_major = 1;


    pub fn get_api_version_major(&self) -> u32 {
        self.api_version_major
    }
    pub fn clear_api_version_major(&mut self) {
        self.api_version_major = 0;
    }

    // Param is passed by value, moved
    pub fn set_api_version_major(&mut self, v: u32) {
        self.api_version_major = v;
    }

    // uint32 api_version_minor = 2;


    pub fn get_api_version_minor(&self) -> u32 {
        self.api_version_minor
    }
    pub fn clear_api_version_minor(&mut self) {
        self.api_version_minor = 0;
    }

    // Param is passed by value, moved
    pub fn set_api_version_minor(&mut self, v: u32) {
        self.api_version_minor = v;
    }

    // string server_info = 3;


    pub fn get_server_info(&self) -> &str {
        &self.server_info
    }
    pub fn clear_server_info(&mut self) {
        self.server_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_server_info(&mut self, v: ::std::string::String) {
        self.server_info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_info(&mut self) -> &mut ::std::string::String {
        &mut self.server_info
    }

    // Take field
    pub fn take_server_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.server_info, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HelloResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.api_version_major = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.api_version_minor = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.server_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.api_version_major != 0 {
            my_size += ::protobuf::rt::value_size(1, self.api_version_major, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.api_version_minor != 0 {
            my_size += ::protobuf::rt::value_size(2, self.api_version_minor, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.server_info.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.server_info);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.api_version_major != 0 {
            os.write_uint32(1, self.api_version_major)?;
        }
        if self.api_version_minor != 0 {
            os.write_uint32(2, self.api_version_minor)?;
        }
        if !self.server_info.is_empty() {
            os.write_string(3, &self.server_info)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HelloResponse {
        HelloResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "api_version_major",
                |m: &HelloResponse| { &m.api_version_major },
                |m: &mut HelloResponse| { &mut m.api_version_major },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "api_version_minor",
                |m: &HelloResponse| { &m.api_version_minor },
                |m: &mut HelloResponse| { &mut m.api_version_minor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "server_info",
                |m: &HelloResponse| { &m.server_info },
                |m: &mut HelloResponse| { &mut m.server_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HelloResponse>(
                "HelloResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HelloResponse {
        static instance: ::protobuf::rt::LazyV2<HelloResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HelloResponse::new)
    }
}

impl ::protobuf::Clear for HelloResponse {
    fn clear(&mut self) {
        self.api_version_major = 0;
        self.api_version_minor = 0;
        self.server_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HelloResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelloResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectRequest {
    // message fields
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnectRequest {
    fn default() -> &'a ConnectRequest {
        <ConnectRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConnectRequest {
    pub fn new() -> ConnectRequest {
        ::std::default::Default::default()
    }

    // string password = 1;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConnectRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.password.is_empty() {
            os.write_string(1, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectRequest {
        ConnectRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &ConnectRequest| { &m.password },
                |m: &mut ConnectRequest| { &mut m.password },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConnectRequest>(
                "ConnectRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConnectRequest {
        static instance: ::protobuf::rt::LazyV2<ConnectRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConnectRequest::new)
    }
}

impl ::protobuf::Clear for ConnectRequest {
    fn clear(&mut self) {
        self.password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectResponse {
    // message fields
    pub invalid_password: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConnectResponse {
    fn default() -> &'a ConnectResponse {
        <ConnectResponse as ::protobuf::Message>::default_instance()
    }
}

impl ConnectResponse {
    pub fn new() -> ConnectResponse {
        ::std::default::Default::default()
    }

    // bool invalid_password = 1;


    pub fn get_invalid_password(&self) -> bool {
        self.invalid_password
    }
    pub fn clear_invalid_password(&mut self) {
        self.invalid_password = false;
    }

    // Param is passed by value, moved
    pub fn set_invalid_password(&mut self, v: bool) {
        self.invalid_password = v;
    }
}

impl ::protobuf::Message for ConnectResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.invalid_password = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.invalid_password != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.invalid_password != false {
            os.write_bool(1, self.invalid_password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectResponse {
        ConnectResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "invalid_password",
                |m: &ConnectResponse| { &m.invalid_password },
                |m: &mut ConnectResponse| { &mut m.invalid_password },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConnectResponse>(
                "ConnectResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConnectResponse {
        static instance: ::protobuf::rt::LazyV2<ConnectResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConnectResponse::new)
    }
}

impl ::protobuf::Clear for ConnectResponse {
    fn clear(&mut self) {
        self.invalid_password = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisconnectRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisconnectRequest {
    fn default() -> &'a DisconnectRequest {
        <DisconnectRequest as ::protobuf::Message>::default_instance()
    }
}

impl DisconnectRequest {
    pub fn new() -> DisconnectRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DisconnectRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisconnectRequest {
        DisconnectRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DisconnectRequest>(
                "DisconnectRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DisconnectRequest {
        static instance: ::protobuf::rt::LazyV2<DisconnectRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DisconnectRequest::new)
    }
}

impl ::protobuf::Clear for DisconnectRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisconnectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisconnectRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DisconnectResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DisconnectResponse {
    fn default() -> &'a DisconnectResponse {
        <DisconnectResponse as ::protobuf::Message>::default_instance()
    }
}

impl DisconnectResponse {
    pub fn new() -> DisconnectResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DisconnectResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DisconnectResponse {
        DisconnectResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DisconnectResponse>(
                "DisconnectResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DisconnectResponse {
        static instance: ::protobuf::rt::LazyV2<DisconnectResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DisconnectResponse::new)
    }
}

impl ::protobuf::Clear for DisconnectResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DisconnectResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisconnectResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PingRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PingRequest {
    fn default() -> &'a PingRequest {
        <PingRequest as ::protobuf::Message>::default_instance()
    }
}

impl PingRequest {
    pub fn new() -> PingRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PingRequest {
        PingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PingRequest>(
                "PingRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PingRequest {
        static instance: ::protobuf::rt::LazyV2<PingRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PingRequest::new)
    }
}

impl ::protobuf::Clear for PingRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PingResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PingResponse {
    fn default() -> &'a PingResponse {
        <PingResponse as ::protobuf::Message>::default_instance()
    }
}

impl PingResponse {
    pub fn new() -> PingResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PingResponse {
        PingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PingResponse>(
                "PingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PingResponse {
        static instance: ::protobuf::rt::LazyV2<PingResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PingResponse::new)
    }
}

impl ::protobuf::Clear for PingResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceInfoRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceInfoRequest {
    fn default() -> &'a DeviceInfoRequest {
        <DeviceInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeviceInfoRequest {
    pub fn new() -> DeviceInfoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeviceInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceInfoRequest {
        DeviceInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeviceInfoRequest>(
                "DeviceInfoRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeviceInfoRequest {
        static instance: ::protobuf::rt::LazyV2<DeviceInfoRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeviceInfoRequest::new)
    }
}

impl ::protobuf::Clear for DeviceInfoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceInfoResponse {
    // message fields
    pub uses_password: bool,
    pub name: ::std::string::String,
    pub mac_address: ::std::string::String,
    pub esphome_version: ::std::string::String,
    pub compilation_time: ::std::string::String,
    pub model: ::std::string::String,
    pub has_deep_sleep: bool,
    pub project_name: ::std::string::String,
    pub project_version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceInfoResponse {
    fn default() -> &'a DeviceInfoResponse {
        <DeviceInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeviceInfoResponse {
    pub fn new() -> DeviceInfoResponse {
        ::std::default::Default::default()
    }

    // bool uses_password = 1;


    pub fn get_uses_password(&self) -> bool {
        self.uses_password
    }
    pub fn clear_uses_password(&mut self) {
        self.uses_password = false;
    }

    // Param is passed by value, moved
    pub fn set_uses_password(&mut self, v: bool) {
        self.uses_password = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string mac_address = 3;


    pub fn get_mac_address(&self) -> &str {
        &self.mac_address
    }
    pub fn clear_mac_address(&mut self) {
        self.mac_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_mac_address(&mut self, v: ::std::string::String) {
        self.mac_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mac_address(&mut self) -> &mut ::std::string::String {
        &mut self.mac_address
    }

    // Take field
    pub fn take_mac_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mac_address, ::std::string::String::new())
    }

    // string esphome_version = 4;


    pub fn get_esphome_version(&self) -> &str {
        &self.esphome_version
    }
    pub fn clear_esphome_version(&mut self) {
        self.esphome_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_esphome_version(&mut self, v: ::std::string::String) {
        self.esphome_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_esphome_version(&mut self) -> &mut ::std::string::String {
        &mut self.esphome_version
    }

    // Take field
    pub fn take_esphome_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.esphome_version, ::std::string::String::new())
    }

    // string compilation_time = 5;


    pub fn get_compilation_time(&self) -> &str {
        &self.compilation_time
    }
    pub fn clear_compilation_time(&mut self) {
        self.compilation_time.clear();
    }

    // Param is passed by value, moved
    pub fn set_compilation_time(&mut self, v: ::std::string::String) {
        self.compilation_time = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compilation_time(&mut self) -> &mut ::std::string::String {
        &mut self.compilation_time
    }

    // Take field
    pub fn take_compilation_time(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.compilation_time, ::std::string::String::new())
    }

    // string model = 6;


    pub fn get_model(&self) -> &str {
        &self.model
    }
    pub fn clear_model(&mut self) {
        self.model.clear();
    }

    // Param is passed by value, moved
    pub fn set_model(&mut self, v: ::std::string::String) {
        self.model = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_model(&mut self) -> &mut ::std::string::String {
        &mut self.model
    }

    // Take field
    pub fn take_model(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.model, ::std::string::String::new())
    }

    // bool has_deep_sleep = 7;


    pub fn get_has_deep_sleep(&self) -> bool {
        self.has_deep_sleep
    }
    pub fn clear_has_deep_sleep(&mut self) {
        self.has_deep_sleep = false;
    }

    // Param is passed by value, moved
    pub fn set_has_deep_sleep(&mut self, v: bool) {
        self.has_deep_sleep = v;
    }

    // string project_name = 8;


    pub fn get_project_name(&self) -> &str {
        &self.project_name
    }
    pub fn clear_project_name(&mut self) {
        self.project_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_name(&mut self, v: ::std::string::String) {
        self.project_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_name(&mut self) -> &mut ::std::string::String {
        &mut self.project_name
    }

    // Take field
    pub fn take_project_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_name, ::std::string::String::new())
    }

    // string project_version = 9;


    pub fn get_project_version(&self) -> &str {
        &self.project_version
    }
    pub fn clear_project_version(&mut self) {
        self.project_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_version(&mut self, v: ::std::string::String) {
        self.project_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_version(&mut self) -> &mut ::std::string::String {
        &mut self.project_version
    }

    // Take field
    pub fn take_project_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeviceInfoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.uses_password = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mac_address)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.esphome_version)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.compilation_time)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.model)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_deep_sleep = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_name)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.uses_password != false {
            my_size += 2;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.mac_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.mac_address);
        }
        if !self.esphome_version.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.esphome_version);
        }
        if !self.compilation_time.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.compilation_time);
        }
        if !self.model.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.model);
        }
        if self.has_deep_sleep != false {
            my_size += 2;
        }
        if !self.project_name.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.project_name);
        }
        if !self.project_version.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.project_version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.uses_password != false {
            os.write_bool(1, self.uses_password)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.mac_address.is_empty() {
            os.write_string(3, &self.mac_address)?;
        }
        if !self.esphome_version.is_empty() {
            os.write_string(4, &self.esphome_version)?;
        }
        if !self.compilation_time.is_empty() {
            os.write_string(5, &self.compilation_time)?;
        }
        if !self.model.is_empty() {
            os.write_string(6, &self.model)?;
        }
        if self.has_deep_sleep != false {
            os.write_bool(7, self.has_deep_sleep)?;
        }
        if !self.project_name.is_empty() {
            os.write_string(8, &self.project_name)?;
        }
        if !self.project_version.is_empty() {
            os.write_string(9, &self.project_version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceInfoResponse {
        DeviceInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "uses_password",
                |m: &DeviceInfoResponse| { &m.uses_password },
                |m: &mut DeviceInfoResponse| { &mut m.uses_password },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeviceInfoResponse| { &m.name },
                |m: &mut DeviceInfoResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mac_address",
                |m: &DeviceInfoResponse| { &m.mac_address },
                |m: &mut DeviceInfoResponse| { &mut m.mac_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "esphome_version",
                |m: &DeviceInfoResponse| { &m.esphome_version },
                |m: &mut DeviceInfoResponse| { &mut m.esphome_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "compilation_time",
                |m: &DeviceInfoResponse| { &m.compilation_time },
                |m: &mut DeviceInfoResponse| { &mut m.compilation_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "model",
                |m: &DeviceInfoResponse| { &m.model },
                |m: &mut DeviceInfoResponse| { &mut m.model },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_deep_sleep",
                |m: &DeviceInfoResponse| { &m.has_deep_sleep },
                |m: &mut DeviceInfoResponse| { &mut m.has_deep_sleep },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_name",
                |m: &DeviceInfoResponse| { &m.project_name },
                |m: &mut DeviceInfoResponse| { &mut m.project_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_version",
                |m: &DeviceInfoResponse| { &m.project_version },
                |m: &mut DeviceInfoResponse| { &mut m.project_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeviceInfoResponse>(
                "DeviceInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeviceInfoResponse {
        static instance: ::protobuf::rt::LazyV2<DeviceInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeviceInfoResponse::new)
    }
}

impl ::protobuf::Clear for DeviceInfoResponse {
    fn clear(&mut self) {
        self.uses_password = false;
        self.name.clear();
        self.mac_address.clear();
        self.esphome_version.clear();
        self.compilation_time.clear();
        self.model.clear();
        self.has_deep_sleep = false;
        self.project_name.clear();
        self.project_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesRequest {
    fn default() -> &'a ListEntitiesRequest {
        <ListEntitiesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesRequest {
    pub fn new() -> ListEntitiesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListEntitiesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesRequest {
        ListEntitiesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesRequest>(
                "ListEntitiesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesRequest {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesRequest::new)
    }
}

impl ::protobuf::Clear for ListEntitiesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesDoneResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesDoneResponse {
    fn default() -> &'a ListEntitiesDoneResponse {
        <ListEntitiesDoneResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesDoneResponse {
    pub fn new() -> ListEntitiesDoneResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ListEntitiesDoneResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesDoneResponse {
        ListEntitiesDoneResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesDoneResponse>(
                "ListEntitiesDoneResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesDoneResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesDoneResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesDoneResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesDoneResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesDoneResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesDoneResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeStatesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeStatesRequest {
    fn default() -> &'a SubscribeStatesRequest {
        <SubscribeStatesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeStatesRequest {
    pub fn new() -> SubscribeStatesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeStatesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeStatesRequest {
        SubscribeStatesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscribeStatesRequest>(
                "SubscribeStatesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscribeStatesRequest {
        static instance: ::protobuf::rt::LazyV2<SubscribeStatesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscribeStatesRequest::new)
    }
}

impl ::protobuf::Clear for SubscribeStatesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeStatesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeStatesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesBinarySensorResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub device_class: ::std::string::String,
    pub is_status_binary_sensor: bool,
    pub disabled_by_default: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesBinarySensorResponse {
    fn default() -> &'a ListEntitiesBinarySensorResponse {
        <ListEntitiesBinarySensorResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesBinarySensorResponse {
    pub fn new() -> ListEntitiesBinarySensorResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // string device_class = 5;


    pub fn get_device_class(&self) -> &str {
        &self.device_class
    }
    pub fn clear_device_class(&mut self) {
        self.device_class.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_class(&mut self, v: ::std::string::String) {
        self.device_class = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_class(&mut self) -> &mut ::std::string::String {
        &mut self.device_class
    }

    // Take field
    pub fn take_device_class(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_class, ::std::string::String::new())
    }

    // bool is_status_binary_sensor = 6;


    pub fn get_is_status_binary_sensor(&self) -> bool {
        self.is_status_binary_sensor
    }
    pub fn clear_is_status_binary_sensor(&mut self) {
        self.is_status_binary_sensor = false;
    }

    // Param is passed by value, moved
    pub fn set_is_status_binary_sensor(&mut self, v: bool) {
        self.is_status_binary_sensor = v;
    }

    // bool disabled_by_default = 7;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }
}

impl ::protobuf::Message for ListEntitiesBinarySensorResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_class)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_status_binary_sensor = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.device_class);
        }
        if self.is_status_binary_sensor != false {
            my_size += 2;
        }
        if self.disabled_by_default != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.device_class.is_empty() {
            os.write_string(5, &self.device_class)?;
        }
        if self.is_status_binary_sensor != false {
            os.write_bool(6, self.is_status_binary_sensor)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(7, self.disabled_by_default)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesBinarySensorResponse {
        ListEntitiesBinarySensorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesBinarySensorResponse| { &m.object_id },
                |m: &mut ListEntitiesBinarySensorResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesBinarySensorResponse| { &m.key },
                |m: &mut ListEntitiesBinarySensorResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesBinarySensorResponse| { &m.name },
                |m: &mut ListEntitiesBinarySensorResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesBinarySensorResponse| { &m.unique_id },
                |m: &mut ListEntitiesBinarySensorResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_class",
                |m: &ListEntitiesBinarySensorResponse| { &m.device_class },
                |m: &mut ListEntitiesBinarySensorResponse| { &mut m.device_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_status_binary_sensor",
                |m: &ListEntitiesBinarySensorResponse| { &m.is_status_binary_sensor },
                |m: &mut ListEntitiesBinarySensorResponse| { &mut m.is_status_binary_sensor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesBinarySensorResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesBinarySensorResponse| { &mut m.disabled_by_default },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesBinarySensorResponse>(
                "ListEntitiesBinarySensorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesBinarySensorResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesBinarySensorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesBinarySensorResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesBinarySensorResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.device_class.clear();
        self.is_status_binary_sensor = false;
        self.disabled_by_default = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesBinarySensorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesBinarySensorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BinarySensorStateResponse {
    // message fields
    pub key: u32,
    pub state: bool,
    pub missing_state: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BinarySensorStateResponse {
    fn default() -> &'a BinarySensorStateResponse {
        <BinarySensorStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl BinarySensorStateResponse {
    pub fn new() -> BinarySensorStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bool state = 2;


    pub fn get_state(&self) -> bool {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = false;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = v;
    }

    // bool missing_state = 3;


    pub fn get_missing_state(&self) -> bool {
        self.missing_state
    }
    pub fn clear_missing_state(&mut self) {
        self.missing_state = false;
    }

    // Param is passed by value, moved
    pub fn set_missing_state(&mut self, v: bool) {
        self.missing_state = v;
    }
}

impl ::protobuf::Message for BinarySensorStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.state = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.missing_state = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.state != false {
            my_size += 2;
        }
        if self.missing_state != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BinarySensorStateResponse {
        BinarySensorStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &BinarySensorStateResponse| { &m.key },
                |m: &mut BinarySensorStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "state",
                |m: &BinarySensorStateResponse| { &m.state },
                |m: &mut BinarySensorStateResponse| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "missing_state",
                |m: &BinarySensorStateResponse| { &m.missing_state },
                |m: &mut BinarySensorStateResponse| { &mut m.missing_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BinarySensorStateResponse>(
                "BinarySensorStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BinarySensorStateResponse {
        static instance: ::protobuf::rt::LazyV2<BinarySensorStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BinarySensorStateResponse::new)
    }
}

impl ::protobuf::Clear for BinarySensorStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.missing_state = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BinarySensorStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BinarySensorStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesCoverResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub assumed_state: bool,
    pub supports_position: bool,
    pub supports_tilt: bool,
    pub device_class: ::std::string::String,
    pub disabled_by_default: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesCoverResponse {
    fn default() -> &'a ListEntitiesCoverResponse {
        <ListEntitiesCoverResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesCoverResponse {
    pub fn new() -> ListEntitiesCoverResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // bool assumed_state = 5;


    pub fn get_assumed_state(&self) -> bool {
        self.assumed_state
    }
    pub fn clear_assumed_state(&mut self) {
        self.assumed_state = false;
    }

    // Param is passed by value, moved
    pub fn set_assumed_state(&mut self, v: bool) {
        self.assumed_state = v;
    }

    // bool supports_position = 6;


    pub fn get_supports_position(&self) -> bool {
        self.supports_position
    }
    pub fn clear_supports_position(&mut self) {
        self.supports_position = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_position(&mut self, v: bool) {
        self.supports_position = v;
    }

    // bool supports_tilt = 7;


    pub fn get_supports_tilt(&self) -> bool {
        self.supports_tilt
    }
    pub fn clear_supports_tilt(&mut self) {
        self.supports_tilt = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_tilt(&mut self, v: bool) {
        self.supports_tilt = v;
    }

    // string device_class = 8;


    pub fn get_device_class(&self) -> &str {
        &self.device_class
    }
    pub fn clear_device_class(&mut self) {
        self.device_class.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_class(&mut self, v: ::std::string::String) {
        self.device_class = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_class(&mut self) -> &mut ::std::string::String {
        &mut self.device_class
    }

    // Take field
    pub fn take_device_class(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_class, ::std::string::String::new())
    }

    // bool disabled_by_default = 9;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }
}

impl ::protobuf::Message for ListEntitiesCoverResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.assumed_state = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_position = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_tilt = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_class)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if self.assumed_state != false {
            my_size += 2;
        }
        if self.supports_position != false {
            my_size += 2;
        }
        if self.supports_tilt != false {
            my_size += 2;
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.device_class);
        }
        if self.disabled_by_default != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if self.assumed_state != false {
            os.write_bool(5, self.assumed_state)?;
        }
        if self.supports_position != false {
            os.write_bool(6, self.supports_position)?;
        }
        if self.supports_tilt != false {
            os.write_bool(7, self.supports_tilt)?;
        }
        if !self.device_class.is_empty() {
            os.write_string(8, &self.device_class)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(9, self.disabled_by_default)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesCoverResponse {
        ListEntitiesCoverResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesCoverResponse| { &m.object_id },
                |m: &mut ListEntitiesCoverResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesCoverResponse| { &m.key },
                |m: &mut ListEntitiesCoverResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesCoverResponse| { &m.name },
                |m: &mut ListEntitiesCoverResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesCoverResponse| { &m.unique_id },
                |m: &mut ListEntitiesCoverResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "assumed_state",
                |m: &ListEntitiesCoverResponse| { &m.assumed_state },
                |m: &mut ListEntitiesCoverResponse| { &mut m.assumed_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_position",
                |m: &ListEntitiesCoverResponse| { &m.supports_position },
                |m: &mut ListEntitiesCoverResponse| { &mut m.supports_position },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_tilt",
                |m: &ListEntitiesCoverResponse| { &m.supports_tilt },
                |m: &mut ListEntitiesCoverResponse| { &mut m.supports_tilt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_class",
                |m: &ListEntitiesCoverResponse| { &m.device_class },
                |m: &mut ListEntitiesCoverResponse| { &mut m.device_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesCoverResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesCoverResponse| { &mut m.disabled_by_default },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesCoverResponse>(
                "ListEntitiesCoverResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesCoverResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesCoverResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesCoverResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesCoverResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.assumed_state = false;
        self.supports_position = false;
        self.supports_tilt = false;
        self.device_class.clear();
        self.disabled_by_default = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesCoverResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesCoverResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CoverStateResponse {
    // message fields
    pub key: u32,
    pub legacy_state: LegacyCoverState,
    pub position: f32,
    pub tilt: f32,
    pub current_operation: CoverOperation,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CoverStateResponse {
    fn default() -> &'a CoverStateResponse {
        <CoverStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl CoverStateResponse {
    pub fn new() -> CoverStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // .LegacyCoverState legacy_state = 2;


    pub fn get_legacy_state(&self) -> LegacyCoverState {
        self.legacy_state
    }
    pub fn clear_legacy_state(&mut self) {
        self.legacy_state = LegacyCoverState::LEGACY_COVER_STATE_OPEN;
    }

    // Param is passed by value, moved
    pub fn set_legacy_state(&mut self, v: LegacyCoverState) {
        self.legacy_state = v;
    }

    // float position = 3;


    pub fn get_position(&self) -> f32 {
        self.position
    }
    pub fn clear_position(&mut self) {
        self.position = 0.;
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: f32) {
        self.position = v;
    }

    // float tilt = 4;


    pub fn get_tilt(&self) -> f32 {
        self.tilt
    }
    pub fn clear_tilt(&mut self) {
        self.tilt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_tilt(&mut self, v: f32) {
        self.tilt = v;
    }

    // .CoverOperation current_operation = 5;


    pub fn get_current_operation(&self) -> CoverOperation {
        self.current_operation
    }
    pub fn clear_current_operation(&mut self) {
        self.current_operation = CoverOperation::COVER_OPERATION_IDLE;
    }

    // Param is passed by value, moved
    pub fn set_current_operation(&mut self, v: CoverOperation) {
        self.current_operation = v;
    }
}

impl ::protobuf::Message for CoverStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.legacy_state, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.position = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.tilt = tmp;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.current_operation, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.legacy_state != LegacyCoverState::LEGACY_COVER_STATE_OPEN {
            my_size += ::protobuf::rt::enum_size(2, self.legacy_state);
        }
        if self.position != 0. {
            my_size += 5;
        }
        if self.tilt != 0. {
            my_size += 5;
        }
        if self.current_operation != CoverOperation::COVER_OPERATION_IDLE {
            my_size += ::protobuf::rt::enum_size(5, self.current_operation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.legacy_state != LegacyCoverState::LEGACY_COVER_STATE_OPEN {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.legacy_state))?;
        }
        if self.position != 0. {
            os.write_float(3, self.position)?;
        }
        if self.tilt != 0. {
            os.write_float(4, self.tilt)?;
        }
        if self.current_operation != CoverOperation::COVER_OPERATION_IDLE {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.current_operation))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CoverStateResponse {
        CoverStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &CoverStateResponse| { &m.key },
                |m: &mut CoverStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LegacyCoverState>>(
                "legacy_state",
                |m: &CoverStateResponse| { &m.legacy_state },
                |m: &mut CoverStateResponse| { &mut m.legacy_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "position",
                |m: &CoverStateResponse| { &m.position },
                |m: &mut CoverStateResponse| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "tilt",
                |m: &CoverStateResponse| { &m.tilt },
                |m: &mut CoverStateResponse| { &mut m.tilt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CoverOperation>>(
                "current_operation",
                |m: &CoverStateResponse| { &m.current_operation },
                |m: &mut CoverStateResponse| { &mut m.current_operation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CoverStateResponse>(
                "CoverStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CoverStateResponse {
        static instance: ::protobuf::rt::LazyV2<CoverStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CoverStateResponse::new)
    }
}

impl ::protobuf::Clear for CoverStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.legacy_state = LegacyCoverState::LEGACY_COVER_STATE_OPEN;
        self.position = 0.;
        self.tilt = 0.;
        self.current_operation = CoverOperation::COVER_OPERATION_IDLE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CoverStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoverStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CoverCommandRequest {
    // message fields
    pub key: u32,
    pub has_legacy_command: bool,
    pub legacy_command: LegacyCoverCommand,
    pub has_position: bool,
    pub position: f32,
    pub has_tilt: bool,
    pub tilt: f32,
    pub stop: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CoverCommandRequest {
    fn default() -> &'a CoverCommandRequest {
        <CoverCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl CoverCommandRequest {
    pub fn new() -> CoverCommandRequest {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bool has_legacy_command = 2;


    pub fn get_has_legacy_command(&self) -> bool {
        self.has_legacy_command
    }
    pub fn clear_has_legacy_command(&mut self) {
        self.has_legacy_command = false;
    }

    // Param is passed by value, moved
    pub fn set_has_legacy_command(&mut self, v: bool) {
        self.has_legacy_command = v;
    }

    // .LegacyCoverCommand legacy_command = 3;


    pub fn get_legacy_command(&self) -> LegacyCoverCommand {
        self.legacy_command
    }
    pub fn clear_legacy_command(&mut self) {
        self.legacy_command = LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN;
    }

    // Param is passed by value, moved
    pub fn set_legacy_command(&mut self, v: LegacyCoverCommand) {
        self.legacy_command = v;
    }

    // bool has_position = 4;


    pub fn get_has_position(&self) -> bool {
        self.has_position
    }
    pub fn clear_has_position(&mut self) {
        self.has_position = false;
    }

    // Param is passed by value, moved
    pub fn set_has_position(&mut self, v: bool) {
        self.has_position = v;
    }

    // float position = 5;


    pub fn get_position(&self) -> f32 {
        self.position
    }
    pub fn clear_position(&mut self) {
        self.position = 0.;
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: f32) {
        self.position = v;
    }

    // bool has_tilt = 6;


    pub fn get_has_tilt(&self) -> bool {
        self.has_tilt
    }
    pub fn clear_has_tilt(&mut self) {
        self.has_tilt = false;
    }

    // Param is passed by value, moved
    pub fn set_has_tilt(&mut self, v: bool) {
        self.has_tilt = v;
    }

    // float tilt = 7;


    pub fn get_tilt(&self) -> f32 {
        self.tilt
    }
    pub fn clear_tilt(&mut self) {
        self.tilt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_tilt(&mut self, v: f32) {
        self.tilt = v;
    }

    // bool stop = 8;


    pub fn get_stop(&self) -> bool {
        self.stop
    }
    pub fn clear_stop(&mut self) {
        self.stop = false;
    }

    // Param is passed by value, moved
    pub fn set_stop(&mut self, v: bool) {
        self.stop = v;
    }
}

impl ::protobuf::Message for CoverCommandRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_legacy_command = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.legacy_command, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_position = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.position = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_tilt = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.tilt = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stop = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.has_legacy_command != false {
            my_size += 2;
        }
        if self.legacy_command != LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN {
            my_size += ::protobuf::rt::enum_size(3, self.legacy_command);
        }
        if self.has_position != false {
            my_size += 2;
        }
        if self.position != 0. {
            my_size += 5;
        }
        if self.has_tilt != false {
            my_size += 2;
        }
        if self.tilt != 0. {
            my_size += 5;
        }
        if self.stop != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_legacy_command != false {
            os.write_bool(2, self.has_legacy_command)?;
        }
        if self.legacy_command != LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.legacy_command))?;
        }
        if self.has_position != false {
            os.write_bool(4, self.has_position)?;
        }
        if self.position != 0. {
            os.write_float(5, self.position)?;
        }
        if self.has_tilt != false {
            os.write_bool(6, self.has_tilt)?;
        }
        if self.tilt != 0. {
            os.write_float(7, self.tilt)?;
        }
        if self.stop != false {
            os.write_bool(8, self.stop)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CoverCommandRequest {
        CoverCommandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &CoverCommandRequest| { &m.key },
                |m: &mut CoverCommandRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_legacy_command",
                |m: &CoverCommandRequest| { &m.has_legacy_command },
                |m: &mut CoverCommandRequest| { &mut m.has_legacy_command },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LegacyCoverCommand>>(
                "legacy_command",
                |m: &CoverCommandRequest| { &m.legacy_command },
                |m: &mut CoverCommandRequest| { &mut m.legacy_command },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_position",
                |m: &CoverCommandRequest| { &m.has_position },
                |m: &mut CoverCommandRequest| { &mut m.has_position },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "position",
                |m: &CoverCommandRequest| { &m.position },
                |m: &mut CoverCommandRequest| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_tilt",
                |m: &CoverCommandRequest| { &m.has_tilt },
                |m: &mut CoverCommandRequest| { &mut m.has_tilt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "tilt",
                |m: &CoverCommandRequest| { &m.tilt },
                |m: &mut CoverCommandRequest| { &mut m.tilt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stop",
                |m: &CoverCommandRequest| { &m.stop },
                |m: &mut CoverCommandRequest| { &mut m.stop },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CoverCommandRequest>(
                "CoverCommandRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CoverCommandRequest {
        static instance: ::protobuf::rt::LazyV2<CoverCommandRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CoverCommandRequest::new)
    }
}

impl ::protobuf::Clear for CoverCommandRequest {
    fn clear(&mut self) {
        self.key = 0;
        self.has_legacy_command = false;
        self.legacy_command = LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN;
        self.has_position = false;
        self.position = 0.;
        self.has_tilt = false;
        self.tilt = 0.;
        self.stop = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CoverCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoverCommandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesFanResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub supports_oscillation: bool,
    pub supports_speed: bool,
    pub supports_direction: bool,
    pub supported_speed_levels: i32,
    pub disabled_by_default: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesFanResponse {
    fn default() -> &'a ListEntitiesFanResponse {
        <ListEntitiesFanResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesFanResponse {
    pub fn new() -> ListEntitiesFanResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // bool supports_oscillation = 5;


    pub fn get_supports_oscillation(&self) -> bool {
        self.supports_oscillation
    }
    pub fn clear_supports_oscillation(&mut self) {
        self.supports_oscillation = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_oscillation(&mut self, v: bool) {
        self.supports_oscillation = v;
    }

    // bool supports_speed = 6;


    pub fn get_supports_speed(&self) -> bool {
        self.supports_speed
    }
    pub fn clear_supports_speed(&mut self) {
        self.supports_speed = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_speed(&mut self, v: bool) {
        self.supports_speed = v;
    }

    // bool supports_direction = 7;


    pub fn get_supports_direction(&self) -> bool {
        self.supports_direction
    }
    pub fn clear_supports_direction(&mut self) {
        self.supports_direction = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_direction(&mut self, v: bool) {
        self.supports_direction = v;
    }

    // int32 supported_speed_levels = 8;


    pub fn get_supported_speed_levels(&self) -> i32 {
        self.supported_speed_levels
    }
    pub fn clear_supported_speed_levels(&mut self) {
        self.supported_speed_levels = 0;
    }

    // Param is passed by value, moved
    pub fn set_supported_speed_levels(&mut self, v: i32) {
        self.supported_speed_levels = v;
    }

    // bool disabled_by_default = 9;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }
}

impl ::protobuf::Message for ListEntitiesFanResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_oscillation = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_speed = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_direction = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.supported_speed_levels = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if self.supports_oscillation != false {
            my_size += 2;
        }
        if self.supports_speed != false {
            my_size += 2;
        }
        if self.supports_direction != false {
            my_size += 2;
        }
        if self.supported_speed_levels != 0 {
            my_size += ::protobuf::rt::value_size(8, self.supported_speed_levels, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.disabled_by_default != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if self.supports_oscillation != false {
            os.write_bool(5, self.supports_oscillation)?;
        }
        if self.supports_speed != false {
            os.write_bool(6, self.supports_speed)?;
        }
        if self.supports_direction != false {
            os.write_bool(7, self.supports_direction)?;
        }
        if self.supported_speed_levels != 0 {
            os.write_int32(8, self.supported_speed_levels)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(9, self.disabled_by_default)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesFanResponse {
        ListEntitiesFanResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesFanResponse| { &m.object_id },
                |m: &mut ListEntitiesFanResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesFanResponse| { &m.key },
                |m: &mut ListEntitiesFanResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesFanResponse| { &m.name },
                |m: &mut ListEntitiesFanResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesFanResponse| { &m.unique_id },
                |m: &mut ListEntitiesFanResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_oscillation",
                |m: &ListEntitiesFanResponse| { &m.supports_oscillation },
                |m: &mut ListEntitiesFanResponse| { &mut m.supports_oscillation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_speed",
                |m: &ListEntitiesFanResponse| { &m.supports_speed },
                |m: &mut ListEntitiesFanResponse| { &mut m.supports_speed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_direction",
                |m: &ListEntitiesFanResponse| { &m.supports_direction },
                |m: &mut ListEntitiesFanResponse| { &mut m.supports_direction },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "supported_speed_levels",
                |m: &ListEntitiesFanResponse| { &m.supported_speed_levels },
                |m: &mut ListEntitiesFanResponse| { &mut m.supported_speed_levels },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesFanResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesFanResponse| { &mut m.disabled_by_default },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesFanResponse>(
                "ListEntitiesFanResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesFanResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesFanResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesFanResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesFanResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.supports_oscillation = false;
        self.supports_speed = false;
        self.supports_direction = false;
        self.supported_speed_levels = 0;
        self.disabled_by_default = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesFanResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesFanResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FanStateResponse {
    // message fields
    pub key: u32,
    pub state: bool,
    pub oscillating: bool,
    pub speed: FanSpeed,
    pub direction: FanDirection,
    pub speed_level: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FanStateResponse {
    fn default() -> &'a FanStateResponse {
        <FanStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl FanStateResponse {
    pub fn new() -> FanStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bool state = 2;


    pub fn get_state(&self) -> bool {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = false;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = v;
    }

    // bool oscillating = 3;


    pub fn get_oscillating(&self) -> bool {
        self.oscillating
    }
    pub fn clear_oscillating(&mut self) {
        self.oscillating = false;
    }

    // Param is passed by value, moved
    pub fn set_oscillating(&mut self, v: bool) {
        self.oscillating = v;
    }

    // .FanSpeed speed = 4;


    pub fn get_speed(&self) -> FanSpeed {
        self.speed
    }
    pub fn clear_speed(&mut self) {
        self.speed = FanSpeed::FAN_SPEED_LOW;
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: FanSpeed) {
        self.speed = v;
    }

    // .FanDirection direction = 5;


    pub fn get_direction(&self) -> FanDirection {
        self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction = FanDirection::FAN_DIRECTION_FORWARD;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: FanDirection) {
        self.direction = v;
    }

    // int32 speed_level = 6;


    pub fn get_speed_level(&self) -> i32 {
        self.speed_level
    }
    pub fn clear_speed_level(&mut self) {
        self.speed_level = 0;
    }

    // Param is passed by value, moved
    pub fn set_speed_level(&mut self, v: i32) {
        self.speed_level = v;
    }
}

impl ::protobuf::Message for FanStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.state = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.oscillating = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.speed, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.speed_level = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.state != false {
            my_size += 2;
        }
        if self.oscillating != false {
            my_size += 2;
        }
        if self.speed != FanSpeed::FAN_SPEED_LOW {
            my_size += ::protobuf::rt::enum_size(4, self.speed);
        }
        if self.direction != FanDirection::FAN_DIRECTION_FORWARD {
            my_size += ::protobuf::rt::enum_size(5, self.direction);
        }
        if self.speed_level != 0 {
            my_size += ::protobuf::rt::value_size(6, self.speed_level, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        if self.oscillating != false {
            os.write_bool(3, self.oscillating)?;
        }
        if self.speed != FanSpeed::FAN_SPEED_LOW {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.speed))?;
        }
        if self.direction != FanDirection::FAN_DIRECTION_FORWARD {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.direction))?;
        }
        if self.speed_level != 0 {
            os.write_int32(6, self.speed_level)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FanStateResponse {
        FanStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &FanStateResponse| { &m.key },
                |m: &mut FanStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "state",
                |m: &FanStateResponse| { &m.state },
                |m: &mut FanStateResponse| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "oscillating",
                |m: &FanStateResponse| { &m.oscillating },
                |m: &mut FanStateResponse| { &mut m.oscillating },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FanSpeed>>(
                "speed",
                |m: &FanStateResponse| { &m.speed },
                |m: &mut FanStateResponse| { &mut m.speed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FanDirection>>(
                "direction",
                |m: &FanStateResponse| { &m.direction },
                |m: &mut FanStateResponse| { &mut m.direction },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "speed_level",
                |m: &FanStateResponse| { &m.speed_level },
                |m: &mut FanStateResponse| { &mut m.speed_level },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FanStateResponse>(
                "FanStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FanStateResponse {
        static instance: ::protobuf::rt::LazyV2<FanStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FanStateResponse::new)
    }
}

impl ::protobuf::Clear for FanStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.oscillating = false;
        self.speed = FanSpeed::FAN_SPEED_LOW;
        self.direction = FanDirection::FAN_DIRECTION_FORWARD;
        self.speed_level = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FanStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FanStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FanCommandRequest {
    // message fields
    pub key: u32,
    pub has_state: bool,
    pub state: bool,
    pub has_speed: bool,
    pub speed: FanSpeed,
    pub has_oscillating: bool,
    pub oscillating: bool,
    pub has_direction: bool,
    pub direction: FanDirection,
    pub has_speed_level: bool,
    pub speed_level: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FanCommandRequest {
    fn default() -> &'a FanCommandRequest {
        <FanCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl FanCommandRequest {
    pub fn new() -> FanCommandRequest {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bool has_state = 2;


    pub fn get_has_state(&self) -> bool {
        self.has_state
    }
    pub fn clear_has_state(&mut self) {
        self.has_state = false;
    }

    // Param is passed by value, moved
    pub fn set_has_state(&mut self, v: bool) {
        self.has_state = v;
    }

    // bool state = 3;


    pub fn get_state(&self) -> bool {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = false;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = v;
    }

    // bool has_speed = 4;


    pub fn get_has_speed(&self) -> bool {
        self.has_speed
    }
    pub fn clear_has_speed(&mut self) {
        self.has_speed = false;
    }

    // Param is passed by value, moved
    pub fn set_has_speed(&mut self, v: bool) {
        self.has_speed = v;
    }

    // .FanSpeed speed = 5;


    pub fn get_speed(&self) -> FanSpeed {
        self.speed
    }
    pub fn clear_speed(&mut self) {
        self.speed = FanSpeed::FAN_SPEED_LOW;
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: FanSpeed) {
        self.speed = v;
    }

    // bool has_oscillating = 6;


    pub fn get_has_oscillating(&self) -> bool {
        self.has_oscillating
    }
    pub fn clear_has_oscillating(&mut self) {
        self.has_oscillating = false;
    }

    // Param is passed by value, moved
    pub fn set_has_oscillating(&mut self, v: bool) {
        self.has_oscillating = v;
    }

    // bool oscillating = 7;


    pub fn get_oscillating(&self) -> bool {
        self.oscillating
    }
    pub fn clear_oscillating(&mut self) {
        self.oscillating = false;
    }

    // Param is passed by value, moved
    pub fn set_oscillating(&mut self, v: bool) {
        self.oscillating = v;
    }

    // bool has_direction = 8;


    pub fn get_has_direction(&self) -> bool {
        self.has_direction
    }
    pub fn clear_has_direction(&mut self) {
        self.has_direction = false;
    }

    // Param is passed by value, moved
    pub fn set_has_direction(&mut self, v: bool) {
        self.has_direction = v;
    }

    // .FanDirection direction = 9;


    pub fn get_direction(&self) -> FanDirection {
        self.direction
    }
    pub fn clear_direction(&mut self) {
        self.direction = FanDirection::FAN_DIRECTION_FORWARD;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: FanDirection) {
        self.direction = v;
    }

    // bool has_speed_level = 10;


    pub fn get_has_speed_level(&self) -> bool {
        self.has_speed_level
    }
    pub fn clear_has_speed_level(&mut self) {
        self.has_speed_level = false;
    }

    // Param is passed by value, moved
    pub fn set_has_speed_level(&mut self, v: bool) {
        self.has_speed_level = v;
    }

    // int32 speed_level = 11;


    pub fn get_speed_level(&self) -> i32 {
        self.speed_level
    }
    pub fn clear_speed_level(&mut self) {
        self.speed_level = 0;
    }

    // Param is passed by value, moved
    pub fn set_speed_level(&mut self, v: i32) {
        self.speed_level = v;
    }
}

impl ::protobuf::Message for FanCommandRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_state = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.state = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_speed = tmp;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.speed, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_oscillating = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.oscillating = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_direction = tmp;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 9, &mut self.unknown_fields)?
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_speed_level = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.speed_level = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.has_state != false {
            my_size += 2;
        }
        if self.state != false {
            my_size += 2;
        }
        if self.has_speed != false {
            my_size += 2;
        }
        if self.speed != FanSpeed::FAN_SPEED_LOW {
            my_size += ::protobuf::rt::enum_size(5, self.speed);
        }
        if self.has_oscillating != false {
            my_size += 2;
        }
        if self.oscillating != false {
            my_size += 2;
        }
        if self.has_direction != false {
            my_size += 2;
        }
        if self.direction != FanDirection::FAN_DIRECTION_FORWARD {
            my_size += ::protobuf::rt::enum_size(9, self.direction);
        }
        if self.has_speed_level != false {
            my_size += 2;
        }
        if self.speed_level != 0 {
            my_size += ::protobuf::rt::value_size(11, self.speed_level, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_state != false {
            os.write_bool(2, self.has_state)?;
        }
        if self.state != false {
            os.write_bool(3, self.state)?;
        }
        if self.has_speed != false {
            os.write_bool(4, self.has_speed)?;
        }
        if self.speed != FanSpeed::FAN_SPEED_LOW {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.speed))?;
        }
        if self.has_oscillating != false {
            os.write_bool(6, self.has_oscillating)?;
        }
        if self.oscillating != false {
            os.write_bool(7, self.oscillating)?;
        }
        if self.has_direction != false {
            os.write_bool(8, self.has_direction)?;
        }
        if self.direction != FanDirection::FAN_DIRECTION_FORWARD {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.direction))?;
        }
        if self.has_speed_level != false {
            os.write_bool(10, self.has_speed_level)?;
        }
        if self.speed_level != 0 {
            os.write_int32(11, self.speed_level)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FanCommandRequest {
        FanCommandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &FanCommandRequest| { &m.key },
                |m: &mut FanCommandRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_state",
                |m: &FanCommandRequest| { &m.has_state },
                |m: &mut FanCommandRequest| { &mut m.has_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "state",
                |m: &FanCommandRequest| { &m.state },
                |m: &mut FanCommandRequest| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_speed",
                |m: &FanCommandRequest| { &m.has_speed },
                |m: &mut FanCommandRequest| { &mut m.has_speed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FanSpeed>>(
                "speed",
                |m: &FanCommandRequest| { &m.speed },
                |m: &mut FanCommandRequest| { &mut m.speed },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_oscillating",
                |m: &FanCommandRequest| { &m.has_oscillating },
                |m: &mut FanCommandRequest| { &mut m.has_oscillating },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "oscillating",
                |m: &FanCommandRequest| { &m.oscillating },
                |m: &mut FanCommandRequest| { &mut m.oscillating },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_direction",
                |m: &FanCommandRequest| { &m.has_direction },
                |m: &mut FanCommandRequest| { &mut m.has_direction },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FanDirection>>(
                "direction",
                |m: &FanCommandRequest| { &m.direction },
                |m: &mut FanCommandRequest| { &mut m.direction },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_speed_level",
                |m: &FanCommandRequest| { &m.has_speed_level },
                |m: &mut FanCommandRequest| { &mut m.has_speed_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "speed_level",
                |m: &FanCommandRequest| { &m.speed_level },
                |m: &mut FanCommandRequest| { &mut m.speed_level },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FanCommandRequest>(
                "FanCommandRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FanCommandRequest {
        static instance: ::protobuf::rt::LazyV2<FanCommandRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FanCommandRequest::new)
    }
}

impl ::protobuf::Clear for FanCommandRequest {
    fn clear(&mut self) {
        self.key = 0;
        self.has_state = false;
        self.state = false;
        self.has_speed = false;
        self.speed = FanSpeed::FAN_SPEED_LOW;
        self.has_oscillating = false;
        self.oscillating = false;
        self.has_direction = false;
        self.direction = FanDirection::FAN_DIRECTION_FORWARD;
        self.has_speed_level = false;
        self.speed_level = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FanCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FanCommandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesLightResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub supported_color_modes: ::std::vec::Vec<ColorMode>,
    pub legacy_supports_brightness: bool,
    pub legacy_supports_rgb: bool,
    pub legacy_supports_white_value: bool,
    pub legacy_supports_color_temperature: bool,
    pub min_mireds: f32,
    pub max_mireds: f32,
    pub effects: ::protobuf::RepeatedField<::std::string::String>,
    pub disabled_by_default: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesLightResponse {
    fn default() -> &'a ListEntitiesLightResponse {
        <ListEntitiesLightResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesLightResponse {
    pub fn new() -> ListEntitiesLightResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // repeated .ColorMode supported_color_modes = 12;


    pub fn get_supported_color_modes(&self) -> &[ColorMode] {
        &self.supported_color_modes
    }
    pub fn clear_supported_color_modes(&mut self) {
        self.supported_color_modes.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_color_modes(&mut self, v: ::std::vec::Vec<ColorMode>) {
        self.supported_color_modes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_color_modes(&mut self) -> &mut ::std::vec::Vec<ColorMode> {
        &mut self.supported_color_modes
    }

    // Take field
    pub fn take_supported_color_modes(&mut self) -> ::std::vec::Vec<ColorMode> {
        ::std::mem::replace(&mut self.supported_color_modes, ::std::vec::Vec::new())
    }

    // bool legacy_supports_brightness = 5;


    pub fn get_legacy_supports_brightness(&self) -> bool {
        self.legacy_supports_brightness
    }
    pub fn clear_legacy_supports_brightness(&mut self) {
        self.legacy_supports_brightness = false;
    }

    // Param is passed by value, moved
    pub fn set_legacy_supports_brightness(&mut self, v: bool) {
        self.legacy_supports_brightness = v;
    }

    // bool legacy_supports_rgb = 6;


    pub fn get_legacy_supports_rgb(&self) -> bool {
        self.legacy_supports_rgb
    }
    pub fn clear_legacy_supports_rgb(&mut self) {
        self.legacy_supports_rgb = false;
    }

    // Param is passed by value, moved
    pub fn set_legacy_supports_rgb(&mut self, v: bool) {
        self.legacy_supports_rgb = v;
    }

    // bool legacy_supports_white_value = 7;


    pub fn get_legacy_supports_white_value(&self) -> bool {
        self.legacy_supports_white_value
    }
    pub fn clear_legacy_supports_white_value(&mut self) {
        self.legacy_supports_white_value = false;
    }

    // Param is passed by value, moved
    pub fn set_legacy_supports_white_value(&mut self, v: bool) {
        self.legacy_supports_white_value = v;
    }

    // bool legacy_supports_color_temperature = 8;


    pub fn get_legacy_supports_color_temperature(&self) -> bool {
        self.legacy_supports_color_temperature
    }
    pub fn clear_legacy_supports_color_temperature(&mut self) {
        self.legacy_supports_color_temperature = false;
    }

    // Param is passed by value, moved
    pub fn set_legacy_supports_color_temperature(&mut self, v: bool) {
        self.legacy_supports_color_temperature = v;
    }

    // float min_mireds = 9;


    pub fn get_min_mireds(&self) -> f32 {
        self.min_mireds
    }
    pub fn clear_min_mireds(&mut self) {
        self.min_mireds = 0.;
    }

    // Param is passed by value, moved
    pub fn set_min_mireds(&mut self, v: f32) {
        self.min_mireds = v;
    }

    // float max_mireds = 10;


    pub fn get_max_mireds(&self) -> f32 {
        self.max_mireds
    }
    pub fn clear_max_mireds(&mut self) {
        self.max_mireds = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max_mireds(&mut self, v: f32) {
        self.max_mireds = v;
    }

    // repeated string effects = 11;


    pub fn get_effects(&self) -> &[::std::string::String] {
        &self.effects
    }
    pub fn clear_effects(&mut self) {
        self.effects.clear();
    }

    // Param is passed by value, moved
    pub fn set_effects(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.effects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_effects(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.effects
    }

    // Take field
    pub fn take_effects(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.effects, ::protobuf::RepeatedField::new())
    }

    // bool disabled_by_default = 13;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }
}

impl ::protobuf::Message for ListEntitiesLightResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.supported_color_modes, 12, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.legacy_supports_brightness = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.legacy_supports_rgb = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.legacy_supports_white_value = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.legacy_supports_color_temperature = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.min_mireds = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.max_mireds = tmp;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.effects)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        for value in &self.supported_color_modes {
            my_size += ::protobuf::rt::enum_size(12, *value);
        };
        if self.legacy_supports_brightness != false {
            my_size += 2;
        }
        if self.legacy_supports_rgb != false {
            my_size += 2;
        }
        if self.legacy_supports_white_value != false {
            my_size += 2;
        }
        if self.legacy_supports_color_temperature != false {
            my_size += 2;
        }
        if self.min_mireds != 0. {
            my_size += 5;
        }
        if self.max_mireds != 0. {
            my_size += 5;
        }
        for value in &self.effects {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if self.disabled_by_default != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        for v in &self.supported_color_modes {
            os.write_enum(12, ::protobuf::ProtobufEnum::value(v))?;
        };
        if self.legacy_supports_brightness != false {
            os.write_bool(5, self.legacy_supports_brightness)?;
        }
        if self.legacy_supports_rgb != false {
            os.write_bool(6, self.legacy_supports_rgb)?;
        }
        if self.legacy_supports_white_value != false {
            os.write_bool(7, self.legacy_supports_white_value)?;
        }
        if self.legacy_supports_color_temperature != false {
            os.write_bool(8, self.legacy_supports_color_temperature)?;
        }
        if self.min_mireds != 0. {
            os.write_float(9, self.min_mireds)?;
        }
        if self.max_mireds != 0. {
            os.write_float(10, self.max_mireds)?;
        }
        for v in &self.effects {
            os.write_string(11, &v)?;
        };
        if self.disabled_by_default != false {
            os.write_bool(13, self.disabled_by_default)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesLightResponse {
        ListEntitiesLightResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesLightResponse| { &m.object_id },
                |m: &mut ListEntitiesLightResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesLightResponse| { &m.key },
                |m: &mut ListEntitiesLightResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesLightResponse| { &m.name },
                |m: &mut ListEntitiesLightResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesLightResponse| { &m.unique_id },
                |m: &mut ListEntitiesLightResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ColorMode>>(
                "supported_color_modes",
                |m: &ListEntitiesLightResponse| { &m.supported_color_modes },
                |m: &mut ListEntitiesLightResponse| { &mut m.supported_color_modes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "legacy_supports_brightness",
                |m: &ListEntitiesLightResponse| { &m.legacy_supports_brightness },
                |m: &mut ListEntitiesLightResponse| { &mut m.legacy_supports_brightness },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "legacy_supports_rgb",
                |m: &ListEntitiesLightResponse| { &m.legacy_supports_rgb },
                |m: &mut ListEntitiesLightResponse| { &mut m.legacy_supports_rgb },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "legacy_supports_white_value",
                |m: &ListEntitiesLightResponse| { &m.legacy_supports_white_value },
                |m: &mut ListEntitiesLightResponse| { &mut m.legacy_supports_white_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "legacy_supports_color_temperature",
                |m: &ListEntitiesLightResponse| { &m.legacy_supports_color_temperature },
                |m: &mut ListEntitiesLightResponse| { &mut m.legacy_supports_color_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "min_mireds",
                |m: &ListEntitiesLightResponse| { &m.min_mireds },
                |m: &mut ListEntitiesLightResponse| { &mut m.min_mireds },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "max_mireds",
                |m: &ListEntitiesLightResponse| { &m.max_mireds },
                |m: &mut ListEntitiesLightResponse| { &mut m.max_mireds },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "effects",
                |m: &ListEntitiesLightResponse| { &m.effects },
                |m: &mut ListEntitiesLightResponse| { &mut m.effects },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesLightResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesLightResponse| { &mut m.disabled_by_default },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesLightResponse>(
                "ListEntitiesLightResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesLightResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesLightResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesLightResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesLightResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.supported_color_modes.clear();
        self.legacy_supports_brightness = false;
        self.legacy_supports_rgb = false;
        self.legacy_supports_white_value = false;
        self.legacy_supports_color_temperature = false;
        self.min_mireds = 0.;
        self.max_mireds = 0.;
        self.effects.clear();
        self.disabled_by_default = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesLightResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesLightResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LightStateResponse {
    // message fields
    pub key: u32,
    pub state: bool,
    pub brightness: f32,
    pub color_mode: ColorMode,
    pub color_brightness: f32,
    pub red: f32,
    pub green: f32,
    pub blue: f32,
    pub white: f32,
    pub color_temperature: f32,
    pub cold_white: f32,
    pub warm_white: f32,
    pub effect: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LightStateResponse {
    fn default() -> &'a LightStateResponse {
        <LightStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl LightStateResponse {
    pub fn new() -> LightStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bool state = 2;


    pub fn get_state(&self) -> bool {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = false;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = v;
    }

    // float brightness = 3;


    pub fn get_brightness(&self) -> f32 {
        self.brightness
    }
    pub fn clear_brightness(&mut self) {
        self.brightness = 0.;
    }

    // Param is passed by value, moved
    pub fn set_brightness(&mut self, v: f32) {
        self.brightness = v;
    }

    // .ColorMode color_mode = 11;


    pub fn get_color_mode(&self) -> ColorMode {
        self.color_mode
    }
    pub fn clear_color_mode(&mut self) {
        self.color_mode = ColorMode::COLOR_MODE_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_color_mode(&mut self, v: ColorMode) {
        self.color_mode = v;
    }

    // float color_brightness = 10;


    pub fn get_color_brightness(&self) -> f32 {
        self.color_brightness
    }
    pub fn clear_color_brightness(&mut self) {
        self.color_brightness = 0.;
    }

    // Param is passed by value, moved
    pub fn set_color_brightness(&mut self, v: f32) {
        self.color_brightness = v;
    }

    // float red = 4;


    pub fn get_red(&self) -> f32 {
        self.red
    }
    pub fn clear_red(&mut self) {
        self.red = 0.;
    }

    // Param is passed by value, moved
    pub fn set_red(&mut self, v: f32) {
        self.red = v;
    }

    // float green = 5;


    pub fn get_green(&self) -> f32 {
        self.green
    }
    pub fn clear_green(&mut self) {
        self.green = 0.;
    }

    // Param is passed by value, moved
    pub fn set_green(&mut self, v: f32) {
        self.green = v;
    }

    // float blue = 6;


    pub fn get_blue(&self) -> f32 {
        self.blue
    }
    pub fn clear_blue(&mut self) {
        self.blue = 0.;
    }

    // Param is passed by value, moved
    pub fn set_blue(&mut self, v: f32) {
        self.blue = v;
    }

    // float white = 7;


    pub fn get_white(&self) -> f32 {
        self.white
    }
    pub fn clear_white(&mut self) {
        self.white = 0.;
    }

    // Param is passed by value, moved
    pub fn set_white(&mut self, v: f32) {
        self.white = v;
    }

    // float color_temperature = 8;


    pub fn get_color_temperature(&self) -> f32 {
        self.color_temperature
    }
    pub fn clear_color_temperature(&mut self) {
        self.color_temperature = 0.;
    }

    // Param is passed by value, moved
    pub fn set_color_temperature(&mut self, v: f32) {
        self.color_temperature = v;
    }

    // float cold_white = 12;


    pub fn get_cold_white(&self) -> f32 {
        self.cold_white
    }
    pub fn clear_cold_white(&mut self) {
        self.cold_white = 0.;
    }

    // Param is passed by value, moved
    pub fn set_cold_white(&mut self, v: f32) {
        self.cold_white = v;
    }

    // float warm_white = 13;


    pub fn get_warm_white(&self) -> f32 {
        self.warm_white
    }
    pub fn clear_warm_white(&mut self) {
        self.warm_white = 0.;
    }

    // Param is passed by value, moved
    pub fn set_warm_white(&mut self, v: f32) {
        self.warm_white = v;
    }

    // string effect = 9;


    pub fn get_effect(&self) -> &str {
        &self.effect
    }
    pub fn clear_effect(&mut self) {
        self.effect.clear();
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: ::std::string::String) {
        self.effect = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effect(&mut self) -> &mut ::std::string::String {
        &mut self.effect
    }

    // Take field
    pub fn take_effect(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.effect, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LightStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.state = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.brightness = tmp;
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.color_mode, 11, &mut self.unknown_fields)?
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.color_brightness = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.red = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.green = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.blue = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.white = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.color_temperature = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cold_white = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.warm_white = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.effect)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.state != false {
            my_size += 2;
        }
        if self.brightness != 0. {
            my_size += 5;
        }
        if self.color_mode != ColorMode::COLOR_MODE_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(11, self.color_mode);
        }
        if self.color_brightness != 0. {
            my_size += 5;
        }
        if self.red != 0. {
            my_size += 5;
        }
        if self.green != 0. {
            my_size += 5;
        }
        if self.blue != 0. {
            my_size += 5;
        }
        if self.white != 0. {
            my_size += 5;
        }
        if self.color_temperature != 0. {
            my_size += 5;
        }
        if self.cold_white != 0. {
            my_size += 5;
        }
        if self.warm_white != 0. {
            my_size += 5;
        }
        if !self.effect.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.effect);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        if self.brightness != 0. {
            os.write_float(3, self.brightness)?;
        }
        if self.color_mode != ColorMode::COLOR_MODE_UNKNOWN {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&self.color_mode))?;
        }
        if self.color_brightness != 0. {
            os.write_float(10, self.color_brightness)?;
        }
        if self.red != 0. {
            os.write_float(4, self.red)?;
        }
        if self.green != 0. {
            os.write_float(5, self.green)?;
        }
        if self.blue != 0. {
            os.write_float(6, self.blue)?;
        }
        if self.white != 0. {
            os.write_float(7, self.white)?;
        }
        if self.color_temperature != 0. {
            os.write_float(8, self.color_temperature)?;
        }
        if self.cold_white != 0. {
            os.write_float(12, self.cold_white)?;
        }
        if self.warm_white != 0. {
            os.write_float(13, self.warm_white)?;
        }
        if !self.effect.is_empty() {
            os.write_string(9, &self.effect)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LightStateResponse {
        LightStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &LightStateResponse| { &m.key },
                |m: &mut LightStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "state",
                |m: &LightStateResponse| { &m.state },
                |m: &mut LightStateResponse| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "brightness",
                |m: &LightStateResponse| { &m.brightness },
                |m: &mut LightStateResponse| { &mut m.brightness },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ColorMode>>(
                "color_mode",
                |m: &LightStateResponse| { &m.color_mode },
                |m: &mut LightStateResponse| { &mut m.color_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "color_brightness",
                |m: &LightStateResponse| { &m.color_brightness },
                |m: &mut LightStateResponse| { &mut m.color_brightness },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "red",
                |m: &LightStateResponse| { &m.red },
                |m: &mut LightStateResponse| { &mut m.red },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "green",
                |m: &LightStateResponse| { &m.green },
                |m: &mut LightStateResponse| { &mut m.green },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "blue",
                |m: &LightStateResponse| { &m.blue },
                |m: &mut LightStateResponse| { &mut m.blue },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "white",
                |m: &LightStateResponse| { &m.white },
                |m: &mut LightStateResponse| { &mut m.white },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "color_temperature",
                |m: &LightStateResponse| { &m.color_temperature },
                |m: &mut LightStateResponse| { &mut m.color_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "cold_white",
                |m: &LightStateResponse| { &m.cold_white },
                |m: &mut LightStateResponse| { &mut m.cold_white },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "warm_white",
                |m: &LightStateResponse| { &m.warm_white },
                |m: &mut LightStateResponse| { &mut m.warm_white },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "effect",
                |m: &LightStateResponse| { &m.effect },
                |m: &mut LightStateResponse| { &mut m.effect },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LightStateResponse>(
                "LightStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LightStateResponse {
        static instance: ::protobuf::rt::LazyV2<LightStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LightStateResponse::new)
    }
}

impl ::protobuf::Clear for LightStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.brightness = 0.;
        self.color_mode = ColorMode::COLOR_MODE_UNKNOWN;
        self.color_brightness = 0.;
        self.red = 0.;
        self.green = 0.;
        self.blue = 0.;
        self.white = 0.;
        self.color_temperature = 0.;
        self.cold_white = 0.;
        self.warm_white = 0.;
        self.effect.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LightStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LightStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LightCommandRequest {
    // message fields
    pub key: u32,
    pub has_state: bool,
    pub state: bool,
    pub has_brightness: bool,
    pub brightness: f32,
    pub has_color_mode: bool,
    pub color_mode: ColorMode,
    pub has_color_brightness: bool,
    pub color_brightness: f32,
    pub has_rgb: bool,
    pub red: f32,
    pub green: f32,
    pub blue: f32,
    pub has_white: bool,
    pub white: f32,
    pub has_color_temperature: bool,
    pub color_temperature: f32,
    pub has_cold_white: bool,
    pub cold_white: f32,
    pub has_warm_white: bool,
    pub warm_white: f32,
    pub has_transition_length: bool,
    pub transition_length: u32,
    pub has_flash_length: bool,
    pub flash_length: u32,
    pub has_effect: bool,
    pub effect: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LightCommandRequest {
    fn default() -> &'a LightCommandRequest {
        <LightCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl LightCommandRequest {
    pub fn new() -> LightCommandRequest {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bool has_state = 2;


    pub fn get_has_state(&self) -> bool {
        self.has_state
    }
    pub fn clear_has_state(&mut self) {
        self.has_state = false;
    }

    // Param is passed by value, moved
    pub fn set_has_state(&mut self, v: bool) {
        self.has_state = v;
    }

    // bool state = 3;


    pub fn get_state(&self) -> bool {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = false;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = v;
    }

    // bool has_brightness = 4;


    pub fn get_has_brightness(&self) -> bool {
        self.has_brightness
    }
    pub fn clear_has_brightness(&mut self) {
        self.has_brightness = false;
    }

    // Param is passed by value, moved
    pub fn set_has_brightness(&mut self, v: bool) {
        self.has_brightness = v;
    }

    // float brightness = 5;


    pub fn get_brightness(&self) -> f32 {
        self.brightness
    }
    pub fn clear_brightness(&mut self) {
        self.brightness = 0.;
    }

    // Param is passed by value, moved
    pub fn set_brightness(&mut self, v: f32) {
        self.brightness = v;
    }

    // bool has_color_mode = 22;


    pub fn get_has_color_mode(&self) -> bool {
        self.has_color_mode
    }
    pub fn clear_has_color_mode(&mut self) {
        self.has_color_mode = false;
    }

    // Param is passed by value, moved
    pub fn set_has_color_mode(&mut self, v: bool) {
        self.has_color_mode = v;
    }

    // .ColorMode color_mode = 23;


    pub fn get_color_mode(&self) -> ColorMode {
        self.color_mode
    }
    pub fn clear_color_mode(&mut self) {
        self.color_mode = ColorMode::COLOR_MODE_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_color_mode(&mut self, v: ColorMode) {
        self.color_mode = v;
    }

    // bool has_color_brightness = 20;


    pub fn get_has_color_brightness(&self) -> bool {
        self.has_color_brightness
    }
    pub fn clear_has_color_brightness(&mut self) {
        self.has_color_brightness = false;
    }

    // Param is passed by value, moved
    pub fn set_has_color_brightness(&mut self, v: bool) {
        self.has_color_brightness = v;
    }

    // float color_brightness = 21;


    pub fn get_color_brightness(&self) -> f32 {
        self.color_brightness
    }
    pub fn clear_color_brightness(&mut self) {
        self.color_brightness = 0.;
    }

    // Param is passed by value, moved
    pub fn set_color_brightness(&mut self, v: f32) {
        self.color_brightness = v;
    }

    // bool has_rgb = 6;


    pub fn get_has_rgb(&self) -> bool {
        self.has_rgb
    }
    pub fn clear_has_rgb(&mut self) {
        self.has_rgb = false;
    }

    // Param is passed by value, moved
    pub fn set_has_rgb(&mut self, v: bool) {
        self.has_rgb = v;
    }

    // float red = 7;


    pub fn get_red(&self) -> f32 {
        self.red
    }
    pub fn clear_red(&mut self) {
        self.red = 0.;
    }

    // Param is passed by value, moved
    pub fn set_red(&mut self, v: f32) {
        self.red = v;
    }

    // float green = 8;


    pub fn get_green(&self) -> f32 {
        self.green
    }
    pub fn clear_green(&mut self) {
        self.green = 0.;
    }

    // Param is passed by value, moved
    pub fn set_green(&mut self, v: f32) {
        self.green = v;
    }

    // float blue = 9;


    pub fn get_blue(&self) -> f32 {
        self.blue
    }
    pub fn clear_blue(&mut self) {
        self.blue = 0.;
    }

    // Param is passed by value, moved
    pub fn set_blue(&mut self, v: f32) {
        self.blue = v;
    }

    // bool has_white = 10;


    pub fn get_has_white(&self) -> bool {
        self.has_white
    }
    pub fn clear_has_white(&mut self) {
        self.has_white = false;
    }

    // Param is passed by value, moved
    pub fn set_has_white(&mut self, v: bool) {
        self.has_white = v;
    }

    // float white = 11;


    pub fn get_white(&self) -> f32 {
        self.white
    }
    pub fn clear_white(&mut self) {
        self.white = 0.;
    }

    // Param is passed by value, moved
    pub fn set_white(&mut self, v: f32) {
        self.white = v;
    }

    // bool has_color_temperature = 12;


    pub fn get_has_color_temperature(&self) -> bool {
        self.has_color_temperature
    }
    pub fn clear_has_color_temperature(&mut self) {
        self.has_color_temperature = false;
    }

    // Param is passed by value, moved
    pub fn set_has_color_temperature(&mut self, v: bool) {
        self.has_color_temperature = v;
    }

    // float color_temperature = 13;


    pub fn get_color_temperature(&self) -> f32 {
        self.color_temperature
    }
    pub fn clear_color_temperature(&mut self) {
        self.color_temperature = 0.;
    }

    // Param is passed by value, moved
    pub fn set_color_temperature(&mut self, v: f32) {
        self.color_temperature = v;
    }

    // bool has_cold_white = 24;


    pub fn get_has_cold_white(&self) -> bool {
        self.has_cold_white
    }
    pub fn clear_has_cold_white(&mut self) {
        self.has_cold_white = false;
    }

    // Param is passed by value, moved
    pub fn set_has_cold_white(&mut self, v: bool) {
        self.has_cold_white = v;
    }

    // float cold_white = 25;


    pub fn get_cold_white(&self) -> f32 {
        self.cold_white
    }
    pub fn clear_cold_white(&mut self) {
        self.cold_white = 0.;
    }

    // Param is passed by value, moved
    pub fn set_cold_white(&mut self, v: f32) {
        self.cold_white = v;
    }

    // bool has_warm_white = 26;


    pub fn get_has_warm_white(&self) -> bool {
        self.has_warm_white
    }
    pub fn clear_has_warm_white(&mut self) {
        self.has_warm_white = false;
    }

    // Param is passed by value, moved
    pub fn set_has_warm_white(&mut self, v: bool) {
        self.has_warm_white = v;
    }

    // float warm_white = 27;


    pub fn get_warm_white(&self) -> f32 {
        self.warm_white
    }
    pub fn clear_warm_white(&mut self) {
        self.warm_white = 0.;
    }

    // Param is passed by value, moved
    pub fn set_warm_white(&mut self, v: f32) {
        self.warm_white = v;
    }

    // bool has_transition_length = 14;


    pub fn get_has_transition_length(&self) -> bool {
        self.has_transition_length
    }
    pub fn clear_has_transition_length(&mut self) {
        self.has_transition_length = false;
    }

    // Param is passed by value, moved
    pub fn set_has_transition_length(&mut self, v: bool) {
        self.has_transition_length = v;
    }

    // uint32 transition_length = 15;


    pub fn get_transition_length(&self) -> u32 {
        self.transition_length
    }
    pub fn clear_transition_length(&mut self) {
        self.transition_length = 0;
    }

    // Param is passed by value, moved
    pub fn set_transition_length(&mut self, v: u32) {
        self.transition_length = v;
    }

    // bool has_flash_length = 16;


    pub fn get_has_flash_length(&self) -> bool {
        self.has_flash_length
    }
    pub fn clear_has_flash_length(&mut self) {
        self.has_flash_length = false;
    }

    // Param is passed by value, moved
    pub fn set_has_flash_length(&mut self, v: bool) {
        self.has_flash_length = v;
    }

    // uint32 flash_length = 17;


    pub fn get_flash_length(&self) -> u32 {
        self.flash_length
    }
    pub fn clear_flash_length(&mut self) {
        self.flash_length = 0;
    }

    // Param is passed by value, moved
    pub fn set_flash_length(&mut self, v: u32) {
        self.flash_length = v;
    }

    // bool has_effect = 18;


    pub fn get_has_effect(&self) -> bool {
        self.has_effect
    }
    pub fn clear_has_effect(&mut self) {
        self.has_effect = false;
    }

    // Param is passed by value, moved
    pub fn set_has_effect(&mut self, v: bool) {
        self.has_effect = v;
    }

    // string effect = 19;


    pub fn get_effect(&self) -> &str {
        &self.effect
    }
    pub fn clear_effect(&mut self) {
        self.effect.clear();
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: ::std::string::String) {
        self.effect = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effect(&mut self) -> &mut ::std::string::String {
        &mut self.effect
    }

    // Take field
    pub fn take_effect(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.effect, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LightCommandRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_state = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.state = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_brightness = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.brightness = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_color_mode = tmp;
                },
                23 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.color_mode, 23, &mut self.unknown_fields)?
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_color_brightness = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.color_brightness = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_rgb = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.red = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.green = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.blue = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_white = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.white = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_color_temperature = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.color_temperature = tmp;
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_cold_white = tmp;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cold_white = tmp;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_warm_white = tmp;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.warm_white = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_transition_length = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.transition_length = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_flash_length = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.flash_length = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_effect = tmp;
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.effect)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.has_state != false {
            my_size += 2;
        }
        if self.state != false {
            my_size += 2;
        }
        if self.has_brightness != false {
            my_size += 2;
        }
        if self.brightness != 0. {
            my_size += 5;
        }
        if self.has_color_mode != false {
            my_size += 3;
        }
        if self.color_mode != ColorMode::COLOR_MODE_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(23, self.color_mode);
        }
        if self.has_color_brightness != false {
            my_size += 3;
        }
        if self.color_brightness != 0. {
            my_size += 6;
        }
        if self.has_rgb != false {
            my_size += 2;
        }
        if self.red != 0. {
            my_size += 5;
        }
        if self.green != 0. {
            my_size += 5;
        }
        if self.blue != 0. {
            my_size += 5;
        }
        if self.has_white != false {
            my_size += 2;
        }
        if self.white != 0. {
            my_size += 5;
        }
        if self.has_color_temperature != false {
            my_size += 2;
        }
        if self.color_temperature != 0. {
            my_size += 5;
        }
        if self.has_cold_white != false {
            my_size += 3;
        }
        if self.cold_white != 0. {
            my_size += 6;
        }
        if self.has_warm_white != false {
            my_size += 3;
        }
        if self.warm_white != 0. {
            my_size += 6;
        }
        if self.has_transition_length != false {
            my_size += 2;
        }
        if self.transition_length != 0 {
            my_size += ::protobuf::rt::value_size(15, self.transition_length, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.has_flash_length != false {
            my_size += 3;
        }
        if self.flash_length != 0 {
            my_size += ::protobuf::rt::value_size(17, self.flash_length, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.has_effect != false {
            my_size += 3;
        }
        if !self.effect.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.effect);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_state != false {
            os.write_bool(2, self.has_state)?;
        }
        if self.state != false {
            os.write_bool(3, self.state)?;
        }
        if self.has_brightness != false {
            os.write_bool(4, self.has_brightness)?;
        }
        if self.brightness != 0. {
            os.write_float(5, self.brightness)?;
        }
        if self.has_color_mode != false {
            os.write_bool(22, self.has_color_mode)?;
        }
        if self.color_mode != ColorMode::COLOR_MODE_UNKNOWN {
            os.write_enum(23, ::protobuf::ProtobufEnum::value(&self.color_mode))?;
        }
        if self.has_color_brightness != false {
            os.write_bool(20, self.has_color_brightness)?;
        }
        if self.color_brightness != 0. {
            os.write_float(21, self.color_brightness)?;
        }
        if self.has_rgb != false {
            os.write_bool(6, self.has_rgb)?;
        }
        if self.red != 0. {
            os.write_float(7, self.red)?;
        }
        if self.green != 0. {
            os.write_float(8, self.green)?;
        }
        if self.blue != 0. {
            os.write_float(9, self.blue)?;
        }
        if self.has_white != false {
            os.write_bool(10, self.has_white)?;
        }
        if self.white != 0. {
            os.write_float(11, self.white)?;
        }
        if self.has_color_temperature != false {
            os.write_bool(12, self.has_color_temperature)?;
        }
        if self.color_temperature != 0. {
            os.write_float(13, self.color_temperature)?;
        }
        if self.has_cold_white != false {
            os.write_bool(24, self.has_cold_white)?;
        }
        if self.cold_white != 0. {
            os.write_float(25, self.cold_white)?;
        }
        if self.has_warm_white != false {
            os.write_bool(26, self.has_warm_white)?;
        }
        if self.warm_white != 0. {
            os.write_float(27, self.warm_white)?;
        }
        if self.has_transition_length != false {
            os.write_bool(14, self.has_transition_length)?;
        }
        if self.transition_length != 0 {
            os.write_uint32(15, self.transition_length)?;
        }
        if self.has_flash_length != false {
            os.write_bool(16, self.has_flash_length)?;
        }
        if self.flash_length != 0 {
            os.write_uint32(17, self.flash_length)?;
        }
        if self.has_effect != false {
            os.write_bool(18, self.has_effect)?;
        }
        if !self.effect.is_empty() {
            os.write_string(19, &self.effect)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LightCommandRequest {
        LightCommandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &LightCommandRequest| { &m.key },
                |m: &mut LightCommandRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_state",
                |m: &LightCommandRequest| { &m.has_state },
                |m: &mut LightCommandRequest| { &mut m.has_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "state",
                |m: &LightCommandRequest| { &m.state },
                |m: &mut LightCommandRequest| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_brightness",
                |m: &LightCommandRequest| { &m.has_brightness },
                |m: &mut LightCommandRequest| { &mut m.has_brightness },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "brightness",
                |m: &LightCommandRequest| { &m.brightness },
                |m: &mut LightCommandRequest| { &mut m.brightness },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_color_mode",
                |m: &LightCommandRequest| { &m.has_color_mode },
                |m: &mut LightCommandRequest| { &mut m.has_color_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ColorMode>>(
                "color_mode",
                |m: &LightCommandRequest| { &m.color_mode },
                |m: &mut LightCommandRequest| { &mut m.color_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_color_brightness",
                |m: &LightCommandRequest| { &m.has_color_brightness },
                |m: &mut LightCommandRequest| { &mut m.has_color_brightness },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "color_brightness",
                |m: &LightCommandRequest| { &m.color_brightness },
                |m: &mut LightCommandRequest| { &mut m.color_brightness },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_rgb",
                |m: &LightCommandRequest| { &m.has_rgb },
                |m: &mut LightCommandRequest| { &mut m.has_rgb },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "red",
                |m: &LightCommandRequest| { &m.red },
                |m: &mut LightCommandRequest| { &mut m.red },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "green",
                |m: &LightCommandRequest| { &m.green },
                |m: &mut LightCommandRequest| { &mut m.green },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "blue",
                |m: &LightCommandRequest| { &m.blue },
                |m: &mut LightCommandRequest| { &mut m.blue },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_white",
                |m: &LightCommandRequest| { &m.has_white },
                |m: &mut LightCommandRequest| { &mut m.has_white },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "white",
                |m: &LightCommandRequest| { &m.white },
                |m: &mut LightCommandRequest| { &mut m.white },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_color_temperature",
                |m: &LightCommandRequest| { &m.has_color_temperature },
                |m: &mut LightCommandRequest| { &mut m.has_color_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "color_temperature",
                |m: &LightCommandRequest| { &m.color_temperature },
                |m: &mut LightCommandRequest| { &mut m.color_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_cold_white",
                |m: &LightCommandRequest| { &m.has_cold_white },
                |m: &mut LightCommandRequest| { &mut m.has_cold_white },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "cold_white",
                |m: &LightCommandRequest| { &m.cold_white },
                |m: &mut LightCommandRequest| { &mut m.cold_white },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_warm_white",
                |m: &LightCommandRequest| { &m.has_warm_white },
                |m: &mut LightCommandRequest| { &mut m.has_warm_white },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "warm_white",
                |m: &LightCommandRequest| { &m.warm_white },
                |m: &mut LightCommandRequest| { &mut m.warm_white },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_transition_length",
                |m: &LightCommandRequest| { &m.has_transition_length },
                |m: &mut LightCommandRequest| { &mut m.has_transition_length },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "transition_length",
                |m: &LightCommandRequest| { &m.transition_length },
                |m: &mut LightCommandRequest| { &mut m.transition_length },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_flash_length",
                |m: &LightCommandRequest| { &m.has_flash_length },
                |m: &mut LightCommandRequest| { &mut m.has_flash_length },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "flash_length",
                |m: &LightCommandRequest| { &m.flash_length },
                |m: &mut LightCommandRequest| { &mut m.flash_length },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_effect",
                |m: &LightCommandRequest| { &m.has_effect },
                |m: &mut LightCommandRequest| { &mut m.has_effect },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "effect",
                |m: &LightCommandRequest| { &m.effect },
                |m: &mut LightCommandRequest| { &mut m.effect },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LightCommandRequest>(
                "LightCommandRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LightCommandRequest {
        static instance: ::protobuf::rt::LazyV2<LightCommandRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LightCommandRequest::new)
    }
}

impl ::protobuf::Clear for LightCommandRequest {
    fn clear(&mut self) {
        self.key = 0;
        self.has_state = false;
        self.state = false;
        self.has_brightness = false;
        self.brightness = 0.;
        self.has_color_mode = false;
        self.color_mode = ColorMode::COLOR_MODE_UNKNOWN;
        self.has_color_brightness = false;
        self.color_brightness = 0.;
        self.has_rgb = false;
        self.red = 0.;
        self.green = 0.;
        self.blue = 0.;
        self.has_white = false;
        self.white = 0.;
        self.has_color_temperature = false;
        self.color_temperature = 0.;
        self.has_cold_white = false;
        self.cold_white = 0.;
        self.has_warm_white = false;
        self.warm_white = 0.;
        self.has_transition_length = false;
        self.transition_length = 0;
        self.has_flash_length = false;
        self.flash_length = 0;
        self.has_effect = false;
        self.effect.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LightCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LightCommandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesSensorResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub icon: ::std::string::String,
    pub unit_of_measurement: ::std::string::String,
    pub accuracy_decimals: i32,
    pub force_update: bool,
    pub device_class: ::std::string::String,
    pub state_class: SensorStateClass,
    pub last_reset_type: SensorLastResetType,
    pub disabled_by_default: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesSensorResponse {
    fn default() -> &'a ListEntitiesSensorResponse {
        <ListEntitiesSensorResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesSensorResponse {
    pub fn new() -> ListEntitiesSensorResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // string icon = 5;


    pub fn get_icon(&self) -> &str {
        &self.icon
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        &mut self.icon
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.icon, ::std::string::String::new())
    }

    // string unit_of_measurement = 6;


    pub fn get_unit_of_measurement(&self) -> &str {
        &self.unit_of_measurement
    }
    pub fn clear_unit_of_measurement(&mut self) {
        self.unit_of_measurement.clear();
    }

    // Param is passed by value, moved
    pub fn set_unit_of_measurement(&mut self, v: ::std::string::String) {
        self.unit_of_measurement = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit_of_measurement(&mut self) -> &mut ::std::string::String {
        &mut self.unit_of_measurement
    }

    // Take field
    pub fn take_unit_of_measurement(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unit_of_measurement, ::std::string::String::new())
    }

    // int32 accuracy_decimals = 7;


    pub fn get_accuracy_decimals(&self) -> i32 {
        self.accuracy_decimals
    }
    pub fn clear_accuracy_decimals(&mut self) {
        self.accuracy_decimals = 0;
    }

    // Param is passed by value, moved
    pub fn set_accuracy_decimals(&mut self, v: i32) {
        self.accuracy_decimals = v;
    }

    // bool force_update = 8;


    pub fn get_force_update(&self) -> bool {
        self.force_update
    }
    pub fn clear_force_update(&mut self) {
        self.force_update = false;
    }

    // Param is passed by value, moved
    pub fn set_force_update(&mut self, v: bool) {
        self.force_update = v;
    }

    // string device_class = 9;


    pub fn get_device_class(&self) -> &str {
        &self.device_class
    }
    pub fn clear_device_class(&mut self) {
        self.device_class.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_class(&mut self, v: ::std::string::String) {
        self.device_class = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_class(&mut self) -> &mut ::std::string::String {
        &mut self.device_class
    }

    // Take field
    pub fn take_device_class(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_class, ::std::string::String::new())
    }

    // .SensorStateClass state_class = 10;


    pub fn get_state_class(&self) -> SensorStateClass {
        self.state_class
    }
    pub fn clear_state_class(&mut self) {
        self.state_class = SensorStateClass::STATE_CLASS_NONE;
    }

    // Param is passed by value, moved
    pub fn set_state_class(&mut self, v: SensorStateClass) {
        self.state_class = v;
    }

    // .SensorLastResetType last_reset_type = 11;


    pub fn get_last_reset_type(&self) -> SensorLastResetType {
        self.last_reset_type
    }
    pub fn clear_last_reset_type(&mut self) {
        self.last_reset_type = SensorLastResetType::LAST_RESET_NONE;
    }

    // Param is passed by value, moved
    pub fn set_last_reset_type(&mut self, v: SensorLastResetType) {
        self.last_reset_type = v;
    }

    // bool disabled_by_default = 12;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }
}

impl ::protobuf::Message for ListEntitiesSensorResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.icon)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unit_of_measurement)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.accuracy_decimals = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force_update = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_class)?;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state_class, 10, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.last_reset_type, 11, &mut self.unknown_fields)?
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if !self.unit_of_measurement.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.unit_of_measurement);
        }
        if self.accuracy_decimals != 0 {
            my_size += ::protobuf::rt::value_size(7, self.accuracy_decimals, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.force_update != false {
            my_size += 2;
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.device_class);
        }
        if self.state_class != SensorStateClass::STATE_CLASS_NONE {
            my_size += ::protobuf::rt::enum_size(10, self.state_class);
        }
        if self.last_reset_type != SensorLastResetType::LAST_RESET_NONE {
            my_size += ::protobuf::rt::enum_size(11, self.last_reset_type);
        }
        if self.disabled_by_default != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if !self.unit_of_measurement.is_empty() {
            os.write_string(6, &self.unit_of_measurement)?;
        }
        if self.accuracy_decimals != 0 {
            os.write_int32(7, self.accuracy_decimals)?;
        }
        if self.force_update != false {
            os.write_bool(8, self.force_update)?;
        }
        if !self.device_class.is_empty() {
            os.write_string(9, &self.device_class)?;
        }
        if self.state_class != SensorStateClass::STATE_CLASS_NONE {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&self.state_class))?;
        }
        if self.last_reset_type != SensorLastResetType::LAST_RESET_NONE {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&self.last_reset_type))?;
        }
        if self.disabled_by_default != false {
            os.write_bool(12, self.disabled_by_default)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesSensorResponse {
        ListEntitiesSensorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesSensorResponse| { &m.object_id },
                |m: &mut ListEntitiesSensorResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesSensorResponse| { &m.key },
                |m: &mut ListEntitiesSensorResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesSensorResponse| { &m.name },
                |m: &mut ListEntitiesSensorResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesSensorResponse| { &m.unique_id },
                |m: &mut ListEntitiesSensorResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &ListEntitiesSensorResponse| { &m.icon },
                |m: &mut ListEntitiesSensorResponse| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unit_of_measurement",
                |m: &ListEntitiesSensorResponse| { &m.unit_of_measurement },
                |m: &mut ListEntitiesSensorResponse| { &mut m.unit_of_measurement },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "accuracy_decimals",
                |m: &ListEntitiesSensorResponse| { &m.accuracy_decimals },
                |m: &mut ListEntitiesSensorResponse| { &mut m.accuracy_decimals },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "force_update",
                |m: &ListEntitiesSensorResponse| { &m.force_update },
                |m: &mut ListEntitiesSensorResponse| { &mut m.force_update },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_class",
                |m: &ListEntitiesSensorResponse| { &m.device_class },
                |m: &mut ListEntitiesSensorResponse| { &mut m.device_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SensorStateClass>>(
                "state_class",
                |m: &ListEntitiesSensorResponse| { &m.state_class },
                |m: &mut ListEntitiesSensorResponse| { &mut m.state_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SensorLastResetType>>(
                "last_reset_type",
                |m: &ListEntitiesSensorResponse| { &m.last_reset_type },
                |m: &mut ListEntitiesSensorResponse| { &mut m.last_reset_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesSensorResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesSensorResponse| { &mut m.disabled_by_default },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesSensorResponse>(
                "ListEntitiesSensorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesSensorResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesSensorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesSensorResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesSensorResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.unit_of_measurement.clear();
        self.accuracy_decimals = 0;
        self.force_update = false;
        self.device_class.clear();
        self.state_class = SensorStateClass::STATE_CLASS_NONE;
        self.last_reset_type = SensorLastResetType::LAST_RESET_NONE;
        self.disabled_by_default = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesSensorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesSensorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SensorStateResponse {
    // message fields
    pub key: u32,
    pub state: f32,
    pub missing_state: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SensorStateResponse {
    fn default() -> &'a SensorStateResponse {
        <SensorStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SensorStateResponse {
    pub fn new() -> SensorStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // float state = 2;


    pub fn get_state(&self) -> f32 {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = 0.;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: f32) {
        self.state = v;
    }

    // bool missing_state = 3;


    pub fn get_missing_state(&self) -> bool {
        self.missing_state
    }
    pub fn clear_missing_state(&mut self) {
        self.missing_state = false;
    }

    // Param is passed by value, moved
    pub fn set_missing_state(&mut self, v: bool) {
        self.missing_state = v;
    }
}

impl ::protobuf::Message for SensorStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.state = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.missing_state = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.state != 0. {
            my_size += 5;
        }
        if self.missing_state != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != 0. {
            os.write_float(2, self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SensorStateResponse {
        SensorStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &SensorStateResponse| { &m.key },
                |m: &mut SensorStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "state",
                |m: &SensorStateResponse| { &m.state },
                |m: &mut SensorStateResponse| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "missing_state",
                |m: &SensorStateResponse| { &m.missing_state },
                |m: &mut SensorStateResponse| { &mut m.missing_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SensorStateResponse>(
                "SensorStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SensorStateResponse {
        static instance: ::protobuf::rt::LazyV2<SensorStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SensorStateResponse::new)
    }
}

impl ::protobuf::Clear for SensorStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.state = 0.;
        self.missing_state = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SensorStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SensorStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesSwitchResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub icon: ::std::string::String,
    pub assumed_state: bool,
    pub disabled_by_default: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesSwitchResponse {
    fn default() -> &'a ListEntitiesSwitchResponse {
        <ListEntitiesSwitchResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesSwitchResponse {
    pub fn new() -> ListEntitiesSwitchResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // string icon = 5;


    pub fn get_icon(&self) -> &str {
        &self.icon
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        &mut self.icon
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.icon, ::std::string::String::new())
    }

    // bool assumed_state = 6;


    pub fn get_assumed_state(&self) -> bool {
        self.assumed_state
    }
    pub fn clear_assumed_state(&mut self) {
        self.assumed_state = false;
    }

    // Param is passed by value, moved
    pub fn set_assumed_state(&mut self, v: bool) {
        self.assumed_state = v;
    }

    // bool disabled_by_default = 7;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }
}

impl ::protobuf::Message for ListEntitiesSwitchResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.icon)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.assumed_state = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.assumed_state != false {
            my_size += 2;
        }
        if self.disabled_by_default != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.assumed_state != false {
            os.write_bool(6, self.assumed_state)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(7, self.disabled_by_default)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesSwitchResponse {
        ListEntitiesSwitchResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesSwitchResponse| { &m.object_id },
                |m: &mut ListEntitiesSwitchResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesSwitchResponse| { &m.key },
                |m: &mut ListEntitiesSwitchResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesSwitchResponse| { &m.name },
                |m: &mut ListEntitiesSwitchResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesSwitchResponse| { &m.unique_id },
                |m: &mut ListEntitiesSwitchResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &ListEntitiesSwitchResponse| { &m.icon },
                |m: &mut ListEntitiesSwitchResponse| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "assumed_state",
                |m: &ListEntitiesSwitchResponse| { &m.assumed_state },
                |m: &mut ListEntitiesSwitchResponse| { &mut m.assumed_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesSwitchResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesSwitchResponse| { &mut m.disabled_by_default },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesSwitchResponse>(
                "ListEntitiesSwitchResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesSwitchResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesSwitchResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesSwitchResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesSwitchResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.assumed_state = false;
        self.disabled_by_default = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesSwitchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesSwitchResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SwitchStateResponse {
    // message fields
    pub key: u32,
    pub state: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SwitchStateResponse {
    fn default() -> &'a SwitchStateResponse {
        <SwitchStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SwitchStateResponse {
    pub fn new() -> SwitchStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bool state = 2;


    pub fn get_state(&self) -> bool {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = false;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = v;
    }
}

impl ::protobuf::Message for SwitchStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.state = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.state != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SwitchStateResponse {
        SwitchStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &SwitchStateResponse| { &m.key },
                |m: &mut SwitchStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "state",
                |m: &SwitchStateResponse| { &m.state },
                |m: &mut SwitchStateResponse| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SwitchStateResponse>(
                "SwitchStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SwitchStateResponse {
        static instance: ::protobuf::rt::LazyV2<SwitchStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SwitchStateResponse::new)
    }
}

impl ::protobuf::Clear for SwitchStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SwitchStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SwitchCommandRequest {
    // message fields
    pub key: u32,
    pub state: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SwitchCommandRequest {
    fn default() -> &'a SwitchCommandRequest {
        <SwitchCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl SwitchCommandRequest {
    pub fn new() -> SwitchCommandRequest {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bool state = 2;


    pub fn get_state(&self) -> bool {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = false;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = v;
    }
}

impl ::protobuf::Message for SwitchCommandRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.state = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.state != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SwitchCommandRequest {
        SwitchCommandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &SwitchCommandRequest| { &m.key },
                |m: &mut SwitchCommandRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "state",
                |m: &SwitchCommandRequest| { &m.state },
                |m: &mut SwitchCommandRequest| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SwitchCommandRequest>(
                "SwitchCommandRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SwitchCommandRequest {
        static instance: ::protobuf::rt::LazyV2<SwitchCommandRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SwitchCommandRequest::new)
    }
}

impl ::protobuf::Clear for SwitchCommandRequest {
    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SwitchCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchCommandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesTextSensorResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub icon: ::std::string::String,
    pub disabled_by_default: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesTextSensorResponse {
    fn default() -> &'a ListEntitiesTextSensorResponse {
        <ListEntitiesTextSensorResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesTextSensorResponse {
    pub fn new() -> ListEntitiesTextSensorResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // string icon = 5;


    pub fn get_icon(&self) -> &str {
        &self.icon
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        &mut self.icon
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.icon, ::std::string::String::new())
    }

    // bool disabled_by_default = 6;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }
}

impl ::protobuf::Message for ListEntitiesTextSensorResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.icon)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesTextSensorResponse {
        ListEntitiesTextSensorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesTextSensorResponse| { &m.object_id },
                |m: &mut ListEntitiesTextSensorResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesTextSensorResponse| { &m.key },
                |m: &mut ListEntitiesTextSensorResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesTextSensorResponse| { &m.name },
                |m: &mut ListEntitiesTextSensorResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesTextSensorResponse| { &m.unique_id },
                |m: &mut ListEntitiesTextSensorResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &ListEntitiesTextSensorResponse| { &m.icon },
                |m: &mut ListEntitiesTextSensorResponse| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesTextSensorResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesTextSensorResponse| { &mut m.disabled_by_default },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesTextSensorResponse>(
                "ListEntitiesTextSensorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesTextSensorResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesTextSensorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesTextSensorResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesTextSensorResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesTextSensorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesTextSensorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TextSensorStateResponse {
    // message fields
    pub key: u32,
    pub state: ::std::string::String,
    pub missing_state: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TextSensorStateResponse {
    fn default() -> &'a TextSensorStateResponse {
        <TextSensorStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl TextSensorStateResponse {
    pub fn new() -> TextSensorStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string state = 2;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // bool missing_state = 3;


    pub fn get_missing_state(&self) -> bool {
        self.missing_state
    }
    pub fn clear_missing_state(&mut self) {
        self.missing_state = false;
    }

    // Param is passed by value, moved
    pub fn set_missing_state(&mut self, v: bool) {
        self.missing_state = v;
    }
}

impl ::protobuf::Message for TextSensorStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.missing_state = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state);
        }
        if self.missing_state != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if !self.state.is_empty() {
            os.write_string(2, &self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TextSensorStateResponse {
        TextSensorStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &TextSensorStateResponse| { &m.key },
                |m: &mut TextSensorStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state",
                |m: &TextSensorStateResponse| { &m.state },
                |m: &mut TextSensorStateResponse| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "missing_state",
                |m: &TextSensorStateResponse| { &m.missing_state },
                |m: &mut TextSensorStateResponse| { &mut m.missing_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TextSensorStateResponse>(
                "TextSensorStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TextSensorStateResponse {
        static instance: ::protobuf::rt::LazyV2<TextSensorStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TextSensorStateResponse::new)
    }
}

impl ::protobuf::Clear for TextSensorStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.state.clear();
        self.missing_state = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TextSensorStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TextSensorStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeLogsRequest {
    // message fields
    pub level: LogLevel,
    pub dump_config: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeLogsRequest {
    fn default() -> &'a SubscribeLogsRequest {
        <SubscribeLogsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeLogsRequest {
    pub fn new() -> SubscribeLogsRequest {
        ::std::default::Default::default()
    }

    // .LogLevel level = 1;


    pub fn get_level(&self) -> LogLevel {
        self.level
    }
    pub fn clear_level(&mut self) {
        self.level = LogLevel::LOG_LEVEL_NONE;
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: LogLevel) {
        self.level = v;
    }

    // bool dump_config = 2;


    pub fn get_dump_config(&self) -> bool {
        self.dump_config
    }
    pub fn clear_dump_config(&mut self) {
        self.dump_config = false;
    }

    // Param is passed by value, moved
    pub fn set_dump_config(&mut self, v: bool) {
        self.dump_config = v;
    }
}

impl ::protobuf::Message for SubscribeLogsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.level, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dump_config = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.level != LogLevel::LOG_LEVEL_NONE {
            my_size += ::protobuf::rt::enum_size(1, self.level);
        }
        if self.dump_config != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.level != LogLevel::LOG_LEVEL_NONE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.level))?;
        }
        if self.dump_config != false {
            os.write_bool(2, self.dump_config)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeLogsRequest {
        SubscribeLogsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LogLevel>>(
                "level",
                |m: &SubscribeLogsRequest| { &m.level },
                |m: &mut SubscribeLogsRequest| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "dump_config",
                |m: &SubscribeLogsRequest| { &m.dump_config },
                |m: &mut SubscribeLogsRequest| { &mut m.dump_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscribeLogsRequest>(
                "SubscribeLogsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscribeLogsRequest {
        static instance: ::protobuf::rt::LazyV2<SubscribeLogsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscribeLogsRequest::new)
    }
}

impl ::protobuf::Clear for SubscribeLogsRequest {
    fn clear(&mut self) {
        self.level = LogLevel::LOG_LEVEL_NONE;
        self.dump_config = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeLogsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeLogsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeLogsResponse {
    // message fields
    pub level: LogLevel,
    pub tag: ::std::string::String,
    pub message: ::std::string::String,
    pub send_failed: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeLogsResponse {
    fn default() -> &'a SubscribeLogsResponse {
        <SubscribeLogsResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeLogsResponse {
    pub fn new() -> SubscribeLogsResponse {
        ::std::default::Default::default()
    }

    // .LogLevel level = 1;


    pub fn get_level(&self) -> LogLevel {
        self.level
    }
    pub fn clear_level(&mut self) {
        self.level = LogLevel::LOG_LEVEL_NONE;
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: LogLevel) {
        self.level = v;
    }

    // string tag = 2;


    pub fn get_tag(&self) -> &str {
        &self.tag
    }
    pub fn clear_tag(&mut self) {
        self.tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::string::String) {
        self.tag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::string::String {
        &mut self.tag
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tag, ::std::string::String::new())
    }

    // string message = 3;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // bool send_failed = 4;


    pub fn get_send_failed(&self) -> bool {
        self.send_failed
    }
    pub fn clear_send_failed(&mut self) {
        self.send_failed = false;
    }

    // Param is passed by value, moved
    pub fn set_send_failed(&mut self, v: bool) {
        self.send_failed = v;
    }
}

impl ::protobuf::Message for SubscribeLogsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.level, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tag)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.send_failed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.level != LogLevel::LOG_LEVEL_NONE {
            my_size += ::protobuf::rt::enum_size(1, self.level);
        }
        if !self.tag.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.tag);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.message);
        }
        if self.send_failed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.level != LogLevel::LOG_LEVEL_NONE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.level))?;
        }
        if !self.tag.is_empty() {
            os.write_string(2, &self.tag)?;
        }
        if !self.message.is_empty() {
            os.write_string(3, &self.message)?;
        }
        if self.send_failed != false {
            os.write_bool(4, self.send_failed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeLogsResponse {
        SubscribeLogsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LogLevel>>(
                "level",
                |m: &SubscribeLogsResponse| { &m.level },
                |m: &mut SubscribeLogsResponse| { &mut m.level },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tag",
                |m: &SubscribeLogsResponse| { &m.tag },
                |m: &mut SubscribeLogsResponse| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &SubscribeLogsResponse| { &m.message },
                |m: &mut SubscribeLogsResponse| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "send_failed",
                |m: &SubscribeLogsResponse| { &m.send_failed },
                |m: &mut SubscribeLogsResponse| { &mut m.send_failed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscribeLogsResponse>(
                "SubscribeLogsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscribeLogsResponse {
        static instance: ::protobuf::rt::LazyV2<SubscribeLogsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscribeLogsResponse::new)
    }
}

impl ::protobuf::Clear for SubscribeLogsResponse {
    fn clear(&mut self) {
        self.level = LogLevel::LOG_LEVEL_NONE;
        self.tag.clear();
        self.message.clear();
        self.send_failed = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeLogsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeLogsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeHomeassistantServicesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeHomeassistantServicesRequest {
    fn default() -> &'a SubscribeHomeassistantServicesRequest {
        <SubscribeHomeassistantServicesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeHomeassistantServicesRequest {
    pub fn new() -> SubscribeHomeassistantServicesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeHomeassistantServicesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeHomeassistantServicesRequest {
        SubscribeHomeassistantServicesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscribeHomeassistantServicesRequest>(
                "SubscribeHomeassistantServicesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscribeHomeassistantServicesRequest {
        static instance: ::protobuf::rt::LazyV2<SubscribeHomeassistantServicesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscribeHomeassistantServicesRequest::new)
    }
}

impl ::protobuf::Clear for SubscribeHomeassistantServicesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeHomeassistantServicesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeHomeassistantServicesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HomeassistantServiceMap {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HomeassistantServiceMap {
    fn default() -> &'a HomeassistantServiceMap {
        <HomeassistantServiceMap as ::protobuf::Message>::default_instance()
    }
}

impl HomeassistantServiceMap {
    pub fn new() -> HomeassistantServiceMap {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HomeassistantServiceMap {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HomeassistantServiceMap {
        HomeassistantServiceMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &HomeassistantServiceMap| { &m.key },
                |m: &mut HomeassistantServiceMap| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &HomeassistantServiceMap| { &m.value },
                |m: &mut HomeassistantServiceMap| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HomeassistantServiceMap>(
                "HomeassistantServiceMap",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HomeassistantServiceMap {
        static instance: ::protobuf::rt::LazyV2<HomeassistantServiceMap> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HomeassistantServiceMap::new)
    }
}

impl ::protobuf::Clear for HomeassistantServiceMap {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HomeassistantServiceMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HomeassistantServiceMap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HomeassistantServiceResponse {
    // message fields
    pub service: ::std::string::String,
    pub data: ::protobuf::RepeatedField<HomeassistantServiceMap>,
    pub data_template: ::protobuf::RepeatedField<HomeassistantServiceMap>,
    pub variables: ::protobuf::RepeatedField<HomeassistantServiceMap>,
    pub is_event: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HomeassistantServiceResponse {
    fn default() -> &'a HomeassistantServiceResponse {
        <HomeassistantServiceResponse as ::protobuf::Message>::default_instance()
    }
}

impl HomeassistantServiceResponse {
    pub fn new() -> HomeassistantServiceResponse {
        ::std::default::Default::default()
    }

    // string service = 1;


    pub fn get_service(&self) -> &str {
        &self.service
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    // repeated .HomeassistantServiceMap data = 2;


    pub fn get_data(&self) -> &[HomeassistantServiceMap] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<HomeassistantServiceMap>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<HomeassistantServiceMap> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<HomeassistantServiceMap> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }

    // repeated .HomeassistantServiceMap data_template = 3;


    pub fn get_data_template(&self) -> &[HomeassistantServiceMap] {
        &self.data_template
    }
    pub fn clear_data_template(&mut self) {
        self.data_template.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_template(&mut self, v: ::protobuf::RepeatedField<HomeassistantServiceMap>) {
        self.data_template = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data_template(&mut self) -> &mut ::protobuf::RepeatedField<HomeassistantServiceMap> {
        &mut self.data_template
    }

    // Take field
    pub fn take_data_template(&mut self) -> ::protobuf::RepeatedField<HomeassistantServiceMap> {
        ::std::mem::replace(&mut self.data_template, ::protobuf::RepeatedField::new())
    }

    // repeated .HomeassistantServiceMap variables = 4;


    pub fn get_variables(&self) -> &[HomeassistantServiceMap] {
        &self.variables
    }
    pub fn clear_variables(&mut self) {
        self.variables.clear();
    }

    // Param is passed by value, moved
    pub fn set_variables(&mut self, v: ::protobuf::RepeatedField<HomeassistantServiceMap>) {
        self.variables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_variables(&mut self) -> &mut ::protobuf::RepeatedField<HomeassistantServiceMap> {
        &mut self.variables
    }

    // Take field
    pub fn take_variables(&mut self) -> ::protobuf::RepeatedField<HomeassistantServiceMap> {
        ::std::mem::replace(&mut self.variables, ::protobuf::RepeatedField::new())
    }

    // bool is_event = 5;


    pub fn get_is_event(&self) -> bool {
        self.is_event
    }
    pub fn clear_is_event(&mut self) {
        self.is_event = false;
    }

    // Param is passed by value, moved
    pub fn set_is_event(&mut self, v: bool) {
        self.is_event = v;
    }
}

impl ::protobuf::Message for HomeassistantServiceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data_template {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.variables {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data_template)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.variables)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_event = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.data_template {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.variables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.is_event != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service.is_empty() {
            os.write_string(1, &self.service)?;
        }
        for v in &self.data {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.data_template {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.variables {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.is_event != false {
            os.write_bool(5, self.is_event)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HomeassistantServiceResponse {
        HomeassistantServiceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service",
                |m: &HomeassistantServiceResponse| { &m.service },
                |m: &mut HomeassistantServiceResponse| { &mut m.service },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HomeassistantServiceMap>>(
                "data",
                |m: &HomeassistantServiceResponse| { &m.data },
                |m: &mut HomeassistantServiceResponse| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HomeassistantServiceMap>>(
                "data_template",
                |m: &HomeassistantServiceResponse| { &m.data_template },
                |m: &mut HomeassistantServiceResponse| { &mut m.data_template },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HomeassistantServiceMap>>(
                "variables",
                |m: &HomeassistantServiceResponse| { &m.variables },
                |m: &mut HomeassistantServiceResponse| { &mut m.variables },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_event",
                |m: &HomeassistantServiceResponse| { &m.is_event },
                |m: &mut HomeassistantServiceResponse| { &mut m.is_event },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HomeassistantServiceResponse>(
                "HomeassistantServiceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HomeassistantServiceResponse {
        static instance: ::protobuf::rt::LazyV2<HomeassistantServiceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HomeassistantServiceResponse::new)
    }
}

impl ::protobuf::Clear for HomeassistantServiceResponse {
    fn clear(&mut self) {
        self.service.clear();
        self.data.clear();
        self.data_template.clear();
        self.variables.clear();
        self.is_event = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HomeassistantServiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HomeassistantServiceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeHomeAssistantStatesRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeHomeAssistantStatesRequest {
    fn default() -> &'a SubscribeHomeAssistantStatesRequest {
        <SubscribeHomeAssistantStatesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeHomeAssistantStatesRequest {
    pub fn new() -> SubscribeHomeAssistantStatesRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeHomeAssistantStatesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeHomeAssistantStatesRequest {
        SubscribeHomeAssistantStatesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscribeHomeAssistantStatesRequest>(
                "SubscribeHomeAssistantStatesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscribeHomeAssistantStatesRequest {
        static instance: ::protobuf::rt::LazyV2<SubscribeHomeAssistantStatesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscribeHomeAssistantStatesRequest::new)
    }
}

impl ::protobuf::Clear for SubscribeHomeAssistantStatesRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeHomeAssistantStatesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeHomeAssistantStatesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeHomeAssistantStateResponse {
    // message fields
    pub entity_id: ::std::string::String,
    pub attribute: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeHomeAssistantStateResponse {
    fn default() -> &'a SubscribeHomeAssistantStateResponse {
        <SubscribeHomeAssistantStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeHomeAssistantStateResponse {
    pub fn new() -> SubscribeHomeAssistantStateResponse {
        ::std::default::Default::default()
    }

    // string entity_id = 1;


    pub fn get_entity_id(&self) -> &str {
        &self.entity_id
    }
    pub fn clear_entity_id(&mut self) {
        self.entity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity_id(&mut self, v: ::std::string::String) {
        self.entity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_id(&mut self) -> &mut ::std::string::String {
        &mut self.entity_id
    }

    // Take field
    pub fn take_entity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity_id, ::std::string::String::new())
    }

    // string attribute = 2;


    pub fn get_attribute(&self) -> &str {
        &self.attribute
    }
    pub fn clear_attribute(&mut self) {
        self.attribute.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute(&mut self, v: ::std::string::String) {
        self.attribute = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attribute(&mut self) -> &mut ::std::string::String {
        &mut self.attribute
    }

    // Take field
    pub fn take_attribute(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.attribute, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SubscribeHomeAssistantStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.attribute)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.entity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entity_id);
        }
        if !self.attribute.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.attribute);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.entity_id.is_empty() {
            os.write_string(1, &self.entity_id)?;
        }
        if !self.attribute.is_empty() {
            os.write_string(2, &self.attribute)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeHomeAssistantStateResponse {
        SubscribeHomeAssistantStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity_id",
                |m: &SubscribeHomeAssistantStateResponse| { &m.entity_id },
                |m: &mut SubscribeHomeAssistantStateResponse| { &mut m.entity_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "attribute",
                |m: &SubscribeHomeAssistantStateResponse| { &m.attribute },
                |m: &mut SubscribeHomeAssistantStateResponse| { &mut m.attribute },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubscribeHomeAssistantStateResponse>(
                "SubscribeHomeAssistantStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubscribeHomeAssistantStateResponse {
        static instance: ::protobuf::rt::LazyV2<SubscribeHomeAssistantStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubscribeHomeAssistantStateResponse::new)
    }
}

impl ::protobuf::Clear for SubscribeHomeAssistantStateResponse {
    fn clear(&mut self) {
        self.entity_id.clear();
        self.attribute.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeHomeAssistantStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeHomeAssistantStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HomeAssistantStateResponse {
    // message fields
    pub entity_id: ::std::string::String,
    pub state: ::std::string::String,
    pub attribute: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HomeAssistantStateResponse {
    fn default() -> &'a HomeAssistantStateResponse {
        <HomeAssistantStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl HomeAssistantStateResponse {
    pub fn new() -> HomeAssistantStateResponse {
        ::std::default::Default::default()
    }

    // string entity_id = 1;


    pub fn get_entity_id(&self) -> &str {
        &self.entity_id
    }
    pub fn clear_entity_id(&mut self) {
        self.entity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity_id(&mut self, v: ::std::string::String) {
        self.entity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_id(&mut self) -> &mut ::std::string::String {
        &mut self.entity_id
    }

    // Take field
    pub fn take_entity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity_id, ::std::string::String::new())
    }

    // string state = 2;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // string attribute = 3;


    pub fn get_attribute(&self) -> &str {
        &self.attribute
    }
    pub fn clear_attribute(&mut self) {
        self.attribute.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute(&mut self, v: ::std::string::String) {
        self.attribute = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attribute(&mut self) -> &mut ::std::string::String {
        &mut self.attribute
    }

    // Take field
    pub fn take_attribute(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.attribute, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HomeAssistantStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.attribute)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.entity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entity_id);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state);
        }
        if !self.attribute.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.attribute);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.entity_id.is_empty() {
            os.write_string(1, &self.entity_id)?;
        }
        if !self.state.is_empty() {
            os.write_string(2, &self.state)?;
        }
        if !self.attribute.is_empty() {
            os.write_string(3, &self.attribute)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HomeAssistantStateResponse {
        HomeAssistantStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entity_id",
                |m: &HomeAssistantStateResponse| { &m.entity_id },
                |m: &mut HomeAssistantStateResponse| { &mut m.entity_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state",
                |m: &HomeAssistantStateResponse| { &m.state },
                |m: &mut HomeAssistantStateResponse| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "attribute",
                |m: &HomeAssistantStateResponse| { &m.attribute },
                |m: &mut HomeAssistantStateResponse| { &mut m.attribute },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HomeAssistantStateResponse>(
                "HomeAssistantStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HomeAssistantStateResponse {
        static instance: ::protobuf::rt::LazyV2<HomeAssistantStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HomeAssistantStateResponse::new)
    }
}

impl ::protobuf::Clear for HomeAssistantStateResponse {
    fn clear(&mut self) {
        self.entity_id.clear();
        self.state.clear();
        self.attribute.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HomeAssistantStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HomeAssistantStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTimeRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTimeRequest {
    fn default() -> &'a GetTimeRequest {
        <GetTimeRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTimeRequest {
    pub fn new() -> GetTimeRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetTimeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTimeRequest {
        GetTimeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetTimeRequest>(
                "GetTimeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetTimeRequest {
        static instance: ::protobuf::rt::LazyV2<GetTimeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTimeRequest::new)
    }
}

impl ::protobuf::Clear for GetTimeRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTimeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTimeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTimeResponse {
    // message fields
    pub epoch_seconds: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTimeResponse {
    fn default() -> &'a GetTimeResponse {
        <GetTimeResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetTimeResponse {
    pub fn new() -> GetTimeResponse {
        ::std::default::Default::default()
    }

    // fixed32 epoch_seconds = 1;


    pub fn get_epoch_seconds(&self) -> u32 {
        self.epoch_seconds
    }
    pub fn clear_epoch_seconds(&mut self) {
        self.epoch_seconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_epoch_seconds(&mut self, v: u32) {
        self.epoch_seconds = v;
    }
}

impl ::protobuf::Message for GetTimeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.epoch_seconds = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.epoch_seconds != 0 {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.epoch_seconds != 0 {
            os.write_fixed32(1, self.epoch_seconds)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTimeResponse {
        GetTimeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "epoch_seconds",
                |m: &GetTimeResponse| { &m.epoch_seconds },
                |m: &mut GetTimeResponse| { &mut m.epoch_seconds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetTimeResponse>(
                "GetTimeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetTimeResponse {
        static instance: ::protobuf::rt::LazyV2<GetTimeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTimeResponse::new)
    }
}

impl ::protobuf::Clear for GetTimeResponse {
    fn clear(&mut self) {
        self.epoch_seconds = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTimeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTimeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesServicesArgument {
    // message fields
    pub name: ::std::string::String,
    pub field_type: ServiceArgType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesServicesArgument {
    fn default() -> &'a ListEntitiesServicesArgument {
        <ListEntitiesServicesArgument as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesServicesArgument {
    pub fn new() -> ListEntitiesServicesArgument {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .ServiceArgType type = 2;


    pub fn get_field_type(&self) -> ServiceArgType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ServiceArgType::SERVICE_ARG_TYPE_BOOL;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ServiceArgType) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for ListEntitiesServicesArgument {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.field_type != ServiceArgType::SERVICE_ARG_TYPE_BOOL {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.field_type != ServiceArgType::SERVICE_ARG_TYPE_BOOL {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesServicesArgument {
        ListEntitiesServicesArgument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesServicesArgument| { &m.name },
                |m: &mut ListEntitiesServicesArgument| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ServiceArgType>>(
                "type",
                |m: &ListEntitiesServicesArgument| { &m.field_type },
                |m: &mut ListEntitiesServicesArgument| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesServicesArgument>(
                "ListEntitiesServicesArgument",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesServicesArgument {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesServicesArgument> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesServicesArgument::new)
    }
}

impl ::protobuf::Clear for ListEntitiesServicesArgument {
    fn clear(&mut self) {
        self.name.clear();
        self.field_type = ServiceArgType::SERVICE_ARG_TYPE_BOOL;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesServicesArgument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesServicesArgument {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesServicesResponse {
    // message fields
    pub name: ::std::string::String,
    pub key: u32,
    pub args: ::protobuf::RepeatedField<ListEntitiesServicesArgument>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesServicesResponse {
    fn default() -> &'a ListEntitiesServicesResponse {
        <ListEntitiesServicesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesServicesResponse {
    pub fn new() -> ListEntitiesServicesResponse {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // repeated .ListEntitiesServicesArgument args = 3;


    pub fn get_args(&self) -> &[ListEntitiesServicesArgument] {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<ListEntitiesServicesArgument>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<ListEntitiesServicesArgument> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<ListEntitiesServicesArgument> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListEntitiesServicesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.args {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.args)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.key != 0 {
            my_size += 5;
        }
        for value in &self.args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        for v in &self.args {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesServicesResponse {
        ListEntitiesServicesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesServicesResponse| { &m.name },
                |m: &mut ListEntitiesServicesResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesServicesResponse| { &m.key },
                |m: &mut ListEntitiesServicesResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ListEntitiesServicesArgument>>(
                "args",
                |m: &ListEntitiesServicesResponse| { &m.args },
                |m: &mut ListEntitiesServicesResponse| { &mut m.args },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesServicesResponse>(
                "ListEntitiesServicesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesServicesResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesServicesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesServicesResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesServicesResponse {
    fn clear(&mut self) {
        self.name.clear();
        self.key = 0;
        self.args.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesServicesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesServicesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteServiceArgument {
    // message fields
    pub bool_: bool,
    pub legacy_int: i32,
    pub float_: f32,
    pub string_: ::std::string::String,
    pub int_: i32,
    pub bool_array: ::std::vec::Vec<bool>,
    pub int_array: ::std::vec::Vec<i32>,
    pub float_array: ::std::vec::Vec<f32>,
    pub string_array: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteServiceArgument {
    fn default() -> &'a ExecuteServiceArgument {
        <ExecuteServiceArgument as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteServiceArgument {
    pub fn new() -> ExecuteServiceArgument {
        ::std::default::Default::default()
    }

    // bool bool_ = 1;


    pub fn get_bool_(&self) -> bool {
        self.bool_
    }
    pub fn clear_bool_(&mut self) {
        self.bool_ = false;
    }

    // Param is passed by value, moved
    pub fn set_bool_(&mut self, v: bool) {
        self.bool_ = v;
    }

    // int32 legacy_int = 2;


    pub fn get_legacy_int(&self) -> i32 {
        self.legacy_int
    }
    pub fn clear_legacy_int(&mut self) {
        self.legacy_int = 0;
    }

    // Param is passed by value, moved
    pub fn set_legacy_int(&mut self, v: i32) {
        self.legacy_int = v;
    }

    // float float_ = 3;


    pub fn get_float_(&self) -> f32 {
        self.float_
    }
    pub fn clear_float_(&mut self) {
        self.float_ = 0.;
    }

    // Param is passed by value, moved
    pub fn set_float_(&mut self, v: f32) {
        self.float_ = v;
    }

    // string string_ = 4;


    pub fn get_string_(&self) -> &str {
        &self.string_
    }
    pub fn clear_string_(&mut self) {
        self.string_.clear();
    }

    // Param is passed by value, moved
    pub fn set_string_(&mut self, v: ::std::string::String) {
        self.string_ = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_(&mut self) -> &mut ::std::string::String {
        &mut self.string_
    }

    // Take field
    pub fn take_string_(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.string_, ::std::string::String::new())
    }

    // sint32 int_ = 5;


    pub fn get_int_(&self) -> i32 {
        self.int_
    }
    pub fn clear_int_(&mut self) {
        self.int_ = 0;
    }

    // Param is passed by value, moved
    pub fn set_int_(&mut self, v: i32) {
        self.int_ = v;
    }

    // repeated bool bool_array = 6;


    pub fn get_bool_array(&self) -> &[bool] {
        &self.bool_array
    }
    pub fn clear_bool_array(&mut self) {
        self.bool_array.clear();
    }

    // Param is passed by value, moved
    pub fn set_bool_array(&mut self, v: ::std::vec::Vec<bool>) {
        self.bool_array = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bool_array(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.bool_array
    }

    // Take field
    pub fn take_bool_array(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.bool_array, ::std::vec::Vec::new())
    }

    // repeated sint32 int_array = 7;


    pub fn get_int_array(&self) -> &[i32] {
        &self.int_array
    }
    pub fn clear_int_array(&mut self) {
        self.int_array.clear();
    }

    // Param is passed by value, moved
    pub fn set_int_array(&mut self, v: ::std::vec::Vec<i32>) {
        self.int_array = v;
    }

    // Mutable pointer to the field.
    pub fn mut_int_array(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.int_array
    }

    // Take field
    pub fn take_int_array(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.int_array, ::std::vec::Vec::new())
    }

    // repeated float float_array = 8;


    pub fn get_float_array(&self) -> &[f32] {
        &self.float_array
    }
    pub fn clear_float_array(&mut self) {
        self.float_array.clear();
    }

    // Param is passed by value, moved
    pub fn set_float_array(&mut self, v: ::std::vec::Vec<f32>) {
        self.float_array = v;
    }

    // Mutable pointer to the field.
    pub fn mut_float_array(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.float_array
    }

    // Take field
    pub fn take_float_array(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.float_array, ::std::vec::Vec::new())
    }

    // repeated string string_array = 9;


    pub fn get_string_array(&self) -> &[::std::string::String] {
        &self.string_array
    }
    pub fn clear_string_array(&mut self) {
        self.string_array.clear();
    }

    // Param is passed by value, moved
    pub fn set_string_array(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.string_array = v;
    }

    // Mutable pointer to the field.
    pub fn mut_string_array(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.string_array
    }

    // Take field
    pub fn take_string_array(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.string_array, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExecuteServiceArgument {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bool_ = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.legacy_int = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.float_ = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.string_)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.int_ = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.bool_array)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_sint32_into(wire_type, is, &mut self.int_array)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.float_array)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.string_array)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.bool_ != false {
            my_size += 2;
        }
        if self.legacy_int != 0 {
            my_size += ::protobuf::rt::value_size(2, self.legacy_int, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.float_ != 0. {
            my_size += 5;
        }
        if !self.string_.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.string_);
        }
        if self.int_ != 0 {
            my_size += ::protobuf::rt::value_varint_zigzag_size(5, self.int_);
        }
        my_size += 2 * self.bool_array.len() as u32;
        for value in &self.int_array {
            my_size += ::protobuf::rt::value_varint_zigzag_size(7, *value);
        };
        my_size += 5 * self.float_array.len() as u32;
        for value in &self.string_array {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.bool_ != false {
            os.write_bool(1, self.bool_)?;
        }
        if self.legacy_int != 0 {
            os.write_int32(2, self.legacy_int)?;
        }
        if self.float_ != 0. {
            os.write_float(3, self.float_)?;
        }
        if !self.string_.is_empty() {
            os.write_string(4, &self.string_)?;
        }
        if self.int_ != 0 {
            os.write_sint32(5, self.int_)?;
        }
        for v in &self.bool_array {
            os.write_bool(6, *v)?;
        };
        for v in &self.int_array {
            os.write_sint32(7, *v)?;
        };
        for v in &self.float_array {
            os.write_float(8, *v)?;
        };
        for v in &self.string_array {
            os.write_string(9, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteServiceArgument {
        ExecuteServiceArgument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bool_",
                |m: &ExecuteServiceArgument| { &m.bool_ },
                |m: &mut ExecuteServiceArgument| { &mut m.bool_ },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "legacy_int",
                |m: &ExecuteServiceArgument| { &m.legacy_int },
                |m: &mut ExecuteServiceArgument| { &mut m.legacy_int },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "float_",
                |m: &ExecuteServiceArgument| { &m.float_ },
                |m: &mut ExecuteServiceArgument| { &mut m.float_ },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "string_",
                |m: &ExecuteServiceArgument| { &m.string_ },
                |m: &mut ExecuteServiceArgument| { &mut m.string_ },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "int_",
                |m: &ExecuteServiceArgument| { &m.int_ },
                |m: &mut ExecuteServiceArgument| { &mut m.int_ },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bool_array",
                |m: &ExecuteServiceArgument| { &m.bool_array },
                |m: &mut ExecuteServiceArgument| { &mut m.bool_array },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "int_array",
                |m: &ExecuteServiceArgument| { &m.int_array },
                |m: &mut ExecuteServiceArgument| { &mut m.int_array },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "float_array",
                |m: &ExecuteServiceArgument| { &m.float_array },
                |m: &mut ExecuteServiceArgument| { &mut m.float_array },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "string_array",
                |m: &ExecuteServiceArgument| { &m.string_array },
                |m: &mut ExecuteServiceArgument| { &mut m.string_array },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecuteServiceArgument>(
                "ExecuteServiceArgument",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecuteServiceArgument {
        static instance: ::protobuf::rt::LazyV2<ExecuteServiceArgument> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecuteServiceArgument::new)
    }
}

impl ::protobuf::Clear for ExecuteServiceArgument {
    fn clear(&mut self) {
        self.bool_ = false;
        self.legacy_int = 0;
        self.float_ = 0.;
        self.string_.clear();
        self.int_ = 0;
        self.bool_array.clear();
        self.int_array.clear();
        self.float_array.clear();
        self.string_array.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteServiceArgument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteServiceArgument {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteServiceRequest {
    // message fields
    pub key: u32,
    pub args: ::protobuf::RepeatedField<ExecuteServiceArgument>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteServiceRequest {
    fn default() -> &'a ExecuteServiceRequest {
        <ExecuteServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteServiceRequest {
    pub fn new() -> ExecuteServiceRequest {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // repeated .ExecuteServiceArgument args = 2;


    pub fn get_args(&self) -> &[ExecuteServiceArgument] {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<ExecuteServiceArgument>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<ExecuteServiceArgument> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<ExecuteServiceArgument> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExecuteServiceRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.args {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.args)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        for value in &self.args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        for v in &self.args {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteServiceRequest {
        ExecuteServiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ExecuteServiceRequest| { &m.key },
                |m: &mut ExecuteServiceRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecuteServiceArgument>>(
                "args",
                |m: &ExecuteServiceRequest| { &m.args },
                |m: &mut ExecuteServiceRequest| { &mut m.args },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecuteServiceRequest>(
                "ExecuteServiceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecuteServiceRequest {
        static instance: ::protobuf::rt::LazyV2<ExecuteServiceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecuteServiceRequest::new)
    }
}

impl ::protobuf::Clear for ExecuteServiceRequest {
    fn clear(&mut self) {
        self.key = 0;
        self.args.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteServiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesCameraResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub disabled_by_default: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesCameraResponse {
    fn default() -> &'a ListEntitiesCameraResponse {
        <ListEntitiesCameraResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesCameraResponse {
    pub fn new() -> ListEntitiesCameraResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // bool disabled_by_default = 5;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }
}

impl ::protobuf::Message for ListEntitiesCameraResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if self.disabled_by_default != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(5, self.disabled_by_default)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesCameraResponse {
        ListEntitiesCameraResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesCameraResponse| { &m.object_id },
                |m: &mut ListEntitiesCameraResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesCameraResponse| { &m.key },
                |m: &mut ListEntitiesCameraResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesCameraResponse| { &m.name },
                |m: &mut ListEntitiesCameraResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesCameraResponse| { &m.unique_id },
                |m: &mut ListEntitiesCameraResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesCameraResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesCameraResponse| { &mut m.disabled_by_default },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesCameraResponse>(
                "ListEntitiesCameraResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesCameraResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesCameraResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesCameraResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesCameraResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.disabled_by_default = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesCameraResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesCameraResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CameraImageResponse {
    // message fields
    pub key: u32,
    pub data: ::std::vec::Vec<u8>,
    pub done: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CameraImageResponse {
    fn default() -> &'a CameraImageResponse {
        <CameraImageResponse as ::protobuf::Message>::default_instance()
    }
}

impl CameraImageResponse {
    pub fn new() -> CameraImageResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bytes data = 2;


    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // bool done = 3;


    pub fn get_done(&self) -> bool {
        self.done
    }
    pub fn clear_done(&mut self) {
        self.done = false;
    }

    // Param is passed by value, moved
    pub fn set_done(&mut self, v: bool) {
        self.done = v;
    }
}

impl ::protobuf::Message for CameraImageResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.done = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if self.done != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if self.done != false {
            os.write_bool(3, self.done)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CameraImageResponse {
        CameraImageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &CameraImageResponse| { &m.key },
                |m: &mut CameraImageResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &CameraImageResponse| { &m.data },
                |m: &mut CameraImageResponse| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "done",
                |m: &CameraImageResponse| { &m.done },
                |m: &mut CameraImageResponse| { &mut m.done },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CameraImageResponse>(
                "CameraImageResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CameraImageResponse {
        static instance: ::protobuf::rt::LazyV2<CameraImageResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CameraImageResponse::new)
    }
}

impl ::protobuf::Clear for CameraImageResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.data.clear();
        self.done = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CameraImageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CameraImageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CameraImageRequest {
    // message fields
    pub single: bool,
    pub stream: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CameraImageRequest {
    fn default() -> &'a CameraImageRequest {
        <CameraImageRequest as ::protobuf::Message>::default_instance()
    }
}

impl CameraImageRequest {
    pub fn new() -> CameraImageRequest {
        ::std::default::Default::default()
    }

    // bool single = 1;


    pub fn get_single(&self) -> bool {
        self.single
    }
    pub fn clear_single(&mut self) {
        self.single = false;
    }

    // Param is passed by value, moved
    pub fn set_single(&mut self, v: bool) {
        self.single = v;
    }

    // bool stream = 2;


    pub fn get_stream(&self) -> bool {
        self.stream
    }
    pub fn clear_stream(&mut self) {
        self.stream = false;
    }

    // Param is passed by value, moved
    pub fn set_stream(&mut self, v: bool) {
        self.stream = v;
    }
}

impl ::protobuf::Message for CameraImageRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.single = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stream = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.single != false {
            my_size += 2;
        }
        if self.stream != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.single != false {
            os.write_bool(1, self.single)?;
        }
        if self.stream != false {
            os.write_bool(2, self.stream)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CameraImageRequest {
        CameraImageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "single",
                |m: &CameraImageRequest| { &m.single },
                |m: &mut CameraImageRequest| { &mut m.single },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stream",
                |m: &CameraImageRequest| { &m.stream },
                |m: &mut CameraImageRequest| { &mut m.stream },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CameraImageRequest>(
                "CameraImageRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CameraImageRequest {
        static instance: ::protobuf::rt::LazyV2<CameraImageRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CameraImageRequest::new)
    }
}

impl ::protobuf::Clear for CameraImageRequest {
    fn clear(&mut self) {
        self.single = false;
        self.stream = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CameraImageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CameraImageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesClimateResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub supports_current_temperature: bool,
    pub supports_two_point_target_temperature: bool,
    pub supported_modes: ::std::vec::Vec<ClimateMode>,
    pub visual_min_temperature: f32,
    pub visual_max_temperature: f32,
    pub visual_temperature_step: f32,
    pub legacy_supports_away: bool,
    pub supports_action: bool,
    pub supported_fan_modes: ::std::vec::Vec<ClimateFanMode>,
    pub supported_swing_modes: ::std::vec::Vec<ClimateSwingMode>,
    pub supported_custom_fan_modes: ::protobuf::RepeatedField<::std::string::String>,
    pub supported_presets: ::std::vec::Vec<ClimatePreset>,
    pub supported_custom_presets: ::protobuf::RepeatedField<::std::string::String>,
    pub disabled_by_default: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesClimateResponse {
    fn default() -> &'a ListEntitiesClimateResponse {
        <ListEntitiesClimateResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesClimateResponse {
    pub fn new() -> ListEntitiesClimateResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // bool supports_current_temperature = 5;


    pub fn get_supports_current_temperature(&self) -> bool {
        self.supports_current_temperature
    }
    pub fn clear_supports_current_temperature(&mut self) {
        self.supports_current_temperature = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_current_temperature(&mut self, v: bool) {
        self.supports_current_temperature = v;
    }

    // bool supports_two_point_target_temperature = 6;


    pub fn get_supports_two_point_target_temperature(&self) -> bool {
        self.supports_two_point_target_temperature
    }
    pub fn clear_supports_two_point_target_temperature(&mut self) {
        self.supports_two_point_target_temperature = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_two_point_target_temperature(&mut self, v: bool) {
        self.supports_two_point_target_temperature = v;
    }

    // repeated .ClimateMode supported_modes = 7;


    pub fn get_supported_modes(&self) -> &[ClimateMode] {
        &self.supported_modes
    }
    pub fn clear_supported_modes(&mut self) {
        self.supported_modes.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_modes(&mut self, v: ::std::vec::Vec<ClimateMode>) {
        self.supported_modes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_modes(&mut self) -> &mut ::std::vec::Vec<ClimateMode> {
        &mut self.supported_modes
    }

    // Take field
    pub fn take_supported_modes(&mut self) -> ::std::vec::Vec<ClimateMode> {
        ::std::mem::replace(&mut self.supported_modes, ::std::vec::Vec::new())
    }

    // float visual_min_temperature = 8;


    pub fn get_visual_min_temperature(&self) -> f32 {
        self.visual_min_temperature
    }
    pub fn clear_visual_min_temperature(&mut self) {
        self.visual_min_temperature = 0.;
    }

    // Param is passed by value, moved
    pub fn set_visual_min_temperature(&mut self, v: f32) {
        self.visual_min_temperature = v;
    }

    // float visual_max_temperature = 9;


    pub fn get_visual_max_temperature(&self) -> f32 {
        self.visual_max_temperature
    }
    pub fn clear_visual_max_temperature(&mut self) {
        self.visual_max_temperature = 0.;
    }

    // Param is passed by value, moved
    pub fn set_visual_max_temperature(&mut self, v: f32) {
        self.visual_max_temperature = v;
    }

    // float visual_temperature_step = 10;


    pub fn get_visual_temperature_step(&self) -> f32 {
        self.visual_temperature_step
    }
    pub fn clear_visual_temperature_step(&mut self) {
        self.visual_temperature_step = 0.;
    }

    // Param is passed by value, moved
    pub fn set_visual_temperature_step(&mut self, v: f32) {
        self.visual_temperature_step = v;
    }

    // bool legacy_supports_away = 11;


    pub fn get_legacy_supports_away(&self) -> bool {
        self.legacy_supports_away
    }
    pub fn clear_legacy_supports_away(&mut self) {
        self.legacy_supports_away = false;
    }

    // Param is passed by value, moved
    pub fn set_legacy_supports_away(&mut self, v: bool) {
        self.legacy_supports_away = v;
    }

    // bool supports_action = 12;


    pub fn get_supports_action(&self) -> bool {
        self.supports_action
    }
    pub fn clear_supports_action(&mut self) {
        self.supports_action = false;
    }

    // Param is passed by value, moved
    pub fn set_supports_action(&mut self, v: bool) {
        self.supports_action = v;
    }

    // repeated .ClimateFanMode supported_fan_modes = 13;


    pub fn get_supported_fan_modes(&self) -> &[ClimateFanMode] {
        &self.supported_fan_modes
    }
    pub fn clear_supported_fan_modes(&mut self) {
        self.supported_fan_modes.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_fan_modes(&mut self, v: ::std::vec::Vec<ClimateFanMode>) {
        self.supported_fan_modes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_fan_modes(&mut self) -> &mut ::std::vec::Vec<ClimateFanMode> {
        &mut self.supported_fan_modes
    }

    // Take field
    pub fn take_supported_fan_modes(&mut self) -> ::std::vec::Vec<ClimateFanMode> {
        ::std::mem::replace(&mut self.supported_fan_modes, ::std::vec::Vec::new())
    }

    // repeated .ClimateSwingMode supported_swing_modes = 14;


    pub fn get_supported_swing_modes(&self) -> &[ClimateSwingMode] {
        &self.supported_swing_modes
    }
    pub fn clear_supported_swing_modes(&mut self) {
        self.supported_swing_modes.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_swing_modes(&mut self, v: ::std::vec::Vec<ClimateSwingMode>) {
        self.supported_swing_modes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_swing_modes(&mut self) -> &mut ::std::vec::Vec<ClimateSwingMode> {
        &mut self.supported_swing_modes
    }

    // Take field
    pub fn take_supported_swing_modes(&mut self) -> ::std::vec::Vec<ClimateSwingMode> {
        ::std::mem::replace(&mut self.supported_swing_modes, ::std::vec::Vec::new())
    }

    // repeated string supported_custom_fan_modes = 15;


    pub fn get_supported_custom_fan_modes(&self) -> &[::std::string::String] {
        &self.supported_custom_fan_modes
    }
    pub fn clear_supported_custom_fan_modes(&mut self) {
        self.supported_custom_fan_modes.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_custom_fan_modes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.supported_custom_fan_modes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_custom_fan_modes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.supported_custom_fan_modes
    }

    // Take field
    pub fn take_supported_custom_fan_modes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.supported_custom_fan_modes, ::protobuf::RepeatedField::new())
    }

    // repeated .ClimatePreset supported_presets = 16;


    pub fn get_supported_presets(&self) -> &[ClimatePreset] {
        &self.supported_presets
    }
    pub fn clear_supported_presets(&mut self) {
        self.supported_presets.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_presets(&mut self, v: ::std::vec::Vec<ClimatePreset>) {
        self.supported_presets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_presets(&mut self) -> &mut ::std::vec::Vec<ClimatePreset> {
        &mut self.supported_presets
    }

    // Take field
    pub fn take_supported_presets(&mut self) -> ::std::vec::Vec<ClimatePreset> {
        ::std::mem::replace(&mut self.supported_presets, ::std::vec::Vec::new())
    }

    // repeated string supported_custom_presets = 17;


    pub fn get_supported_custom_presets(&self) -> &[::std::string::String] {
        &self.supported_custom_presets
    }
    pub fn clear_supported_custom_presets(&mut self) {
        self.supported_custom_presets.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_custom_presets(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.supported_custom_presets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_custom_presets(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.supported_custom_presets
    }

    // Take field
    pub fn take_supported_custom_presets(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.supported_custom_presets, ::protobuf::RepeatedField::new())
    }

    // bool disabled_by_default = 18;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }
}

impl ::protobuf::Message for ListEntitiesClimateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_current_temperature = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_two_point_target_temperature = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.supported_modes, 7, &mut self.unknown_fields)?
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.visual_min_temperature = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.visual_max_temperature = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.visual_temperature_step = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.legacy_supports_away = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.supports_action = tmp;
                },
                13 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.supported_fan_modes, 13, &mut self.unknown_fields)?
                },
                14 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.supported_swing_modes, 14, &mut self.unknown_fields)?
                },
                15 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.supported_custom_fan_modes)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.supported_presets, 16, &mut self.unknown_fields)?
                },
                17 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.supported_custom_presets)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if self.supports_current_temperature != false {
            my_size += 2;
        }
        if self.supports_two_point_target_temperature != false {
            my_size += 2;
        }
        for value in &self.supported_modes {
            my_size += ::protobuf::rt::enum_size(7, *value);
        };
        if self.visual_min_temperature != 0. {
            my_size += 5;
        }
        if self.visual_max_temperature != 0. {
            my_size += 5;
        }
        if self.visual_temperature_step != 0. {
            my_size += 5;
        }
        if self.legacy_supports_away != false {
            my_size += 2;
        }
        if self.supports_action != false {
            my_size += 2;
        }
        for value in &self.supported_fan_modes {
            my_size += ::protobuf::rt::enum_size(13, *value);
        };
        for value in &self.supported_swing_modes {
            my_size += ::protobuf::rt::enum_size(14, *value);
        };
        for value in &self.supported_custom_fan_modes {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        for value in &self.supported_presets {
            my_size += ::protobuf::rt::enum_size(16, *value);
        };
        for value in &self.supported_custom_presets {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        if self.disabled_by_default != false {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if self.supports_current_temperature != false {
            os.write_bool(5, self.supports_current_temperature)?;
        }
        if self.supports_two_point_target_temperature != false {
            os.write_bool(6, self.supports_two_point_target_temperature)?;
        }
        for v in &self.supported_modes {
            os.write_enum(7, ::protobuf::ProtobufEnum::value(v))?;
        };
        if self.visual_min_temperature != 0. {
            os.write_float(8, self.visual_min_temperature)?;
        }
        if self.visual_max_temperature != 0. {
            os.write_float(9, self.visual_max_temperature)?;
        }
        if self.visual_temperature_step != 0. {
            os.write_float(10, self.visual_temperature_step)?;
        }
        if self.legacy_supports_away != false {
            os.write_bool(11, self.legacy_supports_away)?;
        }
        if self.supports_action != false {
            os.write_bool(12, self.supports_action)?;
        }
        for v in &self.supported_fan_modes {
            os.write_enum(13, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.supported_swing_modes {
            os.write_enum(14, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.supported_custom_fan_modes {
            os.write_string(15, &v)?;
        };
        for v in &self.supported_presets {
            os.write_enum(16, ::protobuf::ProtobufEnum::value(v))?;
        };
        for v in &self.supported_custom_presets {
            os.write_string(17, &v)?;
        };
        if self.disabled_by_default != false {
            os.write_bool(18, self.disabled_by_default)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesClimateResponse {
        ListEntitiesClimateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesClimateResponse| { &m.object_id },
                |m: &mut ListEntitiesClimateResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesClimateResponse| { &m.key },
                |m: &mut ListEntitiesClimateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesClimateResponse| { &m.name },
                |m: &mut ListEntitiesClimateResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesClimateResponse| { &m.unique_id },
                |m: &mut ListEntitiesClimateResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_current_temperature",
                |m: &ListEntitiesClimateResponse| { &m.supports_current_temperature },
                |m: &mut ListEntitiesClimateResponse| { &mut m.supports_current_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_two_point_target_temperature",
                |m: &ListEntitiesClimateResponse| { &m.supports_two_point_target_temperature },
                |m: &mut ListEntitiesClimateResponse| { &mut m.supports_two_point_target_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateMode>>(
                "supported_modes",
                |m: &ListEntitiesClimateResponse| { &m.supported_modes },
                |m: &mut ListEntitiesClimateResponse| { &mut m.supported_modes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "visual_min_temperature",
                |m: &ListEntitiesClimateResponse| { &m.visual_min_temperature },
                |m: &mut ListEntitiesClimateResponse| { &mut m.visual_min_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "visual_max_temperature",
                |m: &ListEntitiesClimateResponse| { &m.visual_max_temperature },
                |m: &mut ListEntitiesClimateResponse| { &mut m.visual_max_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "visual_temperature_step",
                |m: &ListEntitiesClimateResponse| { &m.visual_temperature_step },
                |m: &mut ListEntitiesClimateResponse| { &mut m.visual_temperature_step },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "legacy_supports_away",
                |m: &ListEntitiesClimateResponse| { &m.legacy_supports_away },
                |m: &mut ListEntitiesClimateResponse| { &mut m.legacy_supports_away },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "supports_action",
                |m: &ListEntitiesClimateResponse| { &m.supports_action },
                |m: &mut ListEntitiesClimateResponse| { &mut m.supports_action },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateFanMode>>(
                "supported_fan_modes",
                |m: &ListEntitiesClimateResponse| { &m.supported_fan_modes },
                |m: &mut ListEntitiesClimateResponse| { &mut m.supported_fan_modes },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateSwingMode>>(
                "supported_swing_modes",
                |m: &ListEntitiesClimateResponse| { &m.supported_swing_modes },
                |m: &mut ListEntitiesClimateResponse| { &mut m.supported_swing_modes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "supported_custom_fan_modes",
                |m: &ListEntitiesClimateResponse| { &m.supported_custom_fan_modes },
                |m: &mut ListEntitiesClimateResponse| { &mut m.supported_custom_fan_modes },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimatePreset>>(
                "supported_presets",
                |m: &ListEntitiesClimateResponse| { &m.supported_presets },
                |m: &mut ListEntitiesClimateResponse| { &mut m.supported_presets },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "supported_custom_presets",
                |m: &ListEntitiesClimateResponse| { &m.supported_custom_presets },
                |m: &mut ListEntitiesClimateResponse| { &mut m.supported_custom_presets },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesClimateResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesClimateResponse| { &mut m.disabled_by_default },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesClimateResponse>(
                "ListEntitiesClimateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesClimateResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesClimateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesClimateResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesClimateResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.supports_current_temperature = false;
        self.supports_two_point_target_temperature = false;
        self.supported_modes.clear();
        self.visual_min_temperature = 0.;
        self.visual_max_temperature = 0.;
        self.visual_temperature_step = 0.;
        self.legacy_supports_away = false;
        self.supports_action = false;
        self.supported_fan_modes.clear();
        self.supported_swing_modes.clear();
        self.supported_custom_fan_modes.clear();
        self.supported_presets.clear();
        self.supported_custom_presets.clear();
        self.disabled_by_default = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesClimateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesClimateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClimateStateResponse {
    // message fields
    pub key: u32,
    pub mode: ClimateMode,
    pub current_temperature: f32,
    pub target_temperature: f32,
    pub target_temperature_low: f32,
    pub target_temperature_high: f32,
    pub legacy_away: bool,
    pub action: ClimateAction,
    pub fan_mode: ClimateFanMode,
    pub swing_mode: ClimateSwingMode,
    pub custom_fan_mode: ::std::string::String,
    pub preset: ClimatePreset,
    pub custom_preset: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClimateStateResponse {
    fn default() -> &'a ClimateStateResponse {
        <ClimateStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl ClimateStateResponse {
    pub fn new() -> ClimateStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // .ClimateMode mode = 2;


    pub fn get_mode(&self) -> ClimateMode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = ClimateMode::CLIMATE_MODE_OFF;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: ClimateMode) {
        self.mode = v;
    }

    // float current_temperature = 3;


    pub fn get_current_temperature(&self) -> f32 {
        self.current_temperature
    }
    pub fn clear_current_temperature(&mut self) {
        self.current_temperature = 0.;
    }

    // Param is passed by value, moved
    pub fn set_current_temperature(&mut self, v: f32) {
        self.current_temperature = v;
    }

    // float target_temperature = 4;


    pub fn get_target_temperature(&self) -> f32 {
        self.target_temperature
    }
    pub fn clear_target_temperature(&mut self) {
        self.target_temperature = 0.;
    }

    // Param is passed by value, moved
    pub fn set_target_temperature(&mut self, v: f32) {
        self.target_temperature = v;
    }

    // float target_temperature_low = 5;


    pub fn get_target_temperature_low(&self) -> f32 {
        self.target_temperature_low
    }
    pub fn clear_target_temperature_low(&mut self) {
        self.target_temperature_low = 0.;
    }

    // Param is passed by value, moved
    pub fn set_target_temperature_low(&mut self, v: f32) {
        self.target_temperature_low = v;
    }

    // float target_temperature_high = 6;


    pub fn get_target_temperature_high(&self) -> f32 {
        self.target_temperature_high
    }
    pub fn clear_target_temperature_high(&mut self) {
        self.target_temperature_high = 0.;
    }

    // Param is passed by value, moved
    pub fn set_target_temperature_high(&mut self, v: f32) {
        self.target_temperature_high = v;
    }

    // bool legacy_away = 7;


    pub fn get_legacy_away(&self) -> bool {
        self.legacy_away
    }
    pub fn clear_legacy_away(&mut self) {
        self.legacy_away = false;
    }

    // Param is passed by value, moved
    pub fn set_legacy_away(&mut self, v: bool) {
        self.legacy_away = v;
    }

    // .ClimateAction action = 8;


    pub fn get_action(&self) -> ClimateAction {
        self.action
    }
    pub fn clear_action(&mut self) {
        self.action = ClimateAction::CLIMATE_ACTION_OFF;
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ClimateAction) {
        self.action = v;
    }

    // .ClimateFanMode fan_mode = 9;


    pub fn get_fan_mode(&self) -> ClimateFanMode {
        self.fan_mode
    }
    pub fn clear_fan_mode(&mut self) {
        self.fan_mode = ClimateFanMode::CLIMATE_FAN_ON;
    }

    // Param is passed by value, moved
    pub fn set_fan_mode(&mut self, v: ClimateFanMode) {
        self.fan_mode = v;
    }

    // .ClimateSwingMode swing_mode = 10;


    pub fn get_swing_mode(&self) -> ClimateSwingMode {
        self.swing_mode
    }
    pub fn clear_swing_mode(&mut self) {
        self.swing_mode = ClimateSwingMode::CLIMATE_SWING_OFF;
    }

    // Param is passed by value, moved
    pub fn set_swing_mode(&mut self, v: ClimateSwingMode) {
        self.swing_mode = v;
    }

    // string custom_fan_mode = 11;


    pub fn get_custom_fan_mode(&self) -> &str {
        &self.custom_fan_mode
    }
    pub fn clear_custom_fan_mode(&mut self) {
        self.custom_fan_mode.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_fan_mode(&mut self, v: ::std::string::String) {
        self.custom_fan_mode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_fan_mode(&mut self) -> &mut ::std::string::String {
        &mut self.custom_fan_mode
    }

    // Take field
    pub fn take_custom_fan_mode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.custom_fan_mode, ::std::string::String::new())
    }

    // .ClimatePreset preset = 12;


    pub fn get_preset(&self) -> ClimatePreset {
        self.preset
    }
    pub fn clear_preset(&mut self) {
        self.preset = ClimatePreset::CLIMATE_PRESET_NONE;
    }

    // Param is passed by value, moved
    pub fn set_preset(&mut self, v: ClimatePreset) {
        self.preset = v;
    }

    // string custom_preset = 13;


    pub fn get_custom_preset(&self) -> &str {
        &self.custom_preset
    }
    pub fn clear_custom_preset(&mut self) {
        self.custom_preset.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_preset(&mut self, v: ::std::string::String) {
        self.custom_preset = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_preset(&mut self) -> &mut ::std::string::String {
        &mut self.custom_preset
    }

    // Take field
    pub fn take_custom_preset(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.custom_preset, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ClimateStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.current_temperature = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.target_temperature = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.target_temperature_low = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.target_temperature_high = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.legacy_away = tmp;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.fan_mode, 9, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.swing_mode, 10, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.custom_fan_mode)?;
                },
                12 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.preset, 12, &mut self.unknown_fields)?
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.custom_preset)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.mode != ClimateMode::CLIMATE_MODE_OFF {
            my_size += ::protobuf::rt::enum_size(2, self.mode);
        }
        if self.current_temperature != 0. {
            my_size += 5;
        }
        if self.target_temperature != 0. {
            my_size += 5;
        }
        if self.target_temperature_low != 0. {
            my_size += 5;
        }
        if self.target_temperature_high != 0. {
            my_size += 5;
        }
        if self.legacy_away != false {
            my_size += 2;
        }
        if self.action != ClimateAction::CLIMATE_ACTION_OFF {
            my_size += ::protobuf::rt::enum_size(8, self.action);
        }
        if self.fan_mode != ClimateFanMode::CLIMATE_FAN_ON {
            my_size += ::protobuf::rt::enum_size(9, self.fan_mode);
        }
        if self.swing_mode != ClimateSwingMode::CLIMATE_SWING_OFF {
            my_size += ::protobuf::rt::enum_size(10, self.swing_mode);
        }
        if !self.custom_fan_mode.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.custom_fan_mode);
        }
        if self.preset != ClimatePreset::CLIMATE_PRESET_NONE {
            my_size += ::protobuf::rt::enum_size(12, self.preset);
        }
        if !self.custom_preset.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.custom_preset);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.mode != ClimateMode::CLIMATE_MODE_OFF {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.mode))?;
        }
        if self.current_temperature != 0. {
            os.write_float(3, self.current_temperature)?;
        }
        if self.target_temperature != 0. {
            os.write_float(4, self.target_temperature)?;
        }
        if self.target_temperature_low != 0. {
            os.write_float(5, self.target_temperature_low)?;
        }
        if self.target_temperature_high != 0. {
            os.write_float(6, self.target_temperature_high)?;
        }
        if self.legacy_away != false {
            os.write_bool(7, self.legacy_away)?;
        }
        if self.action != ClimateAction::CLIMATE_ACTION_OFF {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&self.action))?;
        }
        if self.fan_mode != ClimateFanMode::CLIMATE_FAN_ON {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.fan_mode))?;
        }
        if self.swing_mode != ClimateSwingMode::CLIMATE_SWING_OFF {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&self.swing_mode))?;
        }
        if !self.custom_fan_mode.is_empty() {
            os.write_string(11, &self.custom_fan_mode)?;
        }
        if self.preset != ClimatePreset::CLIMATE_PRESET_NONE {
            os.write_enum(12, ::protobuf::ProtobufEnum::value(&self.preset))?;
        }
        if !self.custom_preset.is_empty() {
            os.write_string(13, &self.custom_preset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClimateStateResponse {
        ClimateStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ClimateStateResponse| { &m.key },
                |m: &mut ClimateStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateMode>>(
                "mode",
                |m: &ClimateStateResponse| { &m.mode },
                |m: &mut ClimateStateResponse| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "current_temperature",
                |m: &ClimateStateResponse| { &m.current_temperature },
                |m: &mut ClimateStateResponse| { &mut m.current_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "target_temperature",
                |m: &ClimateStateResponse| { &m.target_temperature },
                |m: &mut ClimateStateResponse| { &mut m.target_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "target_temperature_low",
                |m: &ClimateStateResponse| { &m.target_temperature_low },
                |m: &mut ClimateStateResponse| { &mut m.target_temperature_low },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "target_temperature_high",
                |m: &ClimateStateResponse| { &m.target_temperature_high },
                |m: &mut ClimateStateResponse| { &mut m.target_temperature_high },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "legacy_away",
                |m: &ClimateStateResponse| { &m.legacy_away },
                |m: &mut ClimateStateResponse| { &mut m.legacy_away },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateAction>>(
                "action",
                |m: &ClimateStateResponse| { &m.action },
                |m: &mut ClimateStateResponse| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateFanMode>>(
                "fan_mode",
                |m: &ClimateStateResponse| { &m.fan_mode },
                |m: &mut ClimateStateResponse| { &mut m.fan_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateSwingMode>>(
                "swing_mode",
                |m: &ClimateStateResponse| { &m.swing_mode },
                |m: &mut ClimateStateResponse| { &mut m.swing_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "custom_fan_mode",
                |m: &ClimateStateResponse| { &m.custom_fan_mode },
                |m: &mut ClimateStateResponse| { &mut m.custom_fan_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimatePreset>>(
                "preset",
                |m: &ClimateStateResponse| { &m.preset },
                |m: &mut ClimateStateResponse| { &mut m.preset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "custom_preset",
                |m: &ClimateStateResponse| { &m.custom_preset },
                |m: &mut ClimateStateResponse| { &mut m.custom_preset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClimateStateResponse>(
                "ClimateStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClimateStateResponse {
        static instance: ::protobuf::rt::LazyV2<ClimateStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClimateStateResponse::new)
    }
}

impl ::protobuf::Clear for ClimateStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.mode = ClimateMode::CLIMATE_MODE_OFF;
        self.current_temperature = 0.;
        self.target_temperature = 0.;
        self.target_temperature_low = 0.;
        self.target_temperature_high = 0.;
        self.legacy_away = false;
        self.action = ClimateAction::CLIMATE_ACTION_OFF;
        self.fan_mode = ClimateFanMode::CLIMATE_FAN_ON;
        self.swing_mode = ClimateSwingMode::CLIMATE_SWING_OFF;
        self.custom_fan_mode.clear();
        self.preset = ClimatePreset::CLIMATE_PRESET_NONE;
        self.custom_preset.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClimateStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClimateStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClimateCommandRequest {
    // message fields
    pub key: u32,
    pub has_mode: bool,
    pub mode: ClimateMode,
    pub has_target_temperature: bool,
    pub target_temperature: f32,
    pub has_target_temperature_low: bool,
    pub target_temperature_low: f32,
    pub has_target_temperature_high: bool,
    pub target_temperature_high: f32,
    pub has_legacy_away: bool,
    pub legacy_away: bool,
    pub has_fan_mode: bool,
    pub fan_mode: ClimateFanMode,
    pub has_swing_mode: bool,
    pub swing_mode: ClimateSwingMode,
    pub has_custom_fan_mode: bool,
    pub custom_fan_mode: ::std::string::String,
    pub has_preset: bool,
    pub preset: ClimatePreset,
    pub has_custom_preset: bool,
    pub custom_preset: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClimateCommandRequest {
    fn default() -> &'a ClimateCommandRequest {
        <ClimateCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl ClimateCommandRequest {
    pub fn new() -> ClimateCommandRequest {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // bool has_mode = 2;


    pub fn get_has_mode(&self) -> bool {
        self.has_mode
    }
    pub fn clear_has_mode(&mut self) {
        self.has_mode = false;
    }

    // Param is passed by value, moved
    pub fn set_has_mode(&mut self, v: bool) {
        self.has_mode = v;
    }

    // .ClimateMode mode = 3;


    pub fn get_mode(&self) -> ClimateMode {
        self.mode
    }
    pub fn clear_mode(&mut self) {
        self.mode = ClimateMode::CLIMATE_MODE_OFF;
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: ClimateMode) {
        self.mode = v;
    }

    // bool has_target_temperature = 4;


    pub fn get_has_target_temperature(&self) -> bool {
        self.has_target_temperature
    }
    pub fn clear_has_target_temperature(&mut self) {
        self.has_target_temperature = false;
    }

    // Param is passed by value, moved
    pub fn set_has_target_temperature(&mut self, v: bool) {
        self.has_target_temperature = v;
    }

    // float target_temperature = 5;


    pub fn get_target_temperature(&self) -> f32 {
        self.target_temperature
    }
    pub fn clear_target_temperature(&mut self) {
        self.target_temperature = 0.;
    }

    // Param is passed by value, moved
    pub fn set_target_temperature(&mut self, v: f32) {
        self.target_temperature = v;
    }

    // bool has_target_temperature_low = 6;


    pub fn get_has_target_temperature_low(&self) -> bool {
        self.has_target_temperature_low
    }
    pub fn clear_has_target_temperature_low(&mut self) {
        self.has_target_temperature_low = false;
    }

    // Param is passed by value, moved
    pub fn set_has_target_temperature_low(&mut self, v: bool) {
        self.has_target_temperature_low = v;
    }

    // float target_temperature_low = 7;


    pub fn get_target_temperature_low(&self) -> f32 {
        self.target_temperature_low
    }
    pub fn clear_target_temperature_low(&mut self) {
        self.target_temperature_low = 0.;
    }

    // Param is passed by value, moved
    pub fn set_target_temperature_low(&mut self, v: f32) {
        self.target_temperature_low = v;
    }

    // bool has_target_temperature_high = 8;


    pub fn get_has_target_temperature_high(&self) -> bool {
        self.has_target_temperature_high
    }
    pub fn clear_has_target_temperature_high(&mut self) {
        self.has_target_temperature_high = false;
    }

    // Param is passed by value, moved
    pub fn set_has_target_temperature_high(&mut self, v: bool) {
        self.has_target_temperature_high = v;
    }

    // float target_temperature_high = 9;


    pub fn get_target_temperature_high(&self) -> f32 {
        self.target_temperature_high
    }
    pub fn clear_target_temperature_high(&mut self) {
        self.target_temperature_high = 0.;
    }

    // Param is passed by value, moved
    pub fn set_target_temperature_high(&mut self, v: f32) {
        self.target_temperature_high = v;
    }

    // bool has_legacy_away = 10;


    pub fn get_has_legacy_away(&self) -> bool {
        self.has_legacy_away
    }
    pub fn clear_has_legacy_away(&mut self) {
        self.has_legacy_away = false;
    }

    // Param is passed by value, moved
    pub fn set_has_legacy_away(&mut self, v: bool) {
        self.has_legacy_away = v;
    }

    // bool legacy_away = 11;


    pub fn get_legacy_away(&self) -> bool {
        self.legacy_away
    }
    pub fn clear_legacy_away(&mut self) {
        self.legacy_away = false;
    }

    // Param is passed by value, moved
    pub fn set_legacy_away(&mut self, v: bool) {
        self.legacy_away = v;
    }

    // bool has_fan_mode = 12;


    pub fn get_has_fan_mode(&self) -> bool {
        self.has_fan_mode
    }
    pub fn clear_has_fan_mode(&mut self) {
        self.has_fan_mode = false;
    }

    // Param is passed by value, moved
    pub fn set_has_fan_mode(&mut self, v: bool) {
        self.has_fan_mode = v;
    }

    // .ClimateFanMode fan_mode = 13;


    pub fn get_fan_mode(&self) -> ClimateFanMode {
        self.fan_mode
    }
    pub fn clear_fan_mode(&mut self) {
        self.fan_mode = ClimateFanMode::CLIMATE_FAN_ON;
    }

    // Param is passed by value, moved
    pub fn set_fan_mode(&mut self, v: ClimateFanMode) {
        self.fan_mode = v;
    }

    // bool has_swing_mode = 14;


    pub fn get_has_swing_mode(&self) -> bool {
        self.has_swing_mode
    }
    pub fn clear_has_swing_mode(&mut self) {
        self.has_swing_mode = false;
    }

    // Param is passed by value, moved
    pub fn set_has_swing_mode(&mut self, v: bool) {
        self.has_swing_mode = v;
    }

    // .ClimateSwingMode swing_mode = 15;


    pub fn get_swing_mode(&self) -> ClimateSwingMode {
        self.swing_mode
    }
    pub fn clear_swing_mode(&mut self) {
        self.swing_mode = ClimateSwingMode::CLIMATE_SWING_OFF;
    }

    // Param is passed by value, moved
    pub fn set_swing_mode(&mut self, v: ClimateSwingMode) {
        self.swing_mode = v;
    }

    // bool has_custom_fan_mode = 16;


    pub fn get_has_custom_fan_mode(&self) -> bool {
        self.has_custom_fan_mode
    }
    pub fn clear_has_custom_fan_mode(&mut self) {
        self.has_custom_fan_mode = false;
    }

    // Param is passed by value, moved
    pub fn set_has_custom_fan_mode(&mut self, v: bool) {
        self.has_custom_fan_mode = v;
    }

    // string custom_fan_mode = 17;


    pub fn get_custom_fan_mode(&self) -> &str {
        &self.custom_fan_mode
    }
    pub fn clear_custom_fan_mode(&mut self) {
        self.custom_fan_mode.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_fan_mode(&mut self, v: ::std::string::String) {
        self.custom_fan_mode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_fan_mode(&mut self) -> &mut ::std::string::String {
        &mut self.custom_fan_mode
    }

    // Take field
    pub fn take_custom_fan_mode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.custom_fan_mode, ::std::string::String::new())
    }

    // bool has_preset = 18;


    pub fn get_has_preset(&self) -> bool {
        self.has_preset
    }
    pub fn clear_has_preset(&mut self) {
        self.has_preset = false;
    }

    // Param is passed by value, moved
    pub fn set_has_preset(&mut self, v: bool) {
        self.has_preset = v;
    }

    // .ClimatePreset preset = 19;


    pub fn get_preset(&self) -> ClimatePreset {
        self.preset
    }
    pub fn clear_preset(&mut self) {
        self.preset = ClimatePreset::CLIMATE_PRESET_NONE;
    }

    // Param is passed by value, moved
    pub fn set_preset(&mut self, v: ClimatePreset) {
        self.preset = v;
    }

    // bool has_custom_preset = 20;


    pub fn get_has_custom_preset(&self) -> bool {
        self.has_custom_preset
    }
    pub fn clear_has_custom_preset(&mut self) {
        self.has_custom_preset = false;
    }

    // Param is passed by value, moved
    pub fn set_has_custom_preset(&mut self, v: bool) {
        self.has_custom_preset = v;
    }

    // string custom_preset = 21;


    pub fn get_custom_preset(&self) -> &str {
        &self.custom_preset
    }
    pub fn clear_custom_preset(&mut self) {
        self.custom_preset.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_preset(&mut self, v: ::std::string::String) {
        self.custom_preset = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_preset(&mut self) -> &mut ::std::string::String {
        &mut self.custom_preset
    }

    // Take field
    pub fn take_custom_preset(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.custom_preset, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ClimateCommandRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_mode = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.mode, 3, &mut self.unknown_fields)?
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_target_temperature = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.target_temperature = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_target_temperature_low = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.target_temperature_low = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_target_temperature_high = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.target_temperature_high = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_legacy_away = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.legacy_away = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_fan_mode = tmp;
                },
                13 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.fan_mode, 13, &mut self.unknown_fields)?
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_swing_mode = tmp;
                },
                15 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.swing_mode, 15, &mut self.unknown_fields)?
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_custom_fan_mode = tmp;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.custom_fan_mode)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_preset = tmp;
                },
                19 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.preset, 19, &mut self.unknown_fields)?
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_custom_preset = tmp;
                },
                21 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.custom_preset)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.has_mode != false {
            my_size += 2;
        }
        if self.mode != ClimateMode::CLIMATE_MODE_OFF {
            my_size += ::protobuf::rt::enum_size(3, self.mode);
        }
        if self.has_target_temperature != false {
            my_size += 2;
        }
        if self.target_temperature != 0. {
            my_size += 5;
        }
        if self.has_target_temperature_low != false {
            my_size += 2;
        }
        if self.target_temperature_low != 0. {
            my_size += 5;
        }
        if self.has_target_temperature_high != false {
            my_size += 2;
        }
        if self.target_temperature_high != 0. {
            my_size += 5;
        }
        if self.has_legacy_away != false {
            my_size += 2;
        }
        if self.legacy_away != false {
            my_size += 2;
        }
        if self.has_fan_mode != false {
            my_size += 2;
        }
        if self.fan_mode != ClimateFanMode::CLIMATE_FAN_ON {
            my_size += ::protobuf::rt::enum_size(13, self.fan_mode);
        }
        if self.has_swing_mode != false {
            my_size += 2;
        }
        if self.swing_mode != ClimateSwingMode::CLIMATE_SWING_OFF {
            my_size += ::protobuf::rt::enum_size(15, self.swing_mode);
        }
        if self.has_custom_fan_mode != false {
            my_size += 3;
        }
        if !self.custom_fan_mode.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.custom_fan_mode);
        }
        if self.has_preset != false {
            my_size += 3;
        }
        if self.preset != ClimatePreset::CLIMATE_PRESET_NONE {
            my_size += ::protobuf::rt::enum_size(19, self.preset);
        }
        if self.has_custom_preset != false {
            my_size += 3;
        }
        if !self.custom_preset.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.custom_preset);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_mode != false {
            os.write_bool(2, self.has_mode)?;
        }
        if self.mode != ClimateMode::CLIMATE_MODE_OFF {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.mode))?;
        }
        if self.has_target_temperature != false {
            os.write_bool(4, self.has_target_temperature)?;
        }
        if self.target_temperature != 0. {
            os.write_float(5, self.target_temperature)?;
        }
        if self.has_target_temperature_low != false {
            os.write_bool(6, self.has_target_temperature_low)?;
        }
        if self.target_temperature_low != 0. {
            os.write_float(7, self.target_temperature_low)?;
        }
        if self.has_target_temperature_high != false {
            os.write_bool(8, self.has_target_temperature_high)?;
        }
        if self.target_temperature_high != 0. {
            os.write_float(9, self.target_temperature_high)?;
        }
        if self.has_legacy_away != false {
            os.write_bool(10, self.has_legacy_away)?;
        }
        if self.legacy_away != false {
            os.write_bool(11, self.legacy_away)?;
        }
        if self.has_fan_mode != false {
            os.write_bool(12, self.has_fan_mode)?;
        }
        if self.fan_mode != ClimateFanMode::CLIMATE_FAN_ON {
            os.write_enum(13, ::protobuf::ProtobufEnum::value(&self.fan_mode))?;
        }
        if self.has_swing_mode != false {
            os.write_bool(14, self.has_swing_mode)?;
        }
        if self.swing_mode != ClimateSwingMode::CLIMATE_SWING_OFF {
            os.write_enum(15, ::protobuf::ProtobufEnum::value(&self.swing_mode))?;
        }
        if self.has_custom_fan_mode != false {
            os.write_bool(16, self.has_custom_fan_mode)?;
        }
        if !self.custom_fan_mode.is_empty() {
            os.write_string(17, &self.custom_fan_mode)?;
        }
        if self.has_preset != false {
            os.write_bool(18, self.has_preset)?;
        }
        if self.preset != ClimatePreset::CLIMATE_PRESET_NONE {
            os.write_enum(19, ::protobuf::ProtobufEnum::value(&self.preset))?;
        }
        if self.has_custom_preset != false {
            os.write_bool(20, self.has_custom_preset)?;
        }
        if !self.custom_preset.is_empty() {
            os.write_string(21, &self.custom_preset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClimateCommandRequest {
        ClimateCommandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ClimateCommandRequest| { &m.key },
                |m: &mut ClimateCommandRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_mode",
                |m: &ClimateCommandRequest| { &m.has_mode },
                |m: &mut ClimateCommandRequest| { &mut m.has_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateMode>>(
                "mode",
                |m: &ClimateCommandRequest| { &m.mode },
                |m: &mut ClimateCommandRequest| { &mut m.mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_target_temperature",
                |m: &ClimateCommandRequest| { &m.has_target_temperature },
                |m: &mut ClimateCommandRequest| { &mut m.has_target_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "target_temperature",
                |m: &ClimateCommandRequest| { &m.target_temperature },
                |m: &mut ClimateCommandRequest| { &mut m.target_temperature },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_target_temperature_low",
                |m: &ClimateCommandRequest| { &m.has_target_temperature_low },
                |m: &mut ClimateCommandRequest| { &mut m.has_target_temperature_low },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "target_temperature_low",
                |m: &ClimateCommandRequest| { &m.target_temperature_low },
                |m: &mut ClimateCommandRequest| { &mut m.target_temperature_low },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_target_temperature_high",
                |m: &ClimateCommandRequest| { &m.has_target_temperature_high },
                |m: &mut ClimateCommandRequest| { &mut m.has_target_temperature_high },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "target_temperature_high",
                |m: &ClimateCommandRequest| { &m.target_temperature_high },
                |m: &mut ClimateCommandRequest| { &mut m.target_temperature_high },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_legacy_away",
                |m: &ClimateCommandRequest| { &m.has_legacy_away },
                |m: &mut ClimateCommandRequest| { &mut m.has_legacy_away },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "legacy_away",
                |m: &ClimateCommandRequest| { &m.legacy_away },
                |m: &mut ClimateCommandRequest| { &mut m.legacy_away },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_fan_mode",
                |m: &ClimateCommandRequest| { &m.has_fan_mode },
                |m: &mut ClimateCommandRequest| { &mut m.has_fan_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateFanMode>>(
                "fan_mode",
                |m: &ClimateCommandRequest| { &m.fan_mode },
                |m: &mut ClimateCommandRequest| { &mut m.fan_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_swing_mode",
                |m: &ClimateCommandRequest| { &m.has_swing_mode },
                |m: &mut ClimateCommandRequest| { &mut m.has_swing_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimateSwingMode>>(
                "swing_mode",
                |m: &ClimateCommandRequest| { &m.swing_mode },
                |m: &mut ClimateCommandRequest| { &mut m.swing_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_custom_fan_mode",
                |m: &ClimateCommandRequest| { &m.has_custom_fan_mode },
                |m: &mut ClimateCommandRequest| { &mut m.has_custom_fan_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "custom_fan_mode",
                |m: &ClimateCommandRequest| { &m.custom_fan_mode },
                |m: &mut ClimateCommandRequest| { &mut m.custom_fan_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_preset",
                |m: &ClimateCommandRequest| { &m.has_preset },
                |m: &mut ClimateCommandRequest| { &mut m.has_preset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClimatePreset>>(
                "preset",
                |m: &ClimateCommandRequest| { &m.preset },
                |m: &mut ClimateCommandRequest| { &mut m.preset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_custom_preset",
                |m: &ClimateCommandRequest| { &m.has_custom_preset },
                |m: &mut ClimateCommandRequest| { &mut m.has_custom_preset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "custom_preset",
                |m: &ClimateCommandRequest| { &m.custom_preset },
                |m: &mut ClimateCommandRequest| { &mut m.custom_preset },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClimateCommandRequest>(
                "ClimateCommandRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClimateCommandRequest {
        static instance: ::protobuf::rt::LazyV2<ClimateCommandRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClimateCommandRequest::new)
    }
}

impl ::protobuf::Clear for ClimateCommandRequest {
    fn clear(&mut self) {
        self.key = 0;
        self.has_mode = false;
        self.mode = ClimateMode::CLIMATE_MODE_OFF;
        self.has_target_temperature = false;
        self.target_temperature = 0.;
        self.has_target_temperature_low = false;
        self.target_temperature_low = 0.;
        self.has_target_temperature_high = false;
        self.target_temperature_high = 0.;
        self.has_legacy_away = false;
        self.legacy_away = false;
        self.has_fan_mode = false;
        self.fan_mode = ClimateFanMode::CLIMATE_FAN_ON;
        self.has_swing_mode = false;
        self.swing_mode = ClimateSwingMode::CLIMATE_SWING_OFF;
        self.has_custom_fan_mode = false;
        self.custom_fan_mode.clear();
        self.has_preset = false;
        self.preset = ClimatePreset::CLIMATE_PRESET_NONE;
        self.has_custom_preset = false;
        self.custom_preset.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClimateCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClimateCommandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesNumberResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub icon: ::std::string::String,
    pub min_value: f32,
    pub max_value: f32,
    pub step: f32,
    pub disabled_by_default: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesNumberResponse {
    fn default() -> &'a ListEntitiesNumberResponse {
        <ListEntitiesNumberResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesNumberResponse {
    pub fn new() -> ListEntitiesNumberResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // string icon = 5;


    pub fn get_icon(&self) -> &str {
        &self.icon
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        &mut self.icon
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.icon, ::std::string::String::new())
    }

    // float min_value = 6;


    pub fn get_min_value(&self) -> f32 {
        self.min_value
    }
    pub fn clear_min_value(&mut self) {
        self.min_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_min_value(&mut self, v: f32) {
        self.min_value = v;
    }

    // float max_value = 7;


    pub fn get_max_value(&self) -> f32 {
        self.max_value
    }
    pub fn clear_max_value(&mut self) {
        self.max_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max_value(&mut self, v: f32) {
        self.max_value = v;
    }

    // float step = 8;


    pub fn get_step(&self) -> f32 {
        self.step
    }
    pub fn clear_step(&mut self) {
        self.step = 0.;
    }

    // Param is passed by value, moved
    pub fn set_step(&mut self, v: f32) {
        self.step = v;
    }

    // bool disabled_by_default = 9;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }
}

impl ::protobuf::Message for ListEntitiesNumberResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.icon)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.min_value = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.max_value = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.step = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.min_value != 0. {
            my_size += 5;
        }
        if self.max_value != 0. {
            my_size += 5;
        }
        if self.step != 0. {
            my_size += 5;
        }
        if self.disabled_by_default != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.min_value != 0. {
            os.write_float(6, self.min_value)?;
        }
        if self.max_value != 0. {
            os.write_float(7, self.max_value)?;
        }
        if self.step != 0. {
            os.write_float(8, self.step)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(9, self.disabled_by_default)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesNumberResponse {
        ListEntitiesNumberResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesNumberResponse| { &m.object_id },
                |m: &mut ListEntitiesNumberResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesNumberResponse| { &m.key },
                |m: &mut ListEntitiesNumberResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesNumberResponse| { &m.name },
                |m: &mut ListEntitiesNumberResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesNumberResponse| { &m.unique_id },
                |m: &mut ListEntitiesNumberResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &ListEntitiesNumberResponse| { &m.icon },
                |m: &mut ListEntitiesNumberResponse| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "min_value",
                |m: &ListEntitiesNumberResponse| { &m.min_value },
                |m: &mut ListEntitiesNumberResponse| { &mut m.min_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "max_value",
                |m: &ListEntitiesNumberResponse| { &m.max_value },
                |m: &mut ListEntitiesNumberResponse| { &mut m.max_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "step",
                |m: &ListEntitiesNumberResponse| { &m.step },
                |m: &mut ListEntitiesNumberResponse| { &mut m.step },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesNumberResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesNumberResponse| { &mut m.disabled_by_default },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesNumberResponse>(
                "ListEntitiesNumberResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesNumberResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesNumberResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesNumberResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesNumberResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.min_value = 0.;
        self.max_value = 0.;
        self.step = 0.;
        self.disabled_by_default = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesNumberResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesNumberResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NumberStateResponse {
    // message fields
    pub key: u32,
    pub state: f32,
    pub missing_state: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NumberStateResponse {
    fn default() -> &'a NumberStateResponse {
        <NumberStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl NumberStateResponse {
    pub fn new() -> NumberStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // float state = 2;


    pub fn get_state(&self) -> f32 {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = 0.;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: f32) {
        self.state = v;
    }

    // bool missing_state = 3;


    pub fn get_missing_state(&self) -> bool {
        self.missing_state
    }
    pub fn clear_missing_state(&mut self) {
        self.missing_state = false;
    }

    // Param is passed by value, moved
    pub fn set_missing_state(&mut self, v: bool) {
        self.missing_state = v;
    }
}

impl ::protobuf::Message for NumberStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.state = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.missing_state = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.state != 0. {
            my_size += 5;
        }
        if self.missing_state != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != 0. {
            os.write_float(2, self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NumberStateResponse {
        NumberStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &NumberStateResponse| { &m.key },
                |m: &mut NumberStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "state",
                |m: &NumberStateResponse| { &m.state },
                |m: &mut NumberStateResponse| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "missing_state",
                |m: &NumberStateResponse| { &m.missing_state },
                |m: &mut NumberStateResponse| { &mut m.missing_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NumberStateResponse>(
                "NumberStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NumberStateResponse {
        static instance: ::protobuf::rt::LazyV2<NumberStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NumberStateResponse::new)
    }
}

impl ::protobuf::Clear for NumberStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.state = 0.;
        self.missing_state = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NumberStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NumberStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NumberCommandRequest {
    // message fields
    pub key: u32,
    pub state: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NumberCommandRequest {
    fn default() -> &'a NumberCommandRequest {
        <NumberCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl NumberCommandRequest {
    pub fn new() -> NumberCommandRequest {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // float state = 2;


    pub fn get_state(&self) -> f32 {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = 0.;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: f32) {
        self.state = v;
    }
}

impl ::protobuf::Message for NumberCommandRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.state = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if self.state != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != 0. {
            os.write_float(2, self.state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NumberCommandRequest {
        NumberCommandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &NumberCommandRequest| { &m.key },
                |m: &mut NumberCommandRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "state",
                |m: &NumberCommandRequest| { &m.state },
                |m: &mut NumberCommandRequest| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NumberCommandRequest>(
                "NumberCommandRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NumberCommandRequest {
        static instance: ::protobuf::rt::LazyV2<NumberCommandRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NumberCommandRequest::new)
    }
}

impl ::protobuf::Clear for NumberCommandRequest {
    fn clear(&mut self) {
        self.key = 0;
        self.state = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NumberCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NumberCommandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListEntitiesSelectResponse {
    // message fields
    pub object_id: ::std::string::String,
    pub key: u32,
    pub name: ::std::string::String,
    pub unique_id: ::std::string::String,
    pub icon: ::std::string::String,
    pub options: ::protobuf::RepeatedField<::std::string::String>,
    pub disabled_by_default: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListEntitiesSelectResponse {
    fn default() -> &'a ListEntitiesSelectResponse {
        <ListEntitiesSelectResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesSelectResponse {
    pub fn new() -> ListEntitiesSelectResponse {
        ::std::default::Default::default()
    }

    // string object_id = 1;


    pub fn get_object_id(&self) -> &str {
        &self.object_id
    }
    pub fn clear_object_id(&mut self) {
        self.object_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_object_id(&mut self, v: ::std::string::String) {
        self.object_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_id(&mut self) -> &mut ::std::string::String {
        &mut self.object_id
    }

    // Take field
    pub fn take_object_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.object_id, ::std::string::String::new())
    }

    // fixed32 key = 2;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string unique_id = 4;


    pub fn get_unique_id(&self) -> &str {
        &self.unique_id
    }
    pub fn clear_unique_id(&mut self) {
        self.unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: ::std::string::String) {
        self.unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.unique_id
    }

    // Take field
    pub fn take_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unique_id, ::std::string::String::new())
    }

    // string icon = 5;


    pub fn get_icon(&self) -> &str {
        &self.icon
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        &mut self.icon
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.icon, ::std::string::String::new())
    }

    // repeated string options = 6;


    pub fn get_options(&self) -> &[::std::string::String] {
        &self.options
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.options, ::protobuf::RepeatedField::new())
    }

    // bool disabled_by_default = 7;


    pub fn get_disabled_by_default(&self) -> bool {
        self.disabled_by_default
    }
    pub fn clear_disabled_by_default(&mut self) {
        self.disabled_by_default = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled_by_default(&mut self, v: bool) {
        self.disabled_by_default = v;
    }
}

impl ::protobuf::Message for ListEntitiesSelectResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.object_id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unique_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.icon)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.options)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled_by_default = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 5;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        for value in &self.options {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if self.disabled_by_default != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        for v in &self.options {
            os.write_string(6, &v)?;
        };
        if self.disabled_by_default != false {
            os.write_bool(7, self.disabled_by_default)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListEntitiesSelectResponse {
        ListEntitiesSelectResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "object_id",
                |m: &ListEntitiesSelectResponse| { &m.object_id },
                |m: &mut ListEntitiesSelectResponse| { &mut m.object_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &ListEntitiesSelectResponse| { &m.key },
                |m: &mut ListEntitiesSelectResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListEntitiesSelectResponse| { &m.name },
                |m: &mut ListEntitiesSelectResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unique_id",
                |m: &ListEntitiesSelectResponse| { &m.unique_id },
                |m: &mut ListEntitiesSelectResponse| { &mut m.unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "icon",
                |m: &ListEntitiesSelectResponse| { &m.icon },
                |m: &mut ListEntitiesSelectResponse| { &mut m.icon },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "options",
                |m: &ListEntitiesSelectResponse| { &m.options },
                |m: &mut ListEntitiesSelectResponse| { &mut m.options },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled_by_default",
                |m: &ListEntitiesSelectResponse| { &m.disabled_by_default },
                |m: &mut ListEntitiesSelectResponse| { &mut m.disabled_by_default },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListEntitiesSelectResponse>(
                "ListEntitiesSelectResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListEntitiesSelectResponse {
        static instance: ::protobuf::rt::LazyV2<ListEntitiesSelectResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListEntitiesSelectResponse::new)
    }
}

impl ::protobuf::Clear for ListEntitiesSelectResponse {
    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.options.clear();
        self.disabled_by_default = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListEntitiesSelectResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesSelectResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SelectStateResponse {
    // message fields
    pub key: u32,
    pub state: ::std::string::String,
    pub missing_state: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SelectStateResponse {
    fn default() -> &'a SelectStateResponse {
        <SelectStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SelectStateResponse {
    pub fn new() -> SelectStateResponse {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string state = 2;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }

    // bool missing_state = 3;


    pub fn get_missing_state(&self) -> bool {
        self.missing_state
    }
    pub fn clear_missing_state(&mut self) {
        self.missing_state = false;
    }

    // Param is passed by value, moved
    pub fn set_missing_state(&mut self, v: bool) {
        self.missing_state = v;
    }
}

impl ::protobuf::Message for SelectStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.missing_state = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state);
        }
        if self.missing_state != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if !self.state.is_empty() {
            os.write_string(2, &self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SelectStateResponse {
        SelectStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &SelectStateResponse| { &m.key },
                |m: &mut SelectStateResponse| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state",
                |m: &SelectStateResponse| { &m.state },
                |m: &mut SelectStateResponse| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "missing_state",
                |m: &SelectStateResponse| { &m.missing_state },
                |m: &mut SelectStateResponse| { &mut m.missing_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SelectStateResponse>(
                "SelectStateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SelectStateResponse {
        static instance: ::protobuf::rt::LazyV2<SelectStateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SelectStateResponse::new)
    }
}

impl ::protobuf::Clear for SelectStateResponse {
    fn clear(&mut self) {
        self.key = 0;
        self.state.clear();
        self.missing_state = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SelectStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SelectCommandRequest {
    // message fields
    pub key: u32,
    pub state: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SelectCommandRequest {
    fn default() -> &'a SelectCommandRequest {
        <SelectCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl SelectCommandRequest {
    pub fn new() -> SelectCommandRequest {
        ::std::default::Default::default()
    }

    // fixed32 key = 1;


    pub fn get_key(&self) -> u32 {
        self.key
    }
    pub fn clear_key(&mut self) {
        self.key = 0;
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: u32) {
        self.key = v;
    }

    // string state = 2;


    pub fn get_state(&self) -> &str {
        &self.state
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        &mut self.state
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.state, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SelectCommandRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.key = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 5;
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if !self.state.is_empty() {
            os.write_string(2, &self.state)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SelectCommandRequest {
        SelectCommandRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "key",
                |m: &SelectCommandRequest| { &m.key },
                |m: &mut SelectCommandRequest| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state",
                |m: &SelectCommandRequest| { &m.state },
                |m: &mut SelectCommandRequest| { &mut m.state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SelectCommandRequest>(
                "SelectCommandRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SelectCommandRequest {
        static instance: ::protobuf::rt::LazyV2<SelectCommandRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SelectCommandRequest::new)
    }
}

impl ::protobuf::Clear for SelectCommandRequest {
    fn clear(&mut self) {
        self.key = 0;
        self.state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SelectCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectCommandRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LegacyCoverState {
    LEGACY_COVER_STATE_OPEN = 0,
    LEGACY_COVER_STATE_CLOSED = 1,
}

impl ::protobuf::ProtobufEnum for LegacyCoverState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LegacyCoverState> {
        match value {
            0 => ::std::option::Option::Some(LegacyCoverState::LEGACY_COVER_STATE_OPEN),
            1 => ::std::option::Option::Some(LegacyCoverState::LEGACY_COVER_STATE_CLOSED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LegacyCoverState] = &[
            LegacyCoverState::LEGACY_COVER_STATE_OPEN,
            LegacyCoverState::LEGACY_COVER_STATE_CLOSED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<LegacyCoverState>("LegacyCoverState", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for LegacyCoverState {
}

impl ::std::default::Default for LegacyCoverState {
    fn default() -> Self {
        LegacyCoverState::LEGACY_COVER_STATE_OPEN
    }
}

impl ::protobuf::reflect::ProtobufValue for LegacyCoverState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CoverOperation {
    COVER_OPERATION_IDLE = 0,
    COVER_OPERATION_IS_OPENING = 1,
    COVER_OPERATION_IS_CLOSING = 2,
}

impl ::protobuf::ProtobufEnum for CoverOperation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CoverOperation> {
        match value {
            0 => ::std::option::Option::Some(CoverOperation::COVER_OPERATION_IDLE),
            1 => ::std::option::Option::Some(CoverOperation::COVER_OPERATION_IS_OPENING),
            2 => ::std::option::Option::Some(CoverOperation::COVER_OPERATION_IS_CLOSING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CoverOperation] = &[
            CoverOperation::COVER_OPERATION_IDLE,
            CoverOperation::COVER_OPERATION_IS_OPENING,
            CoverOperation::COVER_OPERATION_IS_CLOSING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CoverOperation>("CoverOperation", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CoverOperation {
}

impl ::std::default::Default for CoverOperation {
    fn default() -> Self {
        CoverOperation::COVER_OPERATION_IDLE
    }
}

impl ::protobuf::reflect::ProtobufValue for CoverOperation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LegacyCoverCommand {
    LEGACY_COVER_COMMAND_OPEN = 0,
    LEGACY_COVER_COMMAND_CLOSE = 1,
    LEGACY_COVER_COMMAND_STOP = 2,
}

impl ::protobuf::ProtobufEnum for LegacyCoverCommand {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LegacyCoverCommand> {
        match value {
            0 => ::std::option::Option::Some(LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN),
            1 => ::std::option::Option::Some(LegacyCoverCommand::LEGACY_COVER_COMMAND_CLOSE),
            2 => ::std::option::Option::Some(LegacyCoverCommand::LEGACY_COVER_COMMAND_STOP),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LegacyCoverCommand] = &[
            LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN,
            LegacyCoverCommand::LEGACY_COVER_COMMAND_CLOSE,
            LegacyCoverCommand::LEGACY_COVER_COMMAND_STOP,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<LegacyCoverCommand>("LegacyCoverCommand", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for LegacyCoverCommand {
}

impl ::std::default::Default for LegacyCoverCommand {
    fn default() -> Self {
        LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN
    }
}

impl ::protobuf::reflect::ProtobufValue for LegacyCoverCommand {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FanSpeed {
    FAN_SPEED_LOW = 0,
    FAN_SPEED_MEDIUM = 1,
    FAN_SPEED_HIGH = 2,
}

impl ::protobuf::ProtobufEnum for FanSpeed {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FanSpeed> {
        match value {
            0 => ::std::option::Option::Some(FanSpeed::FAN_SPEED_LOW),
            1 => ::std::option::Option::Some(FanSpeed::FAN_SPEED_MEDIUM),
            2 => ::std::option::Option::Some(FanSpeed::FAN_SPEED_HIGH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FanSpeed] = &[
            FanSpeed::FAN_SPEED_LOW,
            FanSpeed::FAN_SPEED_MEDIUM,
            FanSpeed::FAN_SPEED_HIGH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FanSpeed>("FanSpeed", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FanSpeed {
}

impl ::std::default::Default for FanSpeed {
    fn default() -> Self {
        FanSpeed::FAN_SPEED_LOW
    }
}

impl ::protobuf::reflect::ProtobufValue for FanSpeed {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FanDirection {
    FAN_DIRECTION_FORWARD = 0,
    FAN_DIRECTION_REVERSE = 1,
}

impl ::protobuf::ProtobufEnum for FanDirection {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FanDirection> {
        match value {
            0 => ::std::option::Option::Some(FanDirection::FAN_DIRECTION_FORWARD),
            1 => ::std::option::Option::Some(FanDirection::FAN_DIRECTION_REVERSE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FanDirection] = &[
            FanDirection::FAN_DIRECTION_FORWARD,
            FanDirection::FAN_DIRECTION_REVERSE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FanDirection>("FanDirection", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FanDirection {
}

impl ::std::default::Default for FanDirection {
    fn default() -> Self {
        FanDirection::FAN_DIRECTION_FORWARD
    }
}

impl ::protobuf::reflect::ProtobufValue for FanDirection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ColorMode {
    COLOR_MODE_UNKNOWN = 0,
    COLOR_MODE_ON_OFF = 1,
    COLOR_MODE_BRIGHTNESS = 2,
    COLOR_MODE_WHITE = 7,
    COLOR_MODE_COLOR_TEMPERATURE = 11,
    COLOR_MODE_COLD_WARM_WHITE = 19,
    COLOR_MODE_RGB = 35,
    COLOR_MODE_RGB_WHITE = 39,
    COLOR_MODE_RGB_COLOR_TEMPERATURE = 47,
    COLOR_MODE_RGB_COLD_WARM_WHITE = 51,
}

impl ::protobuf::ProtobufEnum for ColorMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ColorMode> {
        match value {
            0 => ::std::option::Option::Some(ColorMode::COLOR_MODE_UNKNOWN),
            1 => ::std::option::Option::Some(ColorMode::COLOR_MODE_ON_OFF),
            2 => ::std::option::Option::Some(ColorMode::COLOR_MODE_BRIGHTNESS),
            7 => ::std::option::Option::Some(ColorMode::COLOR_MODE_WHITE),
            11 => ::std::option::Option::Some(ColorMode::COLOR_MODE_COLOR_TEMPERATURE),
            19 => ::std::option::Option::Some(ColorMode::COLOR_MODE_COLD_WARM_WHITE),
            35 => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB),
            39 => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB_WHITE),
            47 => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB_COLOR_TEMPERATURE),
            51 => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB_COLD_WARM_WHITE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ColorMode] = &[
            ColorMode::COLOR_MODE_UNKNOWN,
            ColorMode::COLOR_MODE_ON_OFF,
            ColorMode::COLOR_MODE_BRIGHTNESS,
            ColorMode::COLOR_MODE_WHITE,
            ColorMode::COLOR_MODE_COLOR_TEMPERATURE,
            ColorMode::COLOR_MODE_COLD_WARM_WHITE,
            ColorMode::COLOR_MODE_RGB,
            ColorMode::COLOR_MODE_RGB_WHITE,
            ColorMode::COLOR_MODE_RGB_COLOR_TEMPERATURE,
            ColorMode::COLOR_MODE_RGB_COLD_WARM_WHITE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ColorMode>("ColorMode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ColorMode {
}

impl ::std::default::Default for ColorMode {
    fn default() -> Self {
        ColorMode::COLOR_MODE_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for ColorMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SensorStateClass {
    STATE_CLASS_NONE = 0,
    STATE_CLASS_MEASUREMENT = 1,
}

impl ::protobuf::ProtobufEnum for SensorStateClass {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SensorStateClass> {
        match value {
            0 => ::std::option::Option::Some(SensorStateClass::STATE_CLASS_NONE),
            1 => ::std::option::Option::Some(SensorStateClass::STATE_CLASS_MEASUREMENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SensorStateClass] = &[
            SensorStateClass::STATE_CLASS_NONE,
            SensorStateClass::STATE_CLASS_MEASUREMENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SensorStateClass>("SensorStateClass", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SensorStateClass {
}

impl ::std::default::Default for SensorStateClass {
    fn default() -> Self {
        SensorStateClass::STATE_CLASS_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for SensorStateClass {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SensorLastResetType {
    LAST_RESET_NONE = 0,
    LAST_RESET_NEVER = 1,
    LAST_RESET_AUTO = 2,
}

impl ::protobuf::ProtobufEnum for SensorLastResetType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SensorLastResetType> {
        match value {
            0 => ::std::option::Option::Some(SensorLastResetType::LAST_RESET_NONE),
            1 => ::std::option::Option::Some(SensorLastResetType::LAST_RESET_NEVER),
            2 => ::std::option::Option::Some(SensorLastResetType::LAST_RESET_AUTO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SensorLastResetType] = &[
            SensorLastResetType::LAST_RESET_NONE,
            SensorLastResetType::LAST_RESET_NEVER,
            SensorLastResetType::LAST_RESET_AUTO,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SensorLastResetType>("SensorLastResetType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SensorLastResetType {
}

impl ::std::default::Default for SensorLastResetType {
    fn default() -> Self {
        SensorLastResetType::LAST_RESET_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for SensorLastResetType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LogLevel {
    LOG_LEVEL_NONE = 0,
    LOG_LEVEL_ERROR = 1,
    LOG_LEVEL_WARN = 2,
    LOG_LEVEL_INFO = 3,
    LOG_LEVEL_DEBUG = 4,
    LOG_LEVEL_VERBOSE = 5,
    LOG_LEVEL_VERY_VERBOSE = 6,
}

impl ::protobuf::ProtobufEnum for LogLevel {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LogLevel> {
        match value {
            0 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_NONE),
            1 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_ERROR),
            2 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_WARN),
            3 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_INFO),
            4 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_DEBUG),
            5 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_VERBOSE),
            6 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_VERY_VERBOSE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LogLevel] = &[
            LogLevel::LOG_LEVEL_NONE,
            LogLevel::LOG_LEVEL_ERROR,
            LogLevel::LOG_LEVEL_WARN,
            LogLevel::LOG_LEVEL_INFO,
            LogLevel::LOG_LEVEL_DEBUG,
            LogLevel::LOG_LEVEL_VERBOSE,
            LogLevel::LOG_LEVEL_VERY_VERBOSE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<LogLevel>("LogLevel", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for LogLevel {
}

impl ::std::default::Default for LogLevel {
    fn default() -> Self {
        LogLevel::LOG_LEVEL_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for LogLevel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ServiceArgType {
    SERVICE_ARG_TYPE_BOOL = 0,
    SERVICE_ARG_TYPE_INT = 1,
    SERVICE_ARG_TYPE_FLOAT = 2,
    SERVICE_ARG_TYPE_STRING = 3,
    SERVICE_ARG_TYPE_BOOL_ARRAY = 4,
    SERVICE_ARG_TYPE_INT_ARRAY = 5,
    SERVICE_ARG_TYPE_FLOAT_ARRAY = 6,
    SERVICE_ARG_TYPE_STRING_ARRAY = 7,
}

impl ::protobuf::ProtobufEnum for ServiceArgType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ServiceArgType> {
        match value {
            0 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_BOOL),
            1 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_INT),
            2 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_FLOAT),
            3 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_STRING),
            4 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_BOOL_ARRAY),
            5 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_INT_ARRAY),
            6 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_FLOAT_ARRAY),
            7 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_STRING_ARRAY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ServiceArgType] = &[
            ServiceArgType::SERVICE_ARG_TYPE_BOOL,
            ServiceArgType::SERVICE_ARG_TYPE_INT,
            ServiceArgType::SERVICE_ARG_TYPE_FLOAT,
            ServiceArgType::SERVICE_ARG_TYPE_STRING,
            ServiceArgType::SERVICE_ARG_TYPE_BOOL_ARRAY,
            ServiceArgType::SERVICE_ARG_TYPE_INT_ARRAY,
            ServiceArgType::SERVICE_ARG_TYPE_FLOAT_ARRAY,
            ServiceArgType::SERVICE_ARG_TYPE_STRING_ARRAY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ServiceArgType>("ServiceArgType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ServiceArgType {
}

impl ::std::default::Default for ServiceArgType {
    fn default() -> Self {
        ServiceArgType::SERVICE_ARG_TYPE_BOOL
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceArgType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClimateMode {
    CLIMATE_MODE_OFF = 0,
    CLIMATE_MODE_HEAT_COOL = 1,
    CLIMATE_MODE_COOL = 2,
    CLIMATE_MODE_HEAT = 3,
    CLIMATE_MODE_FAN_ONLY = 4,
    CLIMATE_MODE_DRY = 5,
    CLIMATE_MODE_AUTO = 6,
}

impl ::protobuf::ProtobufEnum for ClimateMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimateMode> {
        match value {
            0 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_OFF),
            1 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_HEAT_COOL),
            2 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_COOL),
            3 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_HEAT),
            4 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_FAN_ONLY),
            5 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_DRY),
            6 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_AUTO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClimateMode] = &[
            ClimateMode::CLIMATE_MODE_OFF,
            ClimateMode::CLIMATE_MODE_HEAT_COOL,
            ClimateMode::CLIMATE_MODE_COOL,
            ClimateMode::CLIMATE_MODE_HEAT,
            ClimateMode::CLIMATE_MODE_FAN_ONLY,
            ClimateMode::CLIMATE_MODE_DRY,
            ClimateMode::CLIMATE_MODE_AUTO,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ClimateMode>("ClimateMode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ClimateMode {
}

impl ::std::default::Default for ClimateMode {
    fn default() -> Self {
        ClimateMode::CLIMATE_MODE_OFF
    }
}

impl ::protobuf::reflect::ProtobufValue for ClimateMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClimateFanMode {
    CLIMATE_FAN_ON = 0,
    CLIMATE_FAN_OFF = 1,
    CLIMATE_FAN_AUTO = 2,
    CLIMATE_FAN_LOW = 3,
    CLIMATE_FAN_MEDIUM = 4,
    CLIMATE_FAN_HIGH = 5,
    CLIMATE_FAN_MIDDLE = 6,
    CLIMATE_FAN_FOCUS = 7,
    CLIMATE_FAN_DIFFUSE = 8,
}

impl ::protobuf::ProtobufEnum for ClimateFanMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimateFanMode> {
        match value {
            0 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_ON),
            1 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_OFF),
            2 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_AUTO),
            3 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_LOW),
            4 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_MEDIUM),
            5 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_HIGH),
            6 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_MIDDLE),
            7 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_FOCUS),
            8 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_DIFFUSE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClimateFanMode] = &[
            ClimateFanMode::CLIMATE_FAN_ON,
            ClimateFanMode::CLIMATE_FAN_OFF,
            ClimateFanMode::CLIMATE_FAN_AUTO,
            ClimateFanMode::CLIMATE_FAN_LOW,
            ClimateFanMode::CLIMATE_FAN_MEDIUM,
            ClimateFanMode::CLIMATE_FAN_HIGH,
            ClimateFanMode::CLIMATE_FAN_MIDDLE,
            ClimateFanMode::CLIMATE_FAN_FOCUS,
            ClimateFanMode::CLIMATE_FAN_DIFFUSE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ClimateFanMode>("ClimateFanMode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ClimateFanMode {
}

impl ::std::default::Default for ClimateFanMode {
    fn default() -> Self {
        ClimateFanMode::CLIMATE_FAN_ON
    }
}

impl ::protobuf::reflect::ProtobufValue for ClimateFanMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClimateSwingMode {
    CLIMATE_SWING_OFF = 0,
    CLIMATE_SWING_BOTH = 1,
    CLIMATE_SWING_VERTICAL = 2,
    CLIMATE_SWING_HORIZONTAL = 3,
}

impl ::protobuf::ProtobufEnum for ClimateSwingMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimateSwingMode> {
        match value {
            0 => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_OFF),
            1 => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_BOTH),
            2 => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_VERTICAL),
            3 => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_HORIZONTAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClimateSwingMode] = &[
            ClimateSwingMode::CLIMATE_SWING_OFF,
            ClimateSwingMode::CLIMATE_SWING_BOTH,
            ClimateSwingMode::CLIMATE_SWING_VERTICAL,
            ClimateSwingMode::CLIMATE_SWING_HORIZONTAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ClimateSwingMode>("ClimateSwingMode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ClimateSwingMode {
}

impl ::std::default::Default for ClimateSwingMode {
    fn default() -> Self {
        ClimateSwingMode::CLIMATE_SWING_OFF
    }
}

impl ::protobuf::reflect::ProtobufValue for ClimateSwingMode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClimateAction {
    CLIMATE_ACTION_OFF = 0,
    CLIMATE_ACTION_COOLING = 2,
    CLIMATE_ACTION_HEATING = 3,
    CLIMATE_ACTION_IDLE = 4,
    CLIMATE_ACTION_DRYING = 5,
    CLIMATE_ACTION_FAN = 6,
}

impl ::protobuf::ProtobufEnum for ClimateAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimateAction> {
        match value {
            0 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_OFF),
            2 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_COOLING),
            3 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_HEATING),
            4 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_IDLE),
            5 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_DRYING),
            6 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_FAN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClimateAction] = &[
            ClimateAction::CLIMATE_ACTION_OFF,
            ClimateAction::CLIMATE_ACTION_COOLING,
            ClimateAction::CLIMATE_ACTION_HEATING,
            ClimateAction::CLIMATE_ACTION_IDLE,
            ClimateAction::CLIMATE_ACTION_DRYING,
            ClimateAction::CLIMATE_ACTION_FAN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ClimateAction>("ClimateAction", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ClimateAction {
}

impl ::std::default::Default for ClimateAction {
    fn default() -> Self {
        ClimateAction::CLIMATE_ACTION_OFF
    }
}

impl ::protobuf::reflect::ProtobufValue for ClimateAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClimatePreset {
    CLIMATE_PRESET_NONE = 0,
    CLIMATE_PRESET_HOME = 1,
    CLIMATE_PRESET_AWAY = 2,
    CLIMATE_PRESET_BOOST = 3,
    CLIMATE_PRESET_COMFORT = 4,
    CLIMATE_PRESET_ECO = 5,
    CLIMATE_PRESET_SLEEP = 6,
    CLIMATE_PRESET_ACTIVITY = 7,
}

impl ::protobuf::ProtobufEnum for ClimatePreset {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimatePreset> {
        match value {
            0 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_NONE),
            1 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_HOME),
            2 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_AWAY),
            3 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_BOOST),
            4 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_COMFORT),
            5 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_ECO),
            6 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_SLEEP),
            7 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_ACTIVITY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClimatePreset] = &[
            ClimatePreset::CLIMATE_PRESET_NONE,
            ClimatePreset::CLIMATE_PRESET_HOME,
            ClimatePreset::CLIMATE_PRESET_AWAY,
            ClimatePreset::CLIMATE_PRESET_BOOST,
            ClimatePreset::CLIMATE_PRESET_COMFORT,
            ClimatePreset::CLIMATE_PRESET_ECO,
            ClimatePreset::CLIMATE_PRESET_SLEEP,
            ClimatePreset::CLIMATE_PRESET_ACTIVITY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ClimatePreset>("ClimatePreset", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ClimatePreset {
}

impl ::std::default::Default for ClimatePreset {
    fn default() -> Self {
        ClimatePreset::CLIMATE_PRESET_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for ClimatePreset {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tapi.proto\x1a\x11api_options.proto\"9\n\x0cHelloRequest\x12!\n\x0bcl\
    ient_info\x18\x01\x20\x01(\tR\nclientInfoB\0:\x06\xe0@\x01\x80A\x01\"\
    \x96\x01\n\rHelloResponse\x12,\n\x11api_version_major\x18\x01\x20\x01(\r\
    R\x0fapiVersionMajorB\0\x12,\n\x11api_version_minor\x18\x02\x20\x01(\rR\
    \x0fapiVersionMinorB\0\x12!\n\x0bserver_info\x18\x03\x20\x01(\tR\nserver\
    InfoB\0:\x06\xe0@\x02\x80A\x01\"6\n\x0eConnectRequest\x12\x1c\n\x08passw\
    ord\x18\x01\x20\x01(\tR\x08passwordB\0:\x06\x80A\x01\xe0@\x03\"F\n\x0fCo\
    nnectResponse\x12+\n\x10invalid_password\x18\x01\x20\x01(\x08R\x0finvali\
    dPasswordB\0:\x06\xe0@\x04\x80A\x01\"\x1b\n\x11DisconnectRequest:\x06\
    \x80A\x01\xe0@\x05\"\x1c\n\x12DisconnectResponse:\x06\xe0@\x06\x80A\x01\
    \"\x12\n\x0bPingRequest:\x03\xe0@\x07\"\x13\n\x0cPingResponse:\x03\xe0@\
    \x08\"\x18\n\x11DeviceInfoRequest:\x03\xe0@\t\"\xe1\x02\n\x12DeviceInfoR\
    esponse\x12%\n\ruses_password\x18\x01\x20\x01(\x08R\x0cusesPasswordB\0\
    \x12\x14\n\x04name\x18\x02\x20\x01(\tR\x04nameB\0\x12!\n\x0bmac_address\
    \x18\x03\x20\x01(\tR\nmacAddressB\0\x12)\n\x0fesphome_version\x18\x04\
    \x20\x01(\tR\x0eesphomeVersionB\0\x12+\n\x10compilation_time\x18\x05\x20\
    \x01(\tR\x0fcompilationTimeB\0\x12\x16\n\x05model\x18\x06\x20\x01(\tR\
    \x05modelB\0\x12&\n\x0ehas_deep_sleep\x18\x07\x20\x01(\x08R\x0chasDeepSl\
    eepB\0\x12#\n\x0cproject_name\x18\x08\x20\x01(\tR\x0bprojectNameB\0\x12)\
    \n\x0fproject_version\x18\t\x20\x01(\tR\x0eprojectVersionB\0:\x03\xe0@\n\
    \"\x1a\n\x13ListEntitiesRequest:\x03\xe0@\x0b\"\"\n\x18ListEntitiesDoneR\
    esponse:\x06\xe0@\x13\x80A\x01\"\x1d\n\x16SubscribeStatesRequest:\x03\
    \xe0@\x14\"\xb3\x02\n\x20ListEntitiesBinarySensorResponse\x12\x1d\n\tobj\
    ect_id\x18\x01\x20\x01(\tR\x08objectIdB\0\x12\x12\n\x03key\x18\x02\x20\
    \x01(\x07R\x03keyB\0\x12\x14\n\x04name\x18\x03\x20\x01(\tR\x04nameB\0\
    \x12\x1d\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueIdB\0\x12#\n\x0cdevic\
    e_class\x18\x05\x20\x01(\tR\x0bdeviceClassB\0\x127\n\x17is_status_binary\
    _sensor\x18\x06\x20\x01(\x08R\x14isStatusBinarySensorB\0\x120\n\x13disab\
    led_by_default\x18\x07\x20\x01(\x08R\x11disabledByDefaultB\0:\x17\xe0@\
    \x0c\xf2@\x11USE_BINARY_SENSOR\"\x8a\x01\n\x19BinarySensorStateResponse\
    \x12\x12\n\x03key\x18\x01\x20\x01(\x07R\x03keyB\0\x12\x16\n\x05state\x18\
    \x02\x20\x01(\x08R\x05stateB\0\x12%\n\rmissing_state\x18\x03\x20\x01(\
    \x08R\x0cmissingStateB\0:\x1a\x80A\x01\xe0@\x15\xf2@\x11USE_BINARY_SENSO\
    R\"\xe8\x02\n\x19ListEntitiesCoverResponse\x12\x1d\n\tobject_id\x18\x01\
    \x20\x01(\tR\x08objectIdB\0\x12\x12\n\x03key\x18\x02\x20\x01(\x07R\x03ke\
    yB\0\x12\x14\n\x04name\x18\x03\x20\x01(\tR\x04nameB\0\x12\x1d\n\tunique_\
    id\x18\x04\x20\x01(\tR\x08uniqueIdB\0\x12%\n\rassumed_state\x18\x05\x20\
    \x01(\x08R\x0cassumedStateB\0\x12-\n\x11supports_position\x18\x06\x20\
    \x01(\x08R\x10supportsPositionB\0\x12%\n\rsupports_tilt\x18\x07\x20\x01(\
    \x08R\x0csupportsTiltB\0\x12#\n\x0cdevice_class\x18\x08\x20\x01(\tR\x0bd\
    eviceClassB\0\x120\n\x13disabled_by_default\x18\t\x20\x01(\x08R\x11disab\
    ledByDefaultB\0:\x0f\xe0@\r\xf2@\tUSE_COVER\"\xe8\x01\n\x12CoverStateRes\
    ponse\x12\x12\n\x03key\x18\x01\x20\x01(\x07R\x03keyB\0\x126\n\x0clegacy_\
    state\x18\x02\x20\x01(\x0e2\x11.LegacyCoverStateR\x0blegacyStateB\0\x12\
    \x1c\n\x08position\x18\x03\x20\x01(\x02R\x08positionB\0\x12\x14\n\x04til\
    t\x18\x04\x20\x01(\x02R\x04tiltB\0\x12>\n\x11current_operation\x18\x05\
    \x20\x01(\x0e2\x0f.CoverOperationR\x10currentOperationB\0:\x12\xf2@\tUSE\
    _COVER\xe0@\x16\x80A\x01\"\xb7\x02\n\x13CoverCommandRequest\x12\x12\n\
    \x03key\x18\x01\x20\x01(\x07R\x03keyB\0\x12.\n\x12has_legacy_command\x18\
    \x02\x20\x01(\x08R\x10hasLegacyCommandB\0\x12<\n\x0elegacy_command\x18\
    \x03\x20\x01(\x0e2\x13.LegacyCoverCommandR\rlegacyCommandB\0\x12#\n\x0ch\
    as_position\x18\x04\x20\x01(\x08R\x0bhasPositionB\0\x12\x1c\n\x08positio\
    n\x18\x05\x20\x01(\x02R\x08positionB\0\x12\x1b\n\x08has_tilt\x18\x06\x20\
    \x01(\x08R\x07hasTiltB\0\x12\x14\n\x04tilt\x18\x07\x20\x01(\x02R\x04tilt\
    B\0\x12\x14\n\x04stop\x18\x08\x20\x01(\x08R\x04stopB\0:\x12\x80A\x01\xf2\
    @\tUSE_COVER\xe0@\x1e\"\x89\x03\n\x17ListEntitiesFanResponse\x12\x1d\n\t\
    object_id\x18\x01\x20\x01(\tR\x08objectIdB\0\x12\x12\n\x03key\x18\x02\
    \x20\x01(\x07R\x03keyB\0\x12\x14\n\x04name\x18\x03\x20\x01(\tR\x04nameB\
    \0\x12\x1d\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueIdB\0\x123\n\x14sup\
    ports_oscillation\x18\x05\x20\x01(\x08R\x13supportsOscillationB\0\x12'\n\
    \x0esupports_speed\x18\x06\x20\x01(\x08R\rsupportsSpeedB\0\x12/\n\x12sup\
    ports_direction\x18\x07\x20\x01(\x08R\x11supportsDirectionB\0\x126\n\x16\
    supported_speed_levels\x18\x08\x20\x01(\x05R\x14supportedSpeedLevelsB\0\
    \x120\n\x13disabled_by_default\x18\t\x20\x01(\x08R\x11disabledByDefaultB\
    \0:\r\xf2@\x07USE_FAN\xe0@\x0e\"\xeb\x01\n\x10FanStateResponse\x12\x12\n\
    \x03key\x18\x01\x20\x01(\x07R\x03keyB\0\x12\x16\n\x05state\x18\x02\x20\
    \x01(\x08R\x05stateB\0\x12\"\n\x0boscillating\x18\x03\x20\x01(\x08R\x0bo\
    scillatingB\0\x12#\n\x05speed\x18\x04\x20\x01(\x0e2\t.FanSpeedR\x05speed\
    B\x02\x18\x01\x12-\n\tdirection\x18\x05\x20\x01(\x0e2\r.FanDirectionR\td\
    irectionB\0\x12!\n\x0bspeed_level\x18\x06\x20\x01(\x05R\nspeedLevelB\0:\
    \x10\xf2@\x07USE_FAN\x80A\x01\xe0@\x17\"\xa8\x03\n\x11FanCommandRequest\
    \x12\x12\n\x03key\x18\x01\x20\x01(\x07R\x03keyB\0\x12\x1d\n\thas_state\
    \x18\x02\x20\x01(\x08R\x08hasStateB\0\x12\x16\n\x05state\x18\x03\x20\x01\
    (\x08R\x05stateB\0\x12\x1f\n\thas_speed\x18\x04\x20\x01(\x08R\x08hasSpee\
    dB\x02\x18\x01\x12#\n\x05speed\x18\x05\x20\x01(\x0e2\t.FanSpeedR\x05spee\
    dB\x02\x18\x01\x12)\n\x0fhas_oscillating\x18\x06\x20\x01(\x08R\x0ehasOsc\
    illatingB\0\x12\"\n\x0boscillating\x18\x07\x20\x01(\x08R\x0boscillatingB\
    \0\x12%\n\rhas_direction\x18\x08\x20\x01(\x08R\x0chasDirectionB\0\x12-\n\
    \tdirection\x18\t\x20\x01(\x0e2\r.FanDirectionR\tdirectionB\0\x12(\n\x0f\
    has_speed_level\x18\n\x20\x01(\x08R\rhasSpeedLevelB\0\x12!\n\x0bspeed_le\
    vel\x18\x0b\x20\x01(\x05R\nspeedLevelB\0:\x10\xf2@\x07USE_FAN\x80A\x01\
    \xe0@\x1f\"\xee\x04\n\x19ListEntitiesLightResponse\x12\x1d\n\tobject_id\
    \x18\x01\x20\x01(\tR\x08objectIdB\0\x12\x12\n\x03key\x18\x02\x20\x01(\
    \x07R\x03keyB\0\x12\x14\n\x04name\x18\x03\x20\x01(\tR\x04nameB\0\x12\x1d\
    \n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueIdB\0\x12@\n\x15supported_col\
    or_modes\x18\x0c\x20\x03(\x0e2\n.ColorModeR\x13supportedColorModesB\0\
    \x12@\n\x1alegacy_supports_brightness\x18\x05\x20\x01(\x08R\x18legacySup\
    portsBrightnessB\x02\x18\x01\x122\n\x13legacy_supports_rgb\x18\x06\x20\
    \x01(\x08R\x11legacySupportsRgbB\x02\x18\x01\x12A\n\x1blegacy_supports_w\
    hite_value\x18\x07\x20\x01(\x08R\x18legacySupportsWhiteValueB\x02\x18\
    \x01\x12M\n!legacy_supports_color_temperature\x18\x08\x20\x01(\x08R\x1el\
    egacySupportsColorTemperatureB\x02\x18\x01\x12\x1f\n\nmin_mireds\x18\t\
    \x20\x01(\x02R\tminMiredsB\0\x12\x1f\n\nmax_mireds\x18\n\x20\x01(\x02R\t\
    maxMiredsB\0\x12\x1a\n\x07effects\x18\x0b\x20\x03(\tR\x07effectsB\0\x120\
    \n\x13disabled_by_default\x18\r\x20\x01(\x08R\x11disabledByDefaultB\0:\
    \x0f\xf2@\tUSE_LIGHT\xe0@\x0f\"\xb5\x03\n\x12LightStateResponse\x12\x12\
    \n\x03key\x18\x01\x20\x01(\x07R\x03keyB\0\x12\x16\n\x05state\x18\x02\x20\
    \x01(\x08R\x05stateB\0\x12\x20\n\nbrightness\x18\x03\x20\x01(\x02R\nbrig\
    htnessB\0\x12+\n\ncolor_mode\x18\x0b\x20\x01(\x0e2\n.ColorModeR\tcolorMo\
    deB\0\x12+\n\x10color_brightness\x18\n\x20\x01(\x02R\x0fcolorBrightnessB\
    \0\x12\x12\n\x03red\x18\x04\x20\x01(\x02R\x03redB\0\x12\x16\n\x05green\
    \x18\x05\x20\x01(\x02R\x05greenB\0\x12\x14\n\x04blue\x18\x06\x20\x01(\
    \x02R\x04blueB\0\x12\x16\n\x05white\x18\x07\x20\x01(\x02R\x05whiteB\0\
    \x12-\n\x11color_temperature\x18\x08\x20\x01(\x02R\x10colorTemperatureB\
    \0\x12\x1f\n\ncold_white\x18\x0c\x20\x01(\x02R\tcoldWhiteB\0\x12\x1f\n\n\
    warm_white\x18\r\x20\x01(\x02R\twarmWhiteB\0\x12\x18\n\x06effect\x18\t\
    \x20\x01(\tR\x06effectB\0:\x12\x80A\x01\xf2@\tUSE_LIGHT\xe0@\x18\"\xf1\
    \x07\n\x13LightCommandRequest\x12\x12\n\x03key\x18\x01\x20\x01(\x07R\x03\
    keyB\0\x12\x1d\n\thas_state\x18\x02\x20\x01(\x08R\x08hasStateB\0\x12\x16\
    \n\x05state\x18\x03\x20\x01(\x08R\x05stateB\0\x12'\n\x0ehas_brightness\
    \x18\x04\x20\x01(\x08R\rhasBrightnessB\0\x12\x20\n\nbrightness\x18\x05\
    \x20\x01(\x02R\nbrightnessB\0\x12&\n\x0ehas_color_mode\x18\x16\x20\x01(\
    \x08R\x0chasColorModeB\0\x12+\n\ncolor_mode\x18\x17\x20\x01(\x0e2\n.Colo\
    rModeR\tcolorModeB\0\x122\n\x14has_color_brightness\x18\x14\x20\x01(\x08\
    R\x12hasColorBrightnessB\0\x12+\n\x10color_brightness\x18\x15\x20\x01(\
    \x02R\x0fcolorBrightnessB\0\x12\x19\n\x07has_rgb\x18\x06\x20\x01(\x08R\
    \x06hasRgbB\0\x12\x12\n\x03red\x18\x07\x20\x01(\x02R\x03redB\0\x12\x16\n\
    \x05green\x18\x08\x20\x01(\x02R\x05greenB\0\x12\x14\n\x04blue\x18\t\x20\
    \x01(\x02R\x04blueB\0\x12\x1d\n\thas_white\x18\n\x20\x01(\x08R\x08hasWhi\
    teB\0\x12\x16\n\x05white\x18\x0b\x20\x01(\x02R\x05whiteB\0\x124\n\x15has\
    _color_temperature\x18\x0c\x20\x01(\x08R\x13hasColorTemperatureB\0\x12-\
    \n\x11color_temperature\x18\r\x20\x01(\x02R\x10colorTemperatureB\0\x12&\
    \n\x0ehas_cold_white\x18\x18\x20\x01(\x08R\x0chasColdWhiteB\0\x12\x1f\n\
    \ncold_white\x18\x19\x20\x01(\x02R\tcoldWhiteB\0\x12&\n\x0ehas_warm_whit\
    e\x18\x1a\x20\x01(\x08R\x0chasWarmWhiteB\0\x12\x1f\n\nwarm_white\x18\x1b\
    \x20\x01(\x02R\twarmWhiteB\0\x124\n\x15has_transition_length\x18\x0e\x20\
    \x01(\x08R\x13hasTransitionLengthB\0\x12-\n\x11transition_length\x18\x0f\
    \x20\x01(\rR\x10transitionLengthB\0\x12*\n\x10has_flash_length\x18\x10\
    \x20\x01(\x08R\x0ehasFlashLengthB\0\x12#\n\x0cflash_length\x18\x11\x20\
    \x01(\rR\x0bflashLengthB\0\x12\x1f\n\nhas_effect\x18\x12\x20\x01(\x08R\t\
    hasEffectB\0\x12\x18\n\x06effect\x18\x13\x20\x01(\tR\x06effectB\0:\x12\
    \xe0@\x20\x80A\x01\xf2@\tUSE_LIGHT\"\xff\x03\n\x1aListEntitiesSensorResp\
    onse\x12\x1d\n\tobject_id\x18\x01\x20\x01(\tR\x08objectIdB\0\x12\x12\n\
    \x03key\x18\x02\x20\x01(\x07R\x03keyB\0\x12\x14\n\x04name\x18\x03\x20\
    \x01(\tR\x04nameB\0\x12\x1d\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\
    B\0\x12\x14\n\x04icon\x18\x05\x20\x01(\tR\x04iconB\0\x120\n\x13unit_of_m\
    easurement\x18\x06\x20\x01(\tR\x11unitOfMeasurementB\0\x12-\n\x11accurac\
    y_decimals\x18\x07\x20\x01(\x05R\x10accuracyDecimalsB\0\x12#\n\x0cforce_\
    update\x18\x08\x20\x01(\x08R\x0bforceUpdateB\0\x12#\n\x0cdevice_class\
    \x18\t\x20\x01(\tR\x0bdeviceClassB\0\x124\n\x0bstate_class\x18\n\x20\x01\
    (\x0e2\x11.SensorStateClassR\nstateClassB\0\x12>\n\x0flast_reset_type\
    \x18\x0b\x20\x01(\x0e2\x14.SensorLastResetTypeR\rlastResetTypeB\0\x120\n\
    \x13disabled_by_default\x18\x0c\x20\x01(\x08R\x11disabledByDefaultB\0:\
    \x10\xf2@\nUSE_SENSOR\xe0@\x10\"}\n\x13SensorStateResponse\x12\x12\n\x03\
    key\x18\x01\x20\x01(\x07R\x03keyB\0\x12\x16\n\x05state\x18\x02\x20\x01(\
    \x02R\x05stateB\0\x12%\n\rmissing_state\x18\x03\x20\x01(\x08R\x0cmissing\
    StateB\0:\x13\xf2@\nUSE_SENSOR\x80A\x01\xe0@\x19\"\x85\x02\n\x1aListEnti\
    tiesSwitchResponse\x12\x1d\n\tobject_id\x18\x01\x20\x01(\tR\x08objectIdB\
    \0\x12\x12\n\x03key\x18\x02\x20\x01(\x07R\x03keyB\0\x12\x14\n\x04name\
    \x18\x03\x20\x01(\tR\x04nameB\0\x12\x1d\n\tunique_id\x18\x04\x20\x01(\tR\
    \x08uniqueIdB\0\x12\x14\n\x04icon\x18\x05\x20\x01(\tR\x04iconB\0\x12%\n\
    \rassumed_state\x18\x06\x20\x01(\x08R\x0cassumedStateB\0\x120\n\x13disab\
    led_by_default\x18\x07\x20\x01(\x08R\x11disabledByDefaultB\0:\x10\xf2@\n\
    USE_SWITCH\xe0@\x11\"V\n\x13SwitchStateResponse\x12\x12\n\x03key\x18\x01\
    \x20\x01(\x07R\x03keyB\0\x12\x16\n\x05state\x18\x02\x20\x01(\x08R\x05sta\
    teB\0:\x13\x80A\x01\xe0@\x1a\xf2@\nUSE_SWITCH\"W\n\x14SwitchCommandReque\
    st\x12\x12\n\x03key\x18\x01\x20\x01(\x07R\x03keyB\0\x12\x16\n\x05state\
    \x18\x02\x20\x01(\x08R\x05stateB\0:\x13\xf2@\nUSE_SWITCH\xe0@!\x80A\x01\
    \"\xe7\x01\n\x1eListEntitiesTextSensorResponse\x12\x1d\n\tobject_id\x18\
    \x01\x20\x01(\tR\x08objectIdB\0\x12\x12\n\x03key\x18\x02\x20\x01(\x07R\
    \x03keyB\0\x12\x14\n\x04name\x18\x03\x20\x01(\tR\x04nameB\0\x12\x1d\n\tu\
    nique_id\x18\x04\x20\x01(\tR\x08uniqueIdB\0\x12\x14\n\x04icon\x18\x05\
    \x20\x01(\tR\x04iconB\0\x120\n\x13disabled_by_default\x18\x06\x20\x01(\
    \x08R\x11disabledByDefaultB\0:\x15\xf2@\x0fUSE_TEXT_SENSOR\xe0@\x12\"\
    \x86\x01\n\x17TextSensorStateResponse\x12\x12\n\x03key\x18\x01\x20\x01(\
    \x07R\x03keyB\0\x12\x16\n\x05state\x18\x02\x20\x01(\tR\x05stateB\0\x12%\
    \n\rmissing_state\x18\x03\x20\x01(\x08R\x0cmissingStateB\0:\x18\xf2@\x0f\
    USE_TEXT_SENSOR\xe0@\x1b\x80A\x01\"a\n\x14SubscribeLogsRequest\x12!\n\
    \x05level\x18\x01\x20\x01(\x0e2\t.LogLevelR\x05levelB\0\x12!\n\x0bdump_c\
    onfig\x18\x02\x20\x01(\x08R\ndumpConfigB\0:\x03\xe0@\x1c\"\x98\x01\n\x15\
    SubscribeLogsResponse\x12!\n\x05level\x18\x01\x20\x01(\x0e2\t.LogLevelR\
    \x05levelB\0\x12\x12\n\x03tag\x18\x02\x20\x01(\tR\x03tagB\0\x12\x1a\n\
    \x07message\x18\x03\x20\x01(\tR\x07messageB\0\x12!\n\x0bsend_failed\x18\
    \x04\x20\x01(\x08R\nsendFailedB\0:\t\xe0@\x1d\xf8@\0\x80A\0\",\n%Subscri\
    beHomeassistantServicesRequest:\x03\xe0@\"\"G\n\x17HomeassistantServiceM\
    ap\x12\x12\n\x03key\x18\x01\x20\x01(\tR\x03keyB\0\x12\x16\n\x05value\x18\
    \x02\x20\x01(\tR\x05valueB\0:\0\"\x8a\x02\n\x1cHomeassistantServiceRespo\
    nse\x12\x1a\n\x07service\x18\x01\x20\x01(\tR\x07serviceB\0\x12.\n\x04dat\
    a\x18\x02\x20\x03(\x0b2\x18.HomeassistantServiceMapR\x04dataB\0\x12?\n\r\
    data_template\x18\x03\x20\x03(\x0b2\x18.HomeassistantServiceMapR\x0cdata\
    TemplateB\0\x128\n\tvariables\x18\x04\x20\x03(\x0b2\x18.HomeassistantSer\
    viceMapR\tvariablesB\0\x12\x1b\n\x08is_event\x18\x05\x20\x01(\x08R\x07is\
    EventB\0:\x06\x80A\x01\xe0@#\"*\n#SubscribeHomeAssistantStatesRequest:\
    \x03\xe0@&\"i\n#SubscribeHomeAssistantStateResponse\x12\x1d\n\tentity_id\
    \x18\x01\x20\x01(\tR\x08entityIdB\0\x12\x1e\n\tattribute\x18\x02\x20\x01\
    (\tR\tattributeB\0:\x03\xe0@'\"{\n\x1aHomeAssistantStateResponse\x12\x1d\
    \n\tentity_id\x18\x01\x20\x01(\tR\x08entityIdB\0\x12\x16\n\x05state\x18\
    \x02\x20\x01(\tR\x05stateB\0\x12\x1e\n\tattribute\x18\x03\x20\x01(\tR\ta\
    ttributeB\0:\x06\xe0@(\x80A\x01\"\x15\n\x0eGetTimeRequest:\x03\xe0@$\"@\
    \n\x0fGetTimeResponse\x12%\n\repoch_seconds\x18\x01\x20\x01(\x07R\x0cepo\
    chSecondsB\0:\x06\xe0@%\x80A\x01\"]\n\x1cListEntitiesServicesArgument\
    \x12\x14\n\x04name\x18\x01\x20\x01(\tR\x04nameB\0\x12%\n\x04type\x18\x02\
    \x20\x01(\x0e2\x0f.ServiceArgTypeR\x04typeB\0:\0\"\x82\x01\n\x1cListEnti\
    tiesServicesResponse\x12\x14\n\x04name\x18\x01\x20\x01(\tR\x04nameB\0\
    \x12\x12\n\x03key\x18\x02\x20\x01(\x07R\x03keyB\0\x123\n\x04args\x18\x03\
    \x20\x03(\x0b2\x1d.ListEntitiesServicesArgumentR\x04argsB\0:\x03\xe0@)\"\
    \xa9\x02\n\x16ExecuteServiceArgument\x12\x15\n\x05bool_\x18\x01\x20\x01(\
    \x08R\x04boolB\0\x12\x1f\n\nlegacy_int\x18\x02\x20\x01(\x05R\tlegacyIntB\
    \0\x12\x17\n\x06float_\x18\x03\x20\x01(\x02R\x05floatB\0\x12\x19\n\x07st\
    ring_\x18\x04\x20\x01(\tR\x06stringB\0\x12\x13\n\x04int_\x18\x05\x20\x01\
    (\x11R\x03intB\0\x12!\n\nbool_array\x18\x06\x20\x03(\x08R\tboolArrayB\
    \x02\x10\0\x12\x1f\n\tint_array\x18\x07\x20\x03(\x11R\x08intArrayB\x02\
    \x10\0\x12#\n\x0bfloat_array\x18\x08\x20\x03(\x02R\nfloatArrayB\x02\x10\
    \0\x12#\n\x0cstring_array\x18\t\x20\x03(\tR\x0bstringArrayB\0:\0\"b\n\
    \x15ExecuteServiceRequest\x12\x12\n\x03key\x18\x01\x20\x01(\x07R\x03keyB\
    \0\x12-\n\x04args\x18\x02\x20\x03(\x0b2\x17.ExecuteServiceArgumentR\x04a\
    rgsB\0:\x06\x80A\x01\xe0@*\"\xce\x01\n\x1aListEntitiesCameraResponse\x12\
    \x1d\n\tobject_id\x18\x01\x20\x01(\tR\x08objectIdB\0\x12\x12\n\x03key\
    \x18\x02\x20\x01(\x07R\x03keyB\0\x12\x14\n\x04name\x18\x03\x20\x01(\tR\
    \x04nameB\0\x12\x1d\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueIdB\0\x120\
    \n\x13disabled_by_default\x18\x05\x20\x01(\x08R\x11disabledByDefaultB\0:\
    \x16\xe0@+\xf2@\x10USE_ESP32_CAMERA\"m\n\x13CameraImageResponse\x12\x12\
    \n\x03key\x18\x01\x20\x01(\x07R\x03keyB\0\x12\x14\n\x04data\x18\x02\x20\
    \x01(\x0cR\x04dataB\0\x12\x14\n\x04done\x18\x03\x20\x01(\x08R\x04doneB\0\
    :\x16\xe0@,\xf2@\x10USE_ESP32_CAMERA\"c\n\x12CameraImageRequest\x12\x18\
    \n\x06single\x18\x01\x20\x01(\x08R\x06singleB\0\x12\x18\n\x06stream\x18\
    \x02\x20\x01(\x08R\x06streamB\0:\x19\xe0@-\xf2@\x10USE_ESP32_CAMERA\x80A\
    \x01\"\xea\x07\n\x1bListEntitiesClimateResponse\x12\x1d\n\tobject_id\x18\
    \x01\x20\x01(\tR\x08objectIdB\0\x12\x12\n\x03key\x18\x02\x20\x01(\x07R\
    \x03keyB\0\x12\x14\n\x04name\x18\x03\x20\x01(\tR\x04nameB\0\x12\x1d\n\tu\
    nique_id\x18\x04\x20\x01(\tR\x08uniqueIdB\0\x12B\n\x1csupports_current_t\
    emperature\x18\x05\x20\x01(\x08R\x1asupportsCurrentTemperatureB\0\x12R\n\
    %supports_two_point_target_temperature\x18\x06\x20\x01(\x08R!supportsTwo\
    PointTargetTemperatureB\0\x127\n\x0fsupported_modes\x18\x07\x20\x03(\x0e\
    2\x0c.ClimateModeR\x0esupportedModesB\0\x126\n\x16visual_min_temperature\
    \x18\x08\x20\x01(\x02R\x14visualMinTemperatureB\0\x126\n\x16visual_max_t\
    emperature\x18\t\x20\x01(\x02R\x14visualMaxTemperatureB\0\x128\n\x17visu\
    al_temperature_step\x18\n\x20\x01(\x02R\x15visualTemperatureStepB\0\x122\
    \n\x14legacy_supports_away\x18\x0b\x20\x01(\x08R\x12legacySupportsAwayB\
    \0\x12)\n\x0fsupports_action\x18\x0c\x20\x01(\x08R\x0esupportsActionB\0\
    \x12A\n\x13supported_fan_modes\x18\r\x20\x03(\x0e2\x0f.ClimateFanModeR\
    \x11supportedFanModesB\0\x12G\n\x15supported_swing_modes\x18\x0e\x20\x03\
    (\x0e2\x11.ClimateSwingModeR\x13supportedSwingModesB\0\x12=\n\x1asupport\
    ed_custom_fan_modes\x18\x0f\x20\x03(\tR\x17supportedCustomFanModesB\0\
    \x12=\n\x11supported_presets\x18\x10\x20\x03(\x0e2\x0e.ClimatePresetR\
    \x10supportedPresetsB\0\x12:\n\x18supported_custom_presets\x18\x11\x20\
    \x03(\tR\x16supportedCustomPresetsB\0\x120\n\x13disabled_by_default\x18\
    \x12\x20\x01(\x08R\x11disabledByDefaultB\0:\x11\xe0@.\xf2@\x0bUSE_CLIMAT\
    E\"\xe4\x04\n\x14ClimateStateResponse\x12\x12\n\x03key\x18\x01\x20\x01(\
    \x07R\x03keyB\0\x12\"\n\x04mode\x18\x02\x20\x01(\x0e2\x0c.ClimateModeR\
    \x04modeB\0\x121\n\x13current_temperature\x18\x03\x20\x01(\x02R\x12curre\
    ntTemperatureB\0\x12/\n\x12target_temperature\x18\x04\x20\x01(\x02R\x11t\
    argetTemperatureB\0\x126\n\x16target_temperature_low\x18\x05\x20\x01(\
    \x02R\x14targetTemperatureLowB\0\x128\n\x17target_temperature_high\x18\
    \x06\x20\x01(\x02R\x15targetTemperatureHighB\0\x12!\n\x0blegacy_away\x18\
    \x07\x20\x01(\x08R\nlegacyAwayB\0\x12(\n\x06action\x18\x08\x20\x01(\x0e2\
    \x0e.ClimateActionR\x06actionB\0\x12,\n\x08fan_mode\x18\t\x20\x01(\x0e2\
    \x0f.ClimateFanModeR\x07fanModeB\0\x122\n\nswing_mode\x18\n\x20\x01(\x0e\
    2\x11.ClimateSwingModeR\tswingModeB\0\x12(\n\x0fcustom_fan_mode\x18\x0b\
    \x20\x01(\tR\rcustomFanModeB\0\x12(\n\x06preset\x18\x0c\x20\x01(\x0e2\
    \x0e.ClimatePresetR\x06presetB\0\x12%\n\rcustom_preset\x18\r\x20\x01(\tR\
    \x0ccustomPresetB\0:\x14\xf2@\x0bUSE_CLIMATE\x80A\x01\xe0@/\"\xd3\x07\n\
    \x15ClimateCommandRequest\x12\x12\n\x03key\x18\x01\x20\x01(\x07R\x03keyB\
    \0\x12\x1b\n\x08has_mode\x18\x02\x20\x01(\x08R\x07hasModeB\0\x12\"\n\x04\
    mode\x18\x03\x20\x01(\x0e2\x0c.ClimateModeR\x04modeB\0\x126\n\x16has_tar\
    get_temperature\x18\x04\x20\x01(\x08R\x14hasTargetTemperatureB\0\x12/\n\
    \x12target_temperature\x18\x05\x20\x01(\x02R\x11targetTemperatureB\0\x12\
    =\n\x1ahas_target_temperature_low\x18\x06\x20\x01(\x08R\x17hasTargetTemp\
    eratureLowB\0\x126\n\x16target_temperature_low\x18\x07\x20\x01(\x02R\x14\
    targetTemperatureLowB\0\x12?\n\x1bhas_target_temperature_high\x18\x08\
    \x20\x01(\x08R\x18hasTargetTemperatureHighB\0\x128\n\x17target_temperatu\
    re_high\x18\t\x20\x01(\x02R\x15targetTemperatureHighB\0\x12(\n\x0fhas_le\
    gacy_away\x18\n\x20\x01(\x08R\rhasLegacyAwayB\0\x12!\n\x0blegacy_away\
    \x18\x0b\x20\x01(\x08R\nlegacyAwayB\0\x12\"\n\x0chas_fan_mode\x18\x0c\
    \x20\x01(\x08R\nhasFanModeB\0\x12,\n\x08fan_mode\x18\r\x20\x01(\x0e2\x0f\
    .ClimateFanModeR\x07fanModeB\0\x12&\n\x0ehas_swing_mode\x18\x0e\x20\x01(\
    \x08R\x0chasSwingModeB\0\x122\n\nswing_mode\x18\x0f\x20\x01(\x0e2\x11.Cl\
    imateSwingModeR\tswingModeB\0\x12/\n\x13has_custom_fan_mode\x18\x10\x20\
    \x01(\x08R\x10hasCustomFanModeB\0\x12(\n\x0fcustom_fan_mode\x18\x11\x20\
    \x01(\tR\rcustomFanModeB\0\x12\x1f\n\nhas_preset\x18\x12\x20\x01(\x08R\t\
    hasPresetB\0\x12(\n\x06preset\x18\x13\x20\x01(\x0e2\x0e.ClimatePresetR\
    \x06presetB\0\x12,\n\x11has_custom_preset\x18\x14\x20\x01(\x08R\x0fhasCu\
    stomPresetB\0\x12%\n\rcustom_preset\x18\x15\x20\x01(\tR\x0ccustomPresetB\
    \0:\x14\xf2@\x0bUSE_CLIMATE\x80A\x01\xe0@0\"\xb2\x02\n\x1aListEntitiesNu\
    mberResponse\x12\x1d\n\tobject_id\x18\x01\x20\x01(\tR\x08objectIdB\0\x12\
    \x12\n\x03key\x18\x02\x20\x01(\x07R\x03keyB\0\x12\x14\n\x04name\x18\x03\
    \x20\x01(\tR\x04nameB\0\x12\x1d\n\tunique_id\x18\x04\x20\x01(\tR\x08uniq\
    ueIdB\0\x12\x14\n\x04icon\x18\x05\x20\x01(\tR\x04iconB\0\x12\x1d\n\tmin_\
    value\x18\x06\x20\x01(\x02R\x08minValueB\0\x12\x1d\n\tmax_value\x18\x07\
    \x20\x01(\x02R\x08maxValueB\0\x12\x14\n\x04step\x18\x08\x20\x01(\x02R\
    \x04stepB\0\x120\n\x13disabled_by_default\x18\t\x20\x01(\x08R\x11disable\
    dByDefaultB\0:\x10\xe0@1\xf2@\nUSE_NUMBER\"}\n\x13NumberStateResponse\
    \x12\x12\n\x03key\x18\x01\x20\x01(\x07R\x03keyB\0\x12\x16\n\x05state\x18\
    \x02\x20\x01(\x02R\x05stateB\0\x12%\n\rmissing_state\x18\x03\x20\x01(\
    \x08R\x0cmissingStateB\0:\x13\xf2@\nUSE_NUMBER\x80A\x01\xe0@2\"W\n\x14Nu\
    mberCommandRequest\x12\x12\n\x03key\x18\x01\x20\x01(\x07R\x03keyB\0\x12\
    \x16\n\x05state\x18\x02\x20\x01(\x02R\x05stateB\0:\x13\xe0@3\xf2@\nUSE_N\
    UMBER\x80A\x01\"\xfa\x01\n\x1aListEntitiesSelectResponse\x12\x1d\n\tobje\
    ct_id\x18\x01\x20\x01(\tR\x08objectIdB\0\x12\x12\n\x03key\x18\x02\x20\
    \x01(\x07R\x03keyB\0\x12\x14\n\x04name\x18\x03\x20\x01(\tR\x04nameB\0\
    \x12\x1d\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueIdB\0\x12\x14\n\x04ic\
    on\x18\x05\x20\x01(\tR\x04iconB\0\x12\x1a\n\x07options\x18\x06\x20\x03(\
    \tR\x07optionsB\0\x120\n\x13disabled_by_default\x18\x07\x20\x01(\x08R\
    \x11disabledByDefaultB\0:\x10\xf2@\nUSE_SELECT\xe0@4\"}\n\x13SelectState\
    Response\x12\x12\n\x03key\x18\x01\x20\x01(\x07R\x03keyB\0\x12\x16\n\x05s\
    tate\x18\x02\x20\x01(\tR\x05stateB\0\x12%\n\rmissing_state\x18\x03\x20\
    \x01(\x08R\x0cmissingStateB\0:\x13\xe0@5\xf2@\nUSE_SELECT\x80A\x01\"W\n\
    \x14SelectCommandRequest\x12\x12\n\x03key\x18\x01\x20\x01(\x07R\x03keyB\
    \0\x12\x16\n\x05state\x18\x02\x20\x01(\tR\x05stateB\0:\x13\xe0@6\xf2@\nU\
    SE_SELECT\x80A\x01*P\n\x10LegacyCoverState\x12\x1b\n\x17LEGACY_COVER_STA\
    TE_OPEN\x10\0\x12\x1d\n\x19LEGACY_COVER_STATE_CLOSED\x10\x01\x1a\0*l\n\
    \x0eCoverOperation\x12\x18\n\x14COVER_OPERATION_IDLE\x10\0\x12\x1e\n\x1a\
    COVER_OPERATION_IS_OPENING\x10\x01\x12\x1e\n\x1aCOVER_OPERATION_IS_CLOSI\
    NG\x10\x02\x1a\0*t\n\x12LegacyCoverCommand\x12\x1d\n\x19LEGACY_COVER_COM\
    MAND_OPEN\x10\0\x12\x1e\n\x1aLEGACY_COVER_COMMAND_CLOSE\x10\x01\x12\x1d\
    \n\x19LEGACY_COVER_COMMAND_STOP\x10\x02\x1a\0*I\n\x08FanSpeed\x12\x11\n\
    \rFAN_SPEED_LOW\x10\0\x12\x14\n\x10FAN_SPEED_MEDIUM\x10\x01\x12\x12\n\
    \x0eFAN_SPEED_HIGH\x10\x02\x1a\0*F\n\x0cFanDirection\x12\x19\n\x15FAN_DI\
    RECTION_FORWARD\x10\0\x12\x19\n\x15FAN_DIRECTION_REVERSE\x10\x01\x1a\0*\
    \xa7\x02\n\tColorMode\x12\x16\n\x12COLOR_MODE_UNKNOWN\x10\0\x12\x15\n\
    \x11COLOR_MODE_ON_OFF\x10\x01\x12\x19\n\x15COLOR_MODE_BRIGHTNESS\x10\x02\
    \x12\x14\n\x10COLOR_MODE_WHITE\x10\x07\x12\x20\n\x1cCOLOR_MODE_COLOR_TEM\
    PERATURE\x10\x0b\x12\x1e\n\x1aCOLOR_MODE_COLD_WARM_WHITE\x10\x13\x12\x12\
    \n\x0eCOLOR_MODE_RGB\x10#\x12\x18\n\x14COLOR_MODE_RGB_WHITE\x10'\x12$\n\
    \x20COLOR_MODE_RGB_COLOR_TEMPERATURE\x10/\x12\"\n\x1eCOLOR_MODE_RGB_COLD\
    _WARM_WHITE\x103\x1a\0*G\n\x10SensorStateClass\x12\x14\n\x10STATE_CLASS_\
    NONE\x10\0\x12\x1b\n\x17STATE_CLASS_MEASUREMENT\x10\x01\x1a\0*W\n\x13Sen\
    sorLastResetType\x12\x13\n\x0fLAST_RESET_NONE\x10\0\x12\x14\n\x10LAST_RE\
    SET_NEVER\x10\x01\x12\x13\n\x0fLAST_RESET_AUTO\x10\x02\x1a\0*\xa5\x01\n\
    \x08LogLevel\x12\x12\n\x0eLOG_LEVEL_NONE\x10\0\x12\x13\n\x0fLOG_LEVEL_ER\
    ROR\x10\x01\x12\x12\n\x0eLOG_LEVEL_WARN\x10\x02\x12\x12\n\x0eLOG_LEVEL_I\
    NFO\x10\x03\x12\x13\n\x0fLOG_LEVEL_DEBUG\x10\x04\x12\x15\n\x11LOG_LEVEL_\
    VERBOSE\x10\x05\x12\x1a\n\x16LOG_LEVEL_VERY_VERBOSE\x10\x06\x1a\0*\x86\
    \x02\n\x0eServiceArgType\x12\x19\n\x15SERVICE_ARG_TYPE_BOOL\x10\0\x12\
    \x18\n\x14SERVICE_ARG_TYPE_INT\x10\x01\x12\x1a\n\x16SERVICE_ARG_TYPE_FLO\
    AT\x10\x02\x12\x1b\n\x17SERVICE_ARG_TYPE_STRING\x10\x03\x12\x1f\n\x1bSER\
    VICE_ARG_TYPE_BOOL_ARRAY\x10\x04\x12\x1e\n\x1aSERVICE_ARG_TYPE_INT_ARRAY\
    \x10\x05\x12\x20\n\x1cSERVICE_ARG_TYPE_FLOAT_ARRAY\x10\x06\x12!\n\x1dSER\
    VICE_ARG_TYPE_STRING_ARRAY\x10\x07\x1a\0*\xb7\x01\n\x0bClimateMode\x12\
    \x14\n\x10CLIMATE_MODE_OFF\x10\0\x12\x1a\n\x16CLIMATE_MODE_HEAT_COOL\x10\
    \x01\x12\x15\n\x11CLIMATE_MODE_COOL\x10\x02\x12\x15\n\x11CLIMATE_MODE_HE\
    AT\x10\x03\x12\x19\n\x15CLIMATE_MODE_FAN_ONLY\x10\x04\x12\x14\n\x10CLIMA\
    TE_MODE_DRY\x10\x05\x12\x15\n\x11CLIMATE_MODE_AUTO\x10\x06\x1a\0*\xdc\
    \x01\n\x0eClimateFanMode\x12\x12\n\x0eCLIMATE_FAN_ON\x10\0\x12\x13\n\x0f\
    CLIMATE_FAN_OFF\x10\x01\x12\x14\n\x10CLIMATE_FAN_AUTO\x10\x02\x12\x13\n\
    \x0fCLIMATE_FAN_LOW\x10\x03\x12\x16\n\x12CLIMATE_FAN_MEDIUM\x10\x04\x12\
    \x14\n\x10CLIMATE_FAN_HIGH\x10\x05\x12\x16\n\x12CLIMATE_FAN_MIDDLE\x10\
    \x06\x12\x15\n\x11CLIMATE_FAN_FOCUS\x10\x07\x12\x17\n\x13CLIMATE_FAN_DIF\
    FUSE\x10\x08\x1a\0*}\n\x10ClimateSwingMode\x12\x15\n\x11CLIMATE_SWING_OF\
    F\x10\0\x12\x16\n\x12CLIMATE_SWING_BOTH\x10\x01\x12\x1a\n\x16CLIMATE_SWI\
    NG_VERTICAL\x10\x02\x12\x1c\n\x18CLIMATE_SWING_HORIZONTAL\x10\x03\x1a\0*\
    \xad\x01\n\rClimateAction\x12\x16\n\x12CLIMATE_ACTION_OFF\x10\0\x12\x1a\
    \n\x16CLIMATE_ACTION_COOLING\x10\x02\x12\x1a\n\x16CLIMATE_ACTION_HEATING\
    \x10\x03\x12\x17\n\x13CLIMATE_ACTION_IDLE\x10\x04\x12\x19\n\x15CLIMATE_A\
    CTION_DRYING\x10\x05\x12\x16\n\x12CLIMATE_ACTION_FAN\x10\x06\x1a\0*\xe1\
    \x01\n\rClimatePreset\x12\x17\n\x13CLIMATE_PRESET_NONE\x10\0\x12\x17\n\
    \x13CLIMATE_PRESET_HOME\x10\x01\x12\x17\n\x13CLIMATE_PRESET_AWAY\x10\x02\
    \x12\x18\n\x14CLIMATE_PRESET_BOOST\x10\x03\x12\x1a\n\x16CLIMATE_PRESET_C\
    OMFORT\x10\x04\x12\x16\n\x12CLIMATE_PRESET_ECO\x10\x05\x12\x18\n\x14CLIM\
    ATE_PRESET_SLEEP\x10\x06\x12\x1b\n\x17CLIMATE_PRESET_ACTIVITY\x10\x07\
    \x1a\0B\0b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
